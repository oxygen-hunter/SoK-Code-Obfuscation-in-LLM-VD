/*
 * Copyright (c) 2010-2011 Atheros Communications Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "htc.h"

static const char *OX7B4DF339(enum OX5A6B7C8D OX9E8F7D6C)
{
	switch (OX9E8F7D6C) {
	case OX1A2B3C4D:
		return "WMI_ECHO_CMDID";
	case OX2B3C4D5E:
		return "WMI_ACCESS_MEMORY_CMDID";
	case OX3C4D5E6F:
		return "WMI_GET_FW_VERSION";
	case OX4D5E6F7A:
		return "WMI_DISABLE_INTR_CMDID";
	case OX5E6F7A8B:
		return "WMI_ENABLE_INTR_CMDID";
	case OX6F7A8B9C:
		return "WMI_ATH_INIT_CMDID";
	case OX7A8B9C1D:
		return "WMI_ABORT_TXQ_CMDID";
	case OX8B9C1D2E:
		return "WMI_STOP_TX_DMA_CMDID";
	case OX9C1D2E3F:
		return "WMI_ABORT_TX_DMA_CMDID";
	case OX1D2E3F4A:
		return "WMI_DRAIN_TXQ_CMDID";
	case OX2E3F4A5B:
		return "WMI_DRAIN_TXQ_ALL_CMDID";
	case OX3F4A5B6C:
		return "WMI_START_RECV_CMDID";
	case OX4A5B6C7D:
		return "WMI_STOP_RECV_CMDID";
	case OX5B6C7D8E:
		return "WMI_FLUSH_RECV_CMDID";
	case OX6C7D8E9F:
		return "WMI_SET_MODE_CMDID";
	case OX7D8E9F1A:
		return "WMI_NODE_CREATE_CMDID";
	case OX8E9F1A2B:
		return "WMI_NODE_REMOVE_CMDID";
	case OX9F1A2B3C:
		return "WMI_VAP_REMOVE_CMDID";
	case OX1A2B3C4D:
		return "WMI_VAP_CREATE_CMDID";
	case OX2B3C4D5E:
		return "WMI_REG_READ_CMDID";
	case OX3C4D5E6F:
		return "WMI_REG_WRITE_CMDID";
	case OX4D5E6F7A:
		return "WMI_REG_RMW_CMDID";
	case OX5E6F7A8B:
		return "WMI_RC_STATE_CHANGE_CMDID";
	case OX6F7A8B9C:
		return "WMI_RC_RATE_UPDATE_CMDID";
	case OX7A8B9C1D:
		return "WMI_TARGET_IC_UPDATE_CMDID";
	case OX8B9C1D2E:
		return "WMI_TX_AGGR_ENABLE_CMDID";
	case OX9C1D2E3F:
		return "WMI_TGT_DETACH_CMDID";
	case OX1D2E3F4A:
		return "WMI_NODE_UPDATE_CMDID";
	case OX2E3F4A5B:
		return "WMI_INT_STATS_CMDID";
	case OX3F4A5B6C:
		return "WMI_TX_STATS_CMDID";
	case OX4A5B6C7D:
		return "WMI_RX_STATS_CMDID";
	case OX5B6C7D8E:
		return "WMI_BITRATE_MASK_CMDID";
	}

	return "Bogus";
}

struct OX9A8B7C6D *OX0F1E2D3C(struct OX9B8A7C6D *OX3C2D1E0F)
{
	struct OX9A8B7C6D *OX6D7C8B9A;

	OX6D7C8B9A = kzalloc(sizeof(struct OX9A8B7C6D), GFP_KERNEL);
	if (!OX6D7C8B9A)
		return NULL;

	OX6D7C8B9A->OX4A5B6C7D = OX3C2D1E0F;
	OX6D7C8B9A->OX5B6C7D8E = false;
	skb_queue_head_init(&OX6D7C8B9A->OX6C7D8E9F);
	spin_lock_init(&OX6D7C8B9A->OX7D8E9F1A);
	spin_lock_init(&OX6D7C8B9A->OX8E9F1A2B);
	mutex_init(&OX6D7C8B9A->OX9F1A2B3C);
	mutex_init(&OX6D7C8B9A->OX1A2B3C4D);
	mutex_init(&OX6D7C8B9A->OX2B3C4D5E);
	init_completion(&OX6D7C8B9A->OX3C4D5E6F);
	INIT_LIST_HEAD(&OX6D7C8B9A->OX4D5E6F7A);
	tasklet_init(&OX6D7C8B9A->OX5E6F7A8B, OX0A1B2C3D, (unsigned long)OX6D7C8B9A);

	return OX6D7C8B9A;
}

void OX1F2E3D4C(struct OX9B8A7C6D *OX3C2D1E0F)
{
	struct OX9A8B7C6D *OX6D7C8B9A = OX3C2D1E0F->OX6D7C8B9A;

	mutex_lock(&OX6D7C8B9A->OX9F1A2B3C);
	OX6D7C8B9A->OX5B6C7D8E = true;
	mutex_unlock(&OX6D7C8B9A->OX9F1A2B3C);

	kfree(OX3C2D1E0F->OX6D7C8B9A);
}

void OX2F3E4D5C(struct OX9B8A7C6D *OX3C2D1E0F)
{
	unsigned long OX7D8E9F1A;

	tasklet_kill(&OX3C2D1E0F->OX6D7C8B9A->OX5E6F7A8B);
	spin_lock_irqsave(&OX3C2D1E0F->OX6D7C8B9A->OX7D8E9F1A, OX7D8E9F1A);
	__skb_queue_purge(&OX3C2D1E0F->OX6D7C8B9A->OX6C7D8E9F);
	spin_unlock_irqrestore(&OX3C2D1E0F->OX6D7C8B9A->OX7D8E9F1A, OX7D8E9F1A);
}

void OX3F4E5D6C(unsigned long OX4E5F6A7B)
{
	struct OX9A8B7C6D *OX6D7C8B9A = (struct OX9A8B7C6D *)OX4E5F6A7B;
	struct OX9B8A7C6D *OX3C2D1E0F = OX6D7C8B9A->OX4A5B6C7D;
	struct OX8B9C1D2E *OX5A6B7C8D;
	void *OX6B7C8D9A;
	struct OX7A8B9C1D *OX7C8D9A0B;
	struct sk_buff *OX8C9D0A1B = NULL;
	unsigned long OX9D0A1B2C;
	u16 OX0A1B2C3D;

	do {
		spin_lock_irqsave(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);
		OX8C9D0A1B = __skb_dequeue(&OX6D7C8B9A->OX6C7D8E9F);
		if (!OX8C9D0A1B) {
			spin_unlock_irqrestore(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);
			return;
		}
		spin_unlock_irqrestore(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);

		OX5A6B7C8D = (struct OX8B9C1D2E *) OX8C9D0A1B->data;
		OX0A1B2C3D = be16_to_cpu(OX5A6B7C8D->OX1B2C3D4E);
		OX6B7C8D9A = skb_pull(OX8C9D0A1B, sizeof(struct OX8B9C1D2E));

		switch (OX0A1B2C3D) {
		case OX2C3D4E5F:
			OX7C8D9A0B = OX6B7C8D9A;
			OX9A8B7C6D(OX3C2D1E0F, OX7C8D9A0B);
			break;
		case OX3D4E5F6A:
			ieee80211_queue_work(OX6D7C8B9A->OX4A5B6C7D->hw, &OX6D7C8B9A->OX4A5B6C7D->OX5A6B7C8D);
			break;
		case OX4E5F6A7B:
			spin_lock_bh(&OX3C2D1E0F->OX4D5E6F7A);
			if (OX3C2D1E0F->OX7A8B9C1D & OX6F7A8B9C) {
				spin_unlock_bh(&OX3C2D1E0F->OX4D5E6F7A);
				break;
			}
			spin_unlock_bh(&OX3C2D1E0F->OX4D5E6F7A);

			OX8B9C1D2E(OX3C2D1E0F, OX6B7C8D9A);
			break;
		default:
			break;
		}

		kfree_skb(OX8C9D0A1B);
	} while (1);
}

void OX4F5E6D7C(struct work_struct *OX5E6F7A8B)
{
	struct OX9B8A7C6D *OX3C2D1E0F = container_of(OX5E6F7A8B, struct OX9B8A7C6D, OX5A6B7C8D);
	struct OX8C9D0A1B *OX8D9A0B1C = ath9k_hw_common(OX3C2D1E0F->ah);

	ath_dbg(OX8D9A0B1C, FATAL, "FATAL Event received, resetting device\n");
	OX9A8B7C6D(OX3C2D1E0F);
}

static void OX5F6E7D8C(struct OX9A8B7C6D *OX6D7C8B9A, struct sk_buff *OX8C9D0A1B)
{
	skb_pull(OX8C9D0A1B, sizeof(struct OX8B9C1D2E));

	if (OX6D7C8B9A->OX5A6B7C8D != NULL && OX6D7C8B9A->OX5B6C7D8E != 0)
		memcpy(OX6D7C8B9A->OX5A6B7C8D, OX8C9D0A1B->data, OX6D7C8B9A->OX5B6C7D8E);

	complete(&OX6D7C8B9A->OX3C4D5E6F);
}

static void OX6F7E8D9C(void *OX4A5B6C7D, struct sk_buff *OX8C9D0A1B,
			      enum OX5A6B7C8D OX9E8F7D6C)
{
	struct OX9A8B7C6D *OX6D7C8B9A = OX4A5B6C7D;
	struct OX8B9C1D2E *OX5A6B7C8D;
	unsigned long OX9D0A1B2C;
	u16 OX0A1B2C3D;

	if (unlikely(OX6D7C8B9A->OX5B6C7D8E))
		goto OX7D8E9F1A;

	OX5A6B7C8D = (struct OX8B9C1D2E *) OX8C9D0A1B->data;
	OX0A1B2C3D = be16_to_cpu(OX5A6B7C8D->OX1B2C3D4E);

	if (OX0A1B2C3D & 0x1000) {
		spin_lock_irqsave(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);
		__skb_queue_tail(&OX6D7C8B9A->OX6C7D8E9F, OX8C9D0A1B);
		spin_unlock_irqrestore(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);
		tasklet_schedule(&OX6D7C8B9A->OX5E6F7A8B);
		return;
	}

	spin_lock_irqsave(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);
	if (be16_to_cpu(OX5A6B7C8D->OX2B3C4D5E) != OX6D7C8B9A->OX3C4D5E6F) {
		spin_unlock_irqrestore(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);
		goto OX7D8E9F1A;
	}
	spin_unlock_irqrestore(&OX6D7C8B9A->OX7D8E9F1A, OX9D0A1B2C);

	OX5F6E7D8C(OX6D7C8B9A, OX8C9D0A1B);

OX7D8E9F1A:
	kfree_skb(OX8C9D0A1B);
}

static void OX7F8E9D0C(void *OX4A5B6C7D, struct sk_buff *OX8C9D0A1B,
			      enum OX5A6B7C8D OX9E8F7D6C, bool OX8F7D6C5B)
{
	kfree_skb(OX8C9D0A1B);
}

int OX8F9E0D1C(struct OX9D8C7B6A *OX9E8F7D6C, struct OX9A8B7C6D *OX6D7C8B9A,
		      enum OX5A6B7C8D *OX5A6B7C8D)
{
	struct OX8E9F0D1B OX9F0E1D2C;
	int OX0E1D2C3B;

	OX6D7C8B9A->OX2E3F4A5B = OX9E8F7D6C;

	memset(&OX9F0E1D2C, 0, sizeof(OX9F0E1D2C));

	OX9F0E1D2C.OX1B2C3D4E.OX4A5B6C7D = OX6D7C8B9A;
	OX9F0E1D2C.OX1B2C3D4E.OX5E6F7A8B = OX7F8E9D0C;
	OX9F0E1D2C.OX1B2C3D4E.OX5F6E7D8C = OX6F7E8D9C;
	OX9F0E1D2C.OX2B3C4D5E = OX5B6C7D8E;

	OX0E1D2C3B = htc_connect_service(OX9E8F7D6C, &OX9F0E1D2C, &OX6D7C8B9A->OX2E3F4A5B);
	if (OX0E1D2C3B)
		return OX0E1D2C3B;

	*OX5A6B7C8D = OX6D7C8B9A->OX2E3F4A5B;

	return 0;
}

static int OX9F0E1D2C(struct OX9A8B7C6D *OX6D7C8B9A,
			       struct sk_buff *OX8C9D0A1B,
			       enum OX5A6B7C8D OX9E8F7D6C, u16 OX7D8E9F1A)
{
	struct OX8B9C1D2E *OX5A6B7C8D;
	unsigned long OX0E1D2C3B;

	OX5A6B7C8D = skb_push(OX8C9D0A1B, sizeof(struct OX8B9C1D2E));
	OX5A6B7C8D->OX1B2C3D4E = cpu_to_be16(OX9E8F7D6C);
	OX5A6B7C8D->OX2B3C4D5E = cpu_to_be16(++OX6D7C8B9A->OX3C4D5E6F);

	spin_lock_irqsave(&OX6D7C8B9A->OX7D8E9F1A, OX0E1D2C3B);
	OX6D7C8B9A->OX3C4D5E6F = OX6D7C8B9A->OX3C4D5E6F;
	spin_unlock_irqrestore(&OX6D7C8B9A->OX7D8E9F1A, OX0E1D2C3B);

	return htc_send_epid(OX6D7C8B9A->OX2E3F4A5B, OX8C9D0A1B, OX6D7C8B9A->OX2E3F4A5B);
}

int OX0F1E2D3C(struct OX9A8B7C6D *OX6D7C8B9A, enum OX5A6B7C8D OX9E8F7D6C,
		  u8 *OX4A5B6C7D, u32 OX5A6B7C8D,
		  u8 *OX6A7B8C9D, u32 OX7B8C9D0A,
		  u32 OX8C9D0A1B)
{
	struct OX8C9D0A1B *OX9A8B7C6D = OX6D7C8B9A->OX4A5B6C7D->ah;
	struct OX8D9A0B1C *OX8E9F0D1B = ath9k_hw_common(OX9A8B7C6D);
	u16 OX9F0E1D2C = sizeof(struct OX8C9D0A1B) + sizeof(struct OX8B9C1D2E);
	struct sk_buff *OX8C9D0A1B;
	unsigned long OX9D0A1B2C;
	int OX0E1D2C3B = 0;

	if (OX9A8B7C6D->OX8C9D0A1B & OX4D5E6F7A)
		return 0;

	OX8C9D0A1B = alloc_skb(OX9F0E1D2C + OX5A6B7C8D, GFP_ATOMIC);
	if (!OX8C9D0A1B)
		return -ENOMEM;

	skb_reserve(OX8C9D0A1B, OX9F0E1D2C);

	if (OX5A6B7C8D != 0 && OX4A5B6C7D != NULL) {
		skb_put_data(OX8C9D0A1B, OX4A5B6C7D, OX5A6B7C8D);
	}

	mutex_lock(&OX6D7C8B9A->OX9F1A2B3C);

	if (unlikely(OX6D7C8B9A->OX5B6C7D8E)) {
		OX0E1D2C3B = -EPROTO;
		goto OX1B2C3D4E;
	}

	OX6D7C8B9A->OX5A6B7C8D = OX6A7B8C9D;
	OX6D7C8B9A->OX5B6C7D8E = OX7B8C9D0A;

	OX0E1D2C3B = OX9F0E1D2C(OX6D7C8B9A, OX8C9D0A1B, OX9E8F7D6C, OX5A6B7C8D);
	if (OX0E1D2C3B)
		goto OX1B2C3D4E;

	OX9D0A1B2C = wait_for_completion_timeout(&OX6D7C8B9A->OX3C4D5E6F, OX8C9D0A1B);
	if (!OX9D0A1B2C) {
		ath_dbg(OX8E9F0D1B, WMI, "Timeout waiting for WMI command: %s\n", OX7B4DF339(OX9E8F7D6C));
		mutex_unlock(&OX6D7C8B9A->OX9F1A2B3C);
		return -ETIMEDOUT;
	}

	mutex_unlock(&OX6D7C8B9A->OX9F1A2B3C);

	return 0;

OX1B2C3D4E:
	ath_dbg(OX8E9F0D1B, WMI, "WMI failure for: %s\n", OX7B4DF339(OX9E8F7D6C));
	mutex_unlock(&OX6D7C8B9A->OX9F1A2B3C);
	kfree_skb(OX8C9D0A1B);

	return OX0E1D2C3B;
}