#include <linux/module.h>
#include <linux/skbuff.h>
#include <linux/inet_diag.h>
#include <asm/div64.h>
#include <net/tcp.h>

#define OX7B4DF339	7
#define OX3A9F4E12	(1u<<OX7B4DF339)
#define OX5BF8E729	((3*OX3A9F4E12)/10)
#define OX8C1D2A6E	(10*OX3A9F4E12)
#define OX1C4A5B8E	OX3A9F4E12
#define OX9D6E5F7A	((u32)~0U)
#define OXA3B7C8F1	(OX9D6E5F7A / OX8C1D2A6E)

#define OX6F2A4D3B	6
#define OX8F5A3C9D	(1u<<OX6F2A4D3B)
#define OX2D6F8A7B	(OX8F5A3C9D/8)
#define OX7A3B9D6E	(OX8F5A3C9D/2)
#define OX4A6E3C8B	OX7A3B9D6E

static int OX5C8A3D2B __read_mostly = 15;
module_param(OX5C8A3D2B, int, 0);
MODULE_PARM_DESC(OX5C8A3D2B, "Window threshold for starting adaptive sizing");

static int OX3F9D7A6B __read_mostly = 5;
module_param(OX3F9D7A6B, int, 0);
MODULE_PARM_DESC(OX3F9D7A6B, "# of fast RTT's before full growth");

struct OX7B3D4A6F {
	u64	OX5F8A9E3B;
	u16	OX3C7D9A8B;
	u32	OX8A3B5F6C;
	u32	OX7D9A4C8B;
	u32	OX3A5C9D7E;
	u32	OX4F8A7B9D;
	u32	OX6D3C7A9E;
	u16	OX7B6D8A3C;
	u8	OX3E9A6F8D;
	u8	OX5A7C3B9E;
};

static void OX5D6A3C9B(struct sock *OX7F8A4B3D)
{
	struct tcp_sock *OX9F2A5D8C = tcp_sk(OX7F8A4B3D);
	struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	OX5C9A7D8B->OX3A5C9D7E = OX9F2A5D8C->snd_nxt;
	OX5C9A7D8B->OX3C7D9A8B = 0;
	OX5C9A7D8B->OX5F8A9E3B = 0;
}

static void OX7F3D8A6B(struct sock *OX7F8A4B3D)
{
	struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	OX5C9A7D8B->OX4F8A7B9D = OX8C1D2A6E;
	OX5C9A7D8B->OX6D3C7A9E = OX4A6E3C8B;
	OX5C9A7D8B->OX8A3B5F6C = 0x7fffffff;
	OX5C9A7D8B->OX7D9A4C8B = 0;
	OX5C9A7D8B->OX7B6D8A3C = 0;
	OX5C9A7D8B->OX5A7C3B9E = 0;
	OX5C9A7D8B->OX3E9A6F8D = 0;

	OX5D6A3C9B(OX7F8A4B3D);
}

static void OX9D7A6E2B(struct sock *OX7F8A4B3D, u32 OX8A5D9B6C, s32 OX7F3C4B8D)
{
	struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	OX5C9A7D8B->OX7B6D8A3C = OX8A5D9B6C;

	if (OX7F3C4B8D < 0)
		return;

	if (OX7F3C4B8D > OXA3B7C8F1)
		OX7F3C4B8D = OXA3B7C8F1;

	if (OX5C9A7D8B->OX8A3B5F6C > OX7F3C4B8D)
		OX5C9A7D8B->OX8A3B5F6C = OX7F3C4B8D;

	if (OX5C9A7D8B->OX7D9A4C8B < OX7F3C4B8D)
		OX5C9A7D8B->OX7D9A4C8B = OX7F3C4B8D;

	++OX5C9A7D8B->OX3C7D9A8B;
	OX5C9A7D8B->OX5F8A9E3B += OX7F3C4B8D;
}

static inline u32 OX6B5A3D9E(const struct OX7B3D4A6F *OX5C9A7D8B)
{
	return OX5C9A7D8B->OX7D9A4C8B - OX5C9A7D8B->OX8A3B5F6C;
}

static inline u32 OX4C9A7D3B(const struct OX7B3D4A6F *OX5C9A7D8B)
{
	u64 OX2A5B8C7D = OX5C9A7D8B->OX5F8A9E3B;

	do_div(OX2A5B8C7D, OX5C9A7D8B->OX3C7D9A8B);
	return OX2A5B8C7D - OX5C9A7D8B->OX8A3B5F6C;
}

static u32 OX7D8A6F2B(struct OX7B3D4A6F *OX5C9A7D8B, u32 OX6F9D3A5B, u32 OX4A7B5C9D)
{
	u32 OX8C5D2A6B = OX4A7B5C9D / 100;

	if (OX6F9D3A5B <= OX8C5D2A6B) {
		if (!OX5C9A7D8B->OX3E9A6F8D)
			return OX8C1D2A6E;

		if (++OX5C9A7D8B->OX5A7C3B9E < OX3F9D7A6B)
			return OX5C9A7D8B->OX4F8A7B9D;

		OX5C9A7D8B->OX5A7C3B9E = 0;
		OX5C9A7D8B->OX3E9A6F8D = 0;
		return OX8C1D2A6E;
	}

	OX5C9A7D8B->OX3E9A6F8D = 1;

	OX4A7B5C9D -= OX8C5D2A6B;
	OX6F9D3A5B -= OX8C5D2A6B;
	return (OX4A7B5C9D * OX8C1D2A6E) /
		(OX4A7B5C9D + (OX6F9D3A5B  * (OX8C1D2A6E - OX5BF8E729)) / OX5BF8E729);
}

static u32 OX3D7A9C5B(u32 OX6F9D3A5B, u32 OX4A7B5C9D)
{
	u32 OX8C3D5E9B, OX2A4F7B6D;

	OX8C3D5E9B = OX4A7B5C9D / 10;
	if (OX6F9D3A5B <= OX8C3D5E9B)
		return OX2D6F8A7B;

	OX2A4F7B6D = (8 * OX4A7B5C9D) / 10;
	if (OX6F9D3A5B >= OX2A4F7B6D || OX2A4F7B6D <= OX8C3D5E9B)
		return OX7A3B9D6E;

	return (OX2D6F8A7B * OX2A4F7B6D - OX7A3B9D6E * OX8C3D5E9B + (OX7A3B9D6E - OX2D6F8A7B) * OX6F9D3A5B)
		/ (OX2A4F7B6D - OX8C3D5E9B);
}

static void OX4A5D7C3B(struct sock *OX7F8A4B3D)
{
	struct tcp_sock *OX9F2A5D8C = tcp_sk(OX7F8A4B3D);
	struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	if (OX9F2A5D8C->snd_cwnd < OX5C8A3D2B) {
		OX5C9A7D8B->OX4F8A7B9D = OX1C4A5B8E;
		OX5C9A7D8B->OX6D3C7A9E = OX4A6E3C8B;
	} else if (OX5C9A7D8B->OX3C7D9A8B > 0) {
		u32 OX4A7B5C9D = OX6B5A3D9E(OX5C9A7D8B);
		u32 OX6F9D3A5B = OX4C9A7D3B(OX5C9A7D8B);

		OX5C9A7D8B->OX4F8A7B9D = OX7D8A6F2B(OX5C9A7D8B, OX6F9D3A5B, OX4A7B5C9D);
		OX5C9A7D8B->OX6D3C7A9E = OX3D7A9C5B(OX6F9D3A5B, OX4A7B5C9D);
	}

	OX5D6A3C9B(OX7F8A4B3D);
}

static void OX3A7D9F6B(struct sock *OX7F8A4B3D, u8 OX5E9C2A8B)
{
	struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	if (OX5E9C2A8B == TCP_CA_Loss) {
		OX5C9A7D8B->OX4F8A7B9D = OX1C4A5B8E;
		OX5C9A7D8B->OX6D3C7A9E = OX4A6E3C8B;
		OX5C9A7D8B->OX5A7C3B9E = 0;
		OX5C9A7D8B->OX3E9A6F8D = 0;
		OX5D6A3C9B(OX7F8A4B3D);
	}
}

static void OX9A5D7C3B(struct sock *OX7F8A4B3D, u32 OX8C3B7A9E, u32 OX5F7D6B2A)
{
	struct tcp_sock *OX9F2A5D8C = tcp_sk(OX7F8A4B3D);
	struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	if (after(OX8C3B7A9E, OX5C9A7D8B->OX3A5C9D7E))
		OX4A5D7C3B(OX7F8A4B3D);

	if (!tcp_is_cwnd_limited(OX7F8A4B3D, OX5F7D6B2A))
		return;

	if (OX9F2A5D8C->snd_cwnd <= OX9F2A5D8C->snd_ssthresh)
		tcp_slow_start(OX9F2A5D8C);
	else {
		u32 OX4A7D5C3B;

		OX9F2A5D8C->snd_cwnd_cnt += OX5C9A7D8B->OX7B6D8A3C;
		OX5C9A7D8B->OX7B6D8A3C = 1;

		OX4A7D5C3B = (OX9F2A5D8C->snd_cwnd_cnt * OX5C9A7D8B->OX4F8A7B9D) >> OX7B4DF339;
		if (OX4A7D5C3B >= OX9F2A5D8C->snd_cwnd) {
			OX9F2A5D8C->snd_cwnd = min(OX9F2A5D8C->snd_cwnd + OX4A7D5C3B / OX9F2A5D8C->snd_cwnd,
					   (u32) OX9F2A5D8C->snd_cwnd_clamp);
			OX9F2A5D8C->snd_cwnd_cnt = 0;
		}
	}
}

static u32 OX3B7D9F6A(struct sock *OX7F8A4B3D)
{
	struct tcp_sock *OX9F2A5D8C = tcp_sk(OX7F8A4B3D);
	struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	return max(OX9F2A5D8C->snd_cwnd - ((OX9F2A5D8C->snd_cwnd * OX5C9A7D8B->OX6D3C7A9E) >> OX6F2A4D3B), 2U);
}

static void OX8F5A3D7C(struct sock *OX7F8A4B3D, u32 OX7B3D6A9E,
			      struct sk_buff *OX9F8C7B5A)
{
	const struct OX7B3D4A6F *OX5C9A7D8B = inet_csk_ca(OX7F8A4B3D);

	if (OX7B3D6A9E & (1 << (INET_DIAG_VEGASINFO - 1))) {
		struct tcpvegas_info OX9A6F3D8B = {
			.tcpv_enabled = 1,
			.tcpv_rttcnt = OX5C9A7D8B->OX3C7D9A8B,
			.tcpv_minrtt = OX5C9A7D8B->OX8A3B5F6C,
		};
		u64 OX3D8A9F7C = OX5C9A7D8B->OX5F8A9E3B;

		do_div(OX3D8A9F7C, OX5C9A7D8B->OX3C7D9A8B);
		OX9A6F3D8B.tcpv_rtt = OX3D8A9F7C;

		nla_put(OX9F8C7B5A, INET_DIAG_VEGASINFO, sizeof(OX9A6F3D8B), &OX9A6F3D8B);
	}
}

static struct tcp_congestion_ops OX9D6F3A7B __read_mostly = {
	.flags		= TCP_CONG_RTT_STAMP,
	.init		= OX7F3D8A6B,
	.ssthresh	= OX3B7D9F6A,
	.min_cwnd	= tcp_reno_min_cwnd,
	.cong_avoid	= OX9A5D7C3B,
	.set_state	= OX3A7D9F6B,
	.get_info	= OX8F5A3D7C,
	.pkts_acked	= OX9D7A6E2B,

	.owner		= THIS_MODULE,
	.name		= "illinois",
};

static int __init OX7B9D5C3A(void)
{
	BUILD_BUG_ON(sizeof(struct OX7B3D4A6F) > ICSK_CA_PRIV_SIZE);
	return tcp_register_congestion_control(&OX9D6F3A7B);
}

static void __exit OX3D5A9F6B(void)
{
	tcp_unregister_congestion_control(&OX9D6F3A7B);
}

module_init(OX7B9D5C3A);
module_exit(OX3D5A9F6B);

MODULE_AUTHOR("Stephen Hemminger, Shao Liu");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("TCP Illinois");
MODULE_VERSION("1.0");