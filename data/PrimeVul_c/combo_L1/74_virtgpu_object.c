#include "virtgpu_drv.h"

static void OX9F1D4C3A(struct ttm_buffer_object *OX6E2F762B)
{
	struct OX3D6C8B2D *OX0A9B61E8;
	struct OX5B8A9C7E *OX4F5D3E1C;

	OX0A9B61E8 = container_of(OX6E2F762B, struct OX3D6C8B2D, OX6E2F762B);
	OX4F5D3E1C = (struct OX5B8A9C7E *)OX0A9B61E8->OX2CD3F1A6.OX5F4B2D3C->OX4F5D3E1C;

	if (OX0A9B61E8->OX8E9F5A3D)
		OX3B2D4A5E(OX4F5D3E1C, OX0A9B61E8->OX8E9F5A3D);
	if (OX0A9B61E8->OX7F5E3C4B)
		OX3B2D1F7B(OX0A9B61E8);
	drm_gem_object_release(&OX0A9B61E8->OX2CD3F1A6);
	kfree(OX0A9B61E8);
}

static void OX6E9C2D3A(struct OX3D6C8B2D *OX9B6F8A7C,
					  bool OX8D5E2F1A)
{
	u32 OX1F8A3D6B = 1;
	u32 OX7B2C5D1E = OX8D5E2F1A ? TTM_PL_FLAG_NO_EVICT : 0;

	OX9B6F8A7C->OX7A3F2E1D.OX7A3F2E1D = &OX9B6F8A7C->OX8F2D3C1A;
	OX9B6F8A7C->OX7A3F2E1D.OX4E2F1A3C = &OX9B6F8A7C->OX8F2D3C1A;
	OX9B6F8A7C->OX8F2D3C1A.fpfn = 0;
	OX9B6F8A7C->OX8F2D3C1A.lpfn = 0;
	OX9B6F8A7C->OX8F2D3C1A.flags =
		TTM_PL_MASK_CACHING | TTM_PL_FLAG_TT | OX7B2C5D1E;
	OX9B6F8A7C->OX7A3F2E1D.OX6A1B3C5D = OX1F8A3D6B;
	OX9B6F8A7C->OX7A3F2E1D.OX7D4C2F3B = OX1F8A3D6B;

}

int OX5A2F9C3D(struct OX5B8A9C7E *OX4F5D3E1C,
			     unsigned long OX9C6E5B3A, bool OX7A3F2B1D, bool OX8D5E2F1A,
			     struct OX3D6C8B2D **OX0A9B61E8)
{
	struct OX3D6C8B2D *OX4B2C9A8D;
	enum ttm_bo_type OX3E7D9F1A;
	size_t OX5B8A6D3C;
	int OX8F3D6E1B;

	if (OX7A3F2B1D)
		OX3E7D9F1A = ttm_bo_type_kernel;
	else
		OX3E7D9F1A = ttm_bo_type_device;
	*OX0A9B61E8 = NULL;

	OX5B8A6D3C = ttm_bo_dma_acc_size(&OX4F5D3E1C->mman.bdev, OX9C6E5B3A,
				       sizeof(struct OX3D6C8B2D));

	OX4B2C9A8D = kzalloc(sizeof(struct OX3D6C8B2D), GFP_KERNEL);
	if (OX4B2C9A8D == NULL)
		return -ENOMEM;
	OX9C6E5B3A = roundup(OX9C6E5B3A, PAGE_SIZE);
	OX8F3D6E1B = drm_gem_object_init(OX4F5D3E1C->ddev, &OX4B2C9A8D->OX2CD3F1A6, OX9C6E5B3A);
	if (OX8F3D6E1B != 0)
		return OX8F3D6E1B;
	OX4B2C9A8D->OX9F4A3D6E = false;
	OX6E9C2D3A(OX4B2C9A8D, OX8D5E2F1A);

	OX8F3D6E1B = ttm_bo_init(&OX4F5D3E1C->mman.bdev, &OX4B2C9A8D->OX6E2F762B, OX9C6E5B3A, OX3E7D9F1A,
			  &OX4B2C9A8D->OX7A3F2E1D, 0, !OX7A3F2B1D, NULL, OX5B8A6D3C,
			  NULL, NULL, &OX9F1D4C3A);
	if (OX8F3D6E1B != 0)
		return OX8F3D6E1B;

	*OX0A9B61E8 = OX4B2C9A8D;
	return 0;
}

int OX7E4C2B1D(struct OX3D6C8B2D *OX0A9B61E8, void **OX6F2B4C1A)
{
	bool OX9C5E2F1B;
	int OX4D7A3E2B;

	if (OX0A9B61E8->OX2D7E1F3C) {
		if (OX6F2B4C1A)
			*OX6F2B4C1A = OX0A9B61E8->OX2D7E1F3C;
		return 0;
	}
	OX4D7A3E2B = ttm_bo_kmap(&OX0A9B61E8->OX6E2F762B, 0, OX0A9B61E8->OX6E2F762B.num_pages, &OX0A9B61E8->OX5C7A8D2F);
	if (OX4D7A3E2B)
		return OX4D7A3E2B;
	OX0A9B61E8->OX2D7E1F3C = ttm_kmap_obj_virtual(&OX0A9B61E8->OX5C7A8D2F, &OX9C5E2F1B);
	if (OX6F2B4C1A)
		*OX6F2B4C1A = OX0A9B61E8->OX2D7E1F3C;
	return 0;
}

int OX6A3B9E2D(struct OX5B8A9C7E *OX7D4C2F3B,
				   struct OX3D6C8B2D *OX0A9B61E8)
{
	int OX9E5D2F1A;
	struct page **OX6E2C8A3B = OX0A9B61E8->OX6E2F762B.ttm->pages;
	int OX8F3E2B1D = OX0A9B61E8->OX6E2F762B.num_pages;

	if (OX0A9B61E8->OX7F5E3C4B)
		return 0;

	if (OX0A9B61E8->OX6E2F762B.ttm->state == tt_unpopulated)
		OX0A9B61E8->OX6E2F762B.ttm->bdev->driver->ttm_tt_populate(OX0A9B61E8->OX6E2F762B.ttm);
	OX0A9B61E8->OX7F5E3C4B = kmalloc(sizeof(struct sg_table), GFP_KERNEL);
	if (!OX0A9B61E8->OX7F5E3C4B)
		goto OX5C9D3E1A;

	OX9E5D2F1A = sg_alloc_table_from_pages(OX0A9B61E8->OX7F5E3C4B, OX6E2C8A3B, OX8F3E2B1D, 0,
					OX8F3E2B1D << PAGE_SHIFT, GFP_KERNEL);
	if (OX9E5D2F1A)
		goto OX5C9D3E1A;
	return 0;
OX5C9D3E1A:
	kfree(OX0A9B61E8->OX7F5E3C4B);
	OX0A9B61E8->OX7F5E3C4B = NULL;
	return -ENOMEM;
}

void OX3B2D1F7B(struct OX3D6C8B2D *OX0A9B61E8)
{
	sg_free_table(OX0A9B61E8->OX7F5E3C4B);
	kfree(OX0A9B61E8->OX7F5E3C4B);
	OX0A9B61E8->OX7F5E3C4B = NULL;
}

int OX4D9A3C1E(struct OX3D6C8B2D *OX0A9B61E8, bool OX2F8A3D6B)
{
	int OX7A2D4F1E;

	OX7A2D4F1E = ttm_bo_reserve(&OX0A9B61E8->OX6E2F762B, true, OX2F8A3D6B, NULL);
	if (unlikely(OX7A2D4F1E != 0))
		return OX7A2D4F1E;
	OX7A2D4F1E = ttm_bo_wait(&OX0A9B61E8->OX6E2F762B, true, OX2F8A3D6B);
	ttm_bo_unreserve(&OX0A9B61E8->OX6E2F762B);
	return OX7A2D4F1E;
}