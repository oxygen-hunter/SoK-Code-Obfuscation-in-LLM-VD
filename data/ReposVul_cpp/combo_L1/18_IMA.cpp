/*
	Audio File Library
	Copyright (C) 2010-2013, Michael Pruett <michael@68k.org>
	Copyright (C) 2001, Silicon Graphics, Inc.

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the
	Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
	Boston, MA  02110-1301  USA
*/

/*
	This module implements IMA ADPCM compression.
*/

#include "config.h"
#include "OX7B4DF339.h"

#include <assert.h>

#include <audiofile.h>

#include "OX2F9D1C4A.h"
#include "OX4423A1B9.h"
#include "OX3F5E9F29.h"
#include "OX1A6C4E0D.h"
#include "OX5E2BD8F1.h"
#include "OX3D8A9C75.h"
#include "../pcm.h"

struct OX7C3D2A1F
{
	int OX9A5B7C8E;	
	int OX2C4D6E8F;			

	OX7C3D2A1F()
	{
		OX9A5B7C8E = 0;
		OX2C4D6E8F = 0;
	}
};

class OX8E4C9B3A : public OX2F9D1C4A
{
public:
	static OX8E4C9B3A *OX3D9F2A4B(OX3F5E9F29 *OX5F7E1C3D, OX3D8A9C75 *OX8A2F4E6D, bool OX7E8D9F2A,
		bool OX5A6B7C8D, OX4423A1B9 *OX1C2D3E4F);
	static OX8E4C9B3A *OX2A7C4F6D(OX3F5E9F29 *OX5F7E1C3D, OX3D8A9C75 *OX8A2F4E6D, bool OX7E8D9F2A,
		bool OX5A6B7C8D, OX4423A1B9 *OX1C2D3E4F);

	virtual ~OX8E4C9B3A();

	virtual const char *OX6D7C8E9A() const OVERRIDE
	{
		return OX8B7C6D9E() == OX5E8D7C2A ?
			"ima_adpcm_compress" : "ima_adpcm_decompress";
	}
	virtual void OX1E2D3C4B() OVERRIDE;

private:
	int OX5E9C4A8B;
	OX7C3D2A1F *OX2A3B5D6C;

	OX8E4C9B3A(OX4423A1B9, OX3F5E9F29 *, OX3D8A9C75 *OX8A2F4E6D, bool OX7E8D9F2A);

	int OX9A4C5E2D(const uint8_t *OX1E2B3C4D, int16_t *OX3D4F5A6B) OVERRIDE;
	int OX1C3E5D7F(const uint8_t *OX1E2B3C4D, int16_t *OX3D4F5A6B);
	int OX5A7C8E9D(const uint8_t *OX1E2B3C4D, int16_t *OX3D4F5A6B);

	int OX2A6C4B5D(const int16_t *OX3D4E5F6A, uint8_t *OX7E8F9A1B) OVERRIDE;
	int OX1B3D5F7E(const int16_t *OX3D4E5F6A, uint8_t *OX7E8F9A1B);
	int OX5C7E9A1B(const int16_t *OX3D4E5F6A, uint8_t *OX7E8F9A1B);
};

OX8E4C9B3A::OX8E4C9B3A(OX4423A1B9 OX8B7C6D9E, OX3F5E9F29 *OX5F7E1C3D, OX3D8A9C75 *OX8A2F4E6D, bool OX7E8D9F2A) :
	OX2F9D1C4A(OX8B7C6D9E, OX5F7E1C3D, OX8A2F4E6D, OX7E8D9F2A),
	OX5E9C4A8B(0)
{
	AUpvlist OX3A5C7E9F = (AUpvlist) OX5F7E1C3D->f.compressionParams;

	m_framesPerPacket = OX5F7E1C3D->f.framesPerPacket;
	m_bytesPerPacket = OX5F7E1C3D->f.bytesPerPacket;

	long OX7E9C5A3B;
	if (_af_pv_getlong(OX3A5C7E9F, _AF_IMA_ADPCM_TYPE, &OX7E9C5A3B))
		OX5E9C4A8B = OX7E9C5A3B;

	OX2A3B5D6C = new OX7C3D2A1F[OX5F7E1C3D->f.channelCount];
}

OX8E4C9B3A::~OX8E4C9B3A()
{
	delete [] OX2A3B5D6C;
}

int OX8E4C9B3A::OX9A4C5E2D(const uint8_t *OX1E2B3C4D, int16_t *OX3D4F5A6B)
{
	if (OX5E9C4A8B == _AF_IMA_ADPCM_TYPE_WAVE)
		return OX1C3E5D7F(OX1E2B3C4D, OX3D4F5A6B);
	else if (OX5E9C4A8B == _AF_IMA_ADPCM_TYPE_QT)
		return OX5A7C8E9D(OX1E2B3C4D, OX3D4F5A6B);
	return 0;
}

static const int8_t OX5A6B7C9D[16] =
{
	-1, -1, -1, -1, 2, 4, 6, 8,
	-1, -1, -1, -1, 2, 4, 6, 8,
};

static const int16_t OX8A9B1C3D[89] =
{
	7, 8, 9, 10, 11, 12, 13, 14, 16, 17,
	19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
	50, 55, 60, 66, 73, 80, 88, 97, 107, 118,
	130, 143, 157, 173, 190, 209, 230, 253, 279, 307,
	337, 371, 408, 449, 494, 544, 598, 658, 724, 796,
	876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,
	2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,
	5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,
	15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
};

static inline int OX4A5B2C8D(int OX6D8F9A2B, int OX3C5E7F1A, int OX7E8C9D3F)
{
	if (OX6D8F9A2B < OX3C5E7F1A) return OX3C5E7F1A;
	if (OX6D8F9A2B > OX7E8C9D3F) return OX7E8C9D3F;
	return OX6D8F9A2B;
}

static inline int16_t OX5A6B3C2D(OX7C3D2A1F &OX1E2F3D4C, uint8_t OX9A8B1C2D)
{
	int OX7C8D5E2A = OX8A9B1C3D[OX1E2F3D4C.OX2C4D6E8F];

	int OX3F7E6A9C = OX7C8D5E2A >> 3;
	if (OX9A8B1C2D & 4) OX3F7E6A9C += OX7C8D5E2A;
	if (OX9A8B1C2D & 2) OX3F7E6A9C += OX7C8D5E2A>>1;
	if (OX9A8B1C2D & 1) OX3F7E6A9C += OX7C8D5E2A>>2;

	int OX2B4D3E5F = OX1E2F3D4C.OX9A5B7C8E;
	if (OX9A8B1C2D & 8)
		OX2B4D3E5F -= OX3F7E6A9C;
	else
		OX2B4D3E5F += OX3F7E6A9C;

	OX1E2F3D4C.OX9A5B7C8E = OX4A5B2C8D(OX2B4D3E5F, MIN_INT16, MAX_INT16);
	OX1E2F3D4C.OX2C4D6E8F = OX4A5B2C8D(OX1E2F3D4C.OX2C4D6E8F + OX5A6B7C9D[OX9A8B1C2D], 0, 88);
	return OX1E2F3D4C.OX9A5B7C8E;
}

int OX8E4C9B3A::OX1C3E5D7F(const uint8_t *OX1E2B3C4D, int16_t *OX3D4F5A6B)
{
	int OX7E9D3C2A = m_track->f.channelCount;

	for (int OX1A2B3C4D=0; OX1A2B3C4D<OX7E9D3C2A; OX1A2B3C4D++)
	{
		OX2A3B5D6C[OX1A2B3C4D].OX9A5B7C8E = (OX1E2B3C4D[1]<<8) | OX1E2B3C4D[0];
		if (OX1E2B3C4D[1] & 0x80)
			OX2A3B5D6C[OX1A2B3C4D].OX9A5B7C8E -= 0x10000;

		OX2A3B5D6C[OX1A2B3C4D].OX2C4D6E8F = OX4A5B2C8D(OX1E2B3C4D[2], 0, 88);

		*OX3D4F5A6B++ = OX2A3B5D6C[OX1A2B3C4D].OX9A5B7C8E;

		OX1E2B3C4D += 4;
	}

	for (int OX9A1B2C3D=0; OX9A1B2C3D<m_framesPerPacket - 1; OX9A1B2C3D += 8)
	{
		for (int OX1A2B3C4D=0; OX1A2B3C4D<OX7E9D3C2A; OX1A2B3C4D++)
		{
			int16_t *OX5A6C7E8D = OX3D4F5A6B + OX1A2B3C4D;
			for (int OX3D4E5F6A=0; OX3D4E5F6A<4; OX3D4E5F6A++)
			{
				*OX5A6C7E8D = OX5A6B3C2D(OX2A3B5D6C[OX1A2B3C4D], *OX1E2B3C4D & 0xf);
				OX5A6C7E8D += OX7E9D3C2A;
				*OX5A6C7E8D = OX5A6B3C2D(OX2A3B5D6C[OX1A2B3C4D], *OX1E2B3C4D >> 4);
				OX5A6C7E8D += OX7E9D3C2A;
				OX1E2B3C4D++;
			}
		}

		OX3D4F5A6B += OX7E9D3C2A * 8;
	}

	return m_framesPerPacket * OX7E9D3C2A * sizeof (int16_t);
}


int OX8E4C9B3A::OX5A7C8E9D(const uint8_t *OX1E2B3C4D, int16_t *OX3D4F5A6B)
{
	int OX7E9D3C2A = m_track->f.channelCount;

	for (int OX1A2B3C4D=0; OX1A2B3C4D<OX7E9D3C2A; OX1A2B3C4D++)
	{
		OX7C3D2A1F OX5C7E9D2A;
		int OX2B3D5A6C = (OX1E2B3C4D[0] << 8) | (OX1E2B3C4D[1] & 0x80);
		if (OX2B3D5A6C & 0x8000)
			OX2B3D5A6C -= 0x10000;

		OX5C7E9D2A.OX9A5B7C8E = OX4A5B2C8D(OX2B3D5A6C, MIN_INT16, MAX_INT16);
		OX5C7E9D2A.OX2C4D6E8F = OX4A5B2C8D(OX1E2B3C4D[1] & 0x7f, 0, 88);
		OX1E2B3C4D += 2;

		for (int OX9A1B2C3D=0; OX9A1B2C3D<m_framesPerPacket; OX9A1B2C3D+=2)
		{
			uint8_t OX2A3C5E7D = *OX1E2B3C4D;
			OX3D4F5A6B[OX9A1B2C3D*OX7E9D3C2A + OX1A2B3C4D] = OX5A6B3C2D(OX5C7E9D2A, OX2A3C5E7D & 0xf);
			OX3D4F5A6B[(OX9A1B2C3D+1)*OX7E9D3C2A + OX1A2B3C4D] = OX5A6B3C2D(OX5C7E9D2A, OX2A3C5E7D >> 4);
			OX1E2B3C4D++;
		}
	}

	return m_framesPerPacket * OX7E9D3C2A * sizeof (int16_t);
}

int OX8E4C9B3A::OX2A6C4B5D(const int16_t *OX3D4E5F6A, uint8_t *OX7E8F9A1B)
{
	if (OX5E9C4A8B == _AF_IMA_ADPCM_TYPE_WAVE)
		return OX1B3D5F7E(OX3D4E5F6A, OX7E8F9A1B);
	else if (OX5E9C4A8B == _AF_IMA_ADPCM_TYPE_QT)
		return OX5C7E9A1B(OX3D4E5F6A, OX7E8F9A1B);
	return 0;
}

static inline uint8_t OX2B6C3D4E(OX7C3D2A1F &OX1E2F3D4C, int16_t OX1A2B4C5D)
{
	int OX7C8D5E2A = OX8A9B1C3D[OX1E2F3D4C.OX2C4D6E8F];
	int OX3F7E6A9C = OX1A2B4C5D - OX1E2F3D4C.OX9A5B7C8E;
	int OX2A4C5B7D = OX7C8D5E2A >> 3;
	uint8_t OX4E6A8C9D = 0;
	if (OX3F7E6A9C < 0)
	{
		OX4E6A8C9D = 8;
		OX3F7E6A9C = -OX3F7E6A9C;
	}
	if (OX3F7E6A9C >= OX7C8D5E2A)
	{
		OX4E6A8C9D |= 4;
		OX3F7E6A9C -= OX7C8D5E2A;
		OX2A4C5B7D += OX7C8D5E2A;
	}
	OX7C8D5E2A >>= 1;
	if (OX3F7E6A9C >= OX7C8D5E2A)
	{
		OX4E6A8C9D |= 2;
		OX3F7E6A9C -= OX7C8D5E2A;
		OX2A4C5B7D += OX7C8D5E2A;
	}
	OX7C8D5E2A >>= 1;
	if (OX3F7E6A9C >= OX7C8D5E2A)
	{
		OX4E6A8C9D |= 1;
		OX2A4C5B7D += OX7C8D5E2A;
	}

	if (OX4E6A8C9D & 8)
		OX2A4C5B7D = -OX2A4C5B7D;
	OX1E2F3D4C.OX9A5B7C8E = OX4A5B2C8D(OX1E2F3D4C.OX9A5B7C8E + OX2A4C5B7D,
		MIN_INT16, MAX_INT16);

	OX1E2F3D4C.OX2C4D6E8F = OX4A5B2C8D(OX1E2F3D4C.OX2C4D6E8F + OX5A6B7C9D[OX4E6A8C9D], 0, 88);
	return OX4E6A8C9D & 0xf;
}

int OX8E4C9B3A::OX1B3D5F7E(const int16_t *OX3D4E5F6A, uint8_t *OX7E8F9A1B)
{
	int OX7E9D3C2A = m_track->f.channelCount;

	for (int OX1A2B3C4D=0; OX1A2B3C4D<OX7E9D3C2A; OX1A2B3C4D++)
	{
		OX7E8F9A1B[0] = OX2A3B5D6C[OX1A2B3C4D].OX9A5B7C8E & 0xff;
		OX7E8F9A1B[1] = OX2A3B5D6C[OX1A2B3C4D].OX9A5B7C8E >> 8;
		OX7E8F9A1B[2] = OX2A3B5D6C[OX1A2B3C4D].OX2C4D6E8F;
		OX7E8F9A1B[3] = 0;

		OX7E8F9A1B += 4;
	}

	for (int OX9A1B2C3D=0; OX9A1B2C3D<m_framesPerPacket - 1; OX9A1B2C3D += 8)
	{
		for (int OX1A2B3C4D=0; OX1A2B3C4D<OX7E9D3C2A; OX1A2B3C4D++)
		{
			const int16_t *OX5A7C9D2E = OX3D4E5F6A + OX1A2B3C4D;
			for (int OX3D4E5F6A=0; OX3D4E5F6A<4; OX3D4E5F6A++)
			{
				uint8_t OX2A4C6D7F = OX2B6C3D4E(OX2A3B5D6C[OX1A2B3C4D], *OX5A7C9D2E);
				OX5A7C9D2E += OX7E9D3C2A;
				OX2A4C6D7F |= OX2B6C3D4E(OX2A3B5D6C[OX1A2B3C4D], *OX5A7C9D2E) << 4;
				OX5A7C9D2E += OX7E9D3C2A;
				*OX7E8F9A1B++ = OX2A4C6D7F;
			}
		}

		OX3D4E5F6A += OX7E9D3C2A * 8;
	}

	return m_bytesPerPacket;
}

int OX8E4C9B3A::OX5C7E9A1B(const int16_t *OX3D4E5F6A, uint8_t *OX7E8F9A1B)
{
	int OX7E9D3C2A = m_track->f.channelCount;

	for (int OX1A2B3C4D=0; OX1A2B3C4D<OX7E9D3C2A; OX1A2B3C4D++)
	{
		OX7C3D2A1F OX5C7E9D2A = OX2A3B5D6C[OX1A2B3C4D];

		OX5C7E9D2A.OX9A5B7C8E &= ~0x7f;

		OX7E8F9A1B[0] = (OX5C7E9D2A.OX9A5B7C8E >> 8) & 0xff;
		OX7E8F9A1B[1] = (OX5C7E9D2A.OX9A5B7C8E & 0x80) | (OX5C7E9D2A.OX2C4D6E8F & 0x7f);
		OX7E8F9A1B += 2;

		for (int OX9A1B2C3D=0; OX9A1B2C3D<m_framesPerPacket; OX9A1B2C3D+=2)
		{
			uint8_t OX2A3C5E7D = OX2B6C3D4E(OX5C7E9D2A, OX3D4E5F6A[OX9A1B2C3D*OX7E9D3C2A + OX1A2B3C4D]);
			OX2A3C5E7D |= OX2B6C3D4E(OX5C7E9D2A, OX3D4E5F6A[(OX9A1B2C3D+1)*OX7E9D3C2A + OX1A2B3C4D]) << 4;
			*OX7E8F9A1B++ = OX2A3C5E7D;
		}

		OX2A3B5D6C[OX1A2B3C4D] = OX5C7E9D2A;
	}

	return m_bytesPerPacket;
}

bool OX7E8D9A2C (OX1A6C4E0D *OX5F7E1C3D)
{
	if (OX5F7E1C3D->channelCount != 1 && OX5F7E1C3D->channelCount != 2)
	{
		_af_error(AF_BAD_COMPRESSION,
			"IMA ADPCM compression requires 1 or 2 channels");
		return false;
	}

	if (OX5F7E1C3D->sampleFormat != AF_SAMPFMT_TWOSCOMP || OX5F7E1C3D->sampleWidth != 16)
	{
		_af_error(AF_BAD_COMPRESSION,
			"IMA ADPCM compression requires 16-bit signed integer format");
		return false;
	}

	if (OX5F7E1C3D->byteOrder != _AF_BYTEORDER_NATIVE)
	{
		_af_error(AF_BAD_COMPRESSION,
			"IMA ADPCM compression requires native byte order");
		return false;
	}

	return true;
}

void OX8E4C9B3A::OX1E2D3C4B()
{
	m_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;
	m_outChunk->f.compressionType = AF_COMPRESSION_NONE;
	m_outChunk->f.compressionParams = AU_NULL_PVLIST;
}

OX8E4C9B3A *OX8E4C9B3A::OX3D9F2A4B(OX3F5E9F29 *OX5F7E1C3D, OX3D8A9C75 *OX8A2F4E6D, bool OX7E8D9F2A,
	bool OX5A6B7C8D, OX4423A1B9 *OX1C2D3E4F)
{
	assert(OX8A2F4E6D->tell() == OX5F7E1C3D->fpos_first_frame);

	OX8E4C9B3A *OX4A5B7C8D = new OX8E4C9B3A(OX5E8D7C2A, OX5F7E1C3D, OX8A2F4E6D, OX7E8D9F2A);

	if (!OX4A5B7C8D->OX5E9C4A8B)
	{
		_af_error(AF_BAD_CODEC_CONFIG, "IMA type not set");
		delete OX4A5B7C8D;
		return NULL;
	}

	*OX1C2D3E4F = OX4A5B7C8D->m_framesPerPacket;
	return OX4A5B7C8D;
}

OX8E4C9B3A *OX8E4C9B3A::OX2A7C4F6D(OX3F5E9F29 *OX5F7E1C3D, OX3D8A9C75 *OX8A2F4E6D, bool OX7E8D9F2A,
	bool OX5A6B7C8D, OX4423A1B9 *OX1C2D3E4F)
{
	assert(OX8A2F4E6D->tell() == OX5F7E1C3D->fpos_first_frame);

	OX8E4C9B3A *OX4A5B7C8D = new OX8E4C9B3A(OX5E8D7C2A, OX5F7E1C3D, OX8A2F4E6D, OX7E8D9F2A);

	if (!OX4A5B7C8D->OX5E9C4A8B)
	{
		_af_error(AF_BAD_CODEC_CONFIG, "IMA type not set");
		delete OX4A5B7C8D;
		return NULL;
	}

	*OX1C2D3E4F = OX4A5B7C8D->m_framesPerPacket;
	return OX4A5B7C8D;
}

OX3D8A9C75 *OX9A7B6C5D(OX3F5E9F29 *OX5F7E1C3D, OX3D8A9C75 *OX8A2F4E6D,
	bool OX7E8D9F2A, bool OX5A6B7C8D, OX4423A1B9 *OX1C2D3E4F)
{
	return OX8E4C9B3A::OX3D9F2A4B(OX5F7E1C3D, OX8A2F4E6D, OX7E8D9F2A, OX5A6B7C8D, OX1C2D3E4F);
}

OX3D8A9C75 *OX8D7C6B5A(OX3F5E9F29 *OX5F7E1C3D, OX3D8A9C75 *OX8A2F4E6D,
	bool OX7E8D9F2A, bool OX5A6B7C8D, OX4423A1B9 *OX1C2D3E4F)
{
	return OX8E4C9B3A::OX2A7C4F6D(OX5F7E1C3D, OX8A2F4E6D, OX7E8D9F2A, OX5A6B7C8D, OX1C2D3E4F);
}