file_name,audit_report,input_token_num,output_token_num,inference_time
35_print-vqp.c,"1. YES  
2. - Out-of-bounds read; lines with `vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);` and `vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);` inside the `case 3` branch of `vqp_print`. The loop only verifies that `tlen > 0` before accessing the TLV header, so a packet whose remaining length is smaller than `sizeof(struct vqp_obj_tlv_t)` triggers reads past the captured buffer, leading to memory disclosure or a crash before `ND_TCHECK2` can run.
",1,1,39.85298252105713
63_common.c,"1. YES
2. - Type: Path traversal (`uftpd.c:73-77`) – the post-resolution check uses `strncmp(dir, home, strlen(home))` on the non-canonical `dir` buffer, so crafted inputs with `..` keep the `home` prefix while `realpath` resolves outside the FTP root, allowing traversal beyond the intended directory.  
   - Type: Improper privilege drop (`uftpd.c:268-282`) – failures from `setegid`/`seteuid` only trigger warnings; execution continues with root privileges and `privs_dropped` is set to 1, so later sessions never retry dropping, leaving the process running as root.
",1,1,212.421954870224
69_nsc.c,"
 1. YES
      - Heap-based buffer overflow via integer overflow
        (combo_C2/69_nsc.c:258,combo_C2/69_nsc.c:264,combo_C2/69_nsc.c:274,combo_C2/69_nsc.c:82-85): length =
        context->width * context->height * 4 uses 32-bit arithmetic on attacker-controlled width/height, so large
        values wrap and allocate a too-small BitmapData buffer. The decoder then writes width*height*4 bytes into this
        undersized buffer, overflowing heap memory.
      - Heap-based buffer overflow in RLE decompressor (combo_C2/69_nsc.c:137-154): The run-length len read from the
        compressed stream is never checked against the remaining output left, so an attacker can supply an arbitrary
        large value. FillMemory(out, len, value) then writes past the allocated plane buffer, corrupting heap memory.
",1,1,0.014000415802001953
71_riff.c,"
• 1. YES
      - Integer overflow / unchecked allocation (combo_C2/71_riff.c:286-297): bytes_to_copy is calculated from the chunk
        size in the file (chunk_header.ckSize) and then stored in a signed int. For attacker-supplied sizes ≥ 0x80000000
        this wraps to a negative value, so the subsequent malloc(bytes_to_copy) request is implicitly converted to
        a huge unsigned size and fails, leaving buff == NULL. The code then still calls DoReadFile(infile, buff,
        bytes_to_copy, …) and WavpackAddWrapper(wpc, buff, bytes_to_copy) with that null pointer and negative length,
        which dereferences NULL (or interprets the length as a massive unsigned value). A crafted RIFF chunk therefore
        triggers an immediate crash (denial of service).
",1,1,0.015999555587768555
127_chgdbmailusers.c,"1. YES  
2. - Buffer Overflow — `main:15`, `main:28`, `main:29`; `cmnd` is only 255 bytes, yet `strcpy`/`strcat` copy arbitrary-length input without bounds checks, so long arguments overflow the stack buffer.  
   - Command Injection / Privilege Escalation — `main:28`, `main:29`, `main:37`, `main:38`; untrusted arguments are concatenated into a shell command and executed via `system` after `setuid(UID)` elevates to root, letting attackers run arbitrary commands with root privileges.
",1,1,19.55704951286316
