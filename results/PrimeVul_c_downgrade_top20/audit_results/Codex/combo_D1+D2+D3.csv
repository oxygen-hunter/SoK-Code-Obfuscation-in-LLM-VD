file_name,audit_report,input_token_num,output_token_num,inference_time
35_print-vqp.c,"1. YES  
2. - Out-of-bounds read – `vqp_print` (`vqp_print`: lines around `vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr;` through `vqp_obj_len = EXTRACT_16BITS(...)`) – the loop dereferences the TLV header without first confirming `tlen >= sizeof(struct vqp_obj_tlv_t)`, so a crafted packet with fewer than 6 bytes left will make the `EXTRACT_32BITS/16BITS` macros read past the captured buffer.
",1,1,19.60578727722168
63_common.c,"1. YES
2. - Vulnerability: Stack-based buffer overflow (CWE-121)  
     Vulnerable lines: uftpd.c:25-26 (`memmove(dir + len, dir, strlen(dir) + 1);` followed by `memcpy(dir, home, len);`)  
     Reason: When the server runs unchrooted, it prepends `home` to `dir` by shifting the existing contents inside the fixed-size stack buffer `dir[PATH_MAX]` without first ensuring `len + strlen(dir) < PATH_MAX`. An attacker who controls `ctrl->cwd` can push the combined length past `PATH_MAX` and overwrite adjacent stack memory.
   - Vulnerability: Directory traversal / sandbox escape (CWE-22)  
     Vulnerable lines: uftpd.c:29-45 (especially the final check `strncmp(dir, home, strlen(home))`)  
     Reason: After resolving paths with `realpath`, the code verifies containment using the non-canonical `dir` string that still contains sequences like `../`. Because the prefix comparison ignores path segment boundaries and bypasses canonicalisation, inputs such as `../../etc/passwd` yield `rpath` outside `home` (e.g., `/etc/passwd`) while the `strncmp` check still passes, enabling traversal outside the intended FTP root.
",1,1,89.96757054328918
69_nsc.c,"
1. YES
      - Heap-based buffer overflow via integer overflow (combo_D1+D2+D3/69_nsc.c:193, combo_D1+D2+D3/69_nsc.c:83):
        length = context->width * context->height * 4 uses 32-bit arithmetic, so attacker-controlled width/height can
        wrap the product and allocate a too-small BitmapData. The decode loop then writes width*height*4 bytes through
        bmpdata, running past the truncated buffer.
      - Heap-based buffer overflow in RLE decoder (combo_D1+D2+D3/69_nsc.c:117, combo_D1+D2+D3/69_nsc.c:123,
        combo_D1+D2+D3/69_nsc.c:127): The run length len read from the compressed stream is never validated against the
        remaining output size left. A crafted stream can make len > left, causing FillMemory(out, len, value) to overrun
        the destination plane buffer and corrupt heap memory.
",1,1,0.015002250671386719
71_riff.c,"
 1. YES
      - CWE-190 Integer Overflow at combo_D1+D2+D3/71_riff.c:288: bytes_to_copy is stored in a signed int even though
        it is derived from the attacker-controlled 32-bit chunk length. Values ≥ 0x80000000 wrap negative, so the
        subsequent I/O call interprets it as a huge unsigned length.
      - CWE-476 Null Pointer Dereference / CWE-789 Uncontrolled Memory Allocation at combo_D1+D2+D3/71_riff.c:289-
        305: the wrapped or simply oversized length is passed to malloc() without checking the result; on failure the
        code still calls DoReadFile() with a NULL buffer, leading to an exploitable crash. Even without wraparound an
        attacker can force extreme allocations and trigger denial of service.
",1,1,0.017998933792114258
127_chgdbmailusers.c,"1. YES
2. - Command Injection — `main.c:20` — `system(cmnd)` executes a shell command assembled from user-controlled argv elements without validation, letting attackers run arbitrary commands, especially dangerous after the privilege-changing `setuid`.
   - Buffer Overflow — `main.c:12` and `main.c:13` — successive `strcat` calls copy unbounded argv data into the fixed `cmnd[255]` buffer, so long arguments can overflow the stack buffer and enable code execution or app crashes.
",1,1,25.49248218536377
