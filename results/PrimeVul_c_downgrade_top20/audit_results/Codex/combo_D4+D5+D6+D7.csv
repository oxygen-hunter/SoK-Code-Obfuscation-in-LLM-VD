file_name,audit_report,input_token_num,output_token_num,inference_time
35_print-vqp.c,"1. YES
2. - Vulnerability: Out-of-bounds read / potential crash; Lines: `vqp_print()` where `vqp_obj_tlv` is parsed (e.g., around the assignments to `vqp_obj_tlv`, `vqp_obj_type`, and `vqp_obj_len`); Reason: the code dereferences `vqp_obj_tlv->obj_type` and `obj_length` before checking that at least `sizeof(struct vqp_obj_tlv_t)` bytes remain in the packet buffer, so a truncated VQP packet can make `EXTRACT_32BITS/EXTRACT_16BITS` read past the captured data and trigger a crash or read of attacker-controlled memory.
",1,1,34.746703147888184
63_common.c,"1. YES
2. - Path traversal / directory escape — `uftpd.c:50` — After resolving the path, the code compares `dir` (which still contains attacker-controlled `..` segments) with `home`, instead of validating the canonicalised `rpath`. An attacker can request paths like `../../etc/passwd`; `realpath` returns `/etc/passwd`, yet the prefix check on `dir` succeeds, so the function hands back a path outside the intended FTP root.  
   - Stack-based buffer overflow — `uftpd.c:31-32` — When the server is not chrooted, it prepends `home` by shifting `dir` with `memmove(dir + len, dir, strlen(dir) + 1)`. If `strlen(dir) + len >= PATH_MAX` (attacker supplies a long path), the shift writes past the end of the fixed-size `dir` buffer, leading to memory corruption.  
   - Privilege-drop bypass — `uftpd.c:122-138` — In `new_session`, even if `setegid()` or `seteuid()` fail, the code only logs a warning, sets `session_info.privs_dropped = 1`, and keeps servicing the session. The process therefore continues running with elevated privileges, enabling full compromise if any other bug is exploited.
3. N/A
4. N/A
",1,1,98.56765723228456
69_nsc.c,"1. YES  
2. - Buffer overflow (heap) — `nsc.c:87`: `FillMemory(out, l, v);` writes `l` bytes into the destination plane buffer without checking that the run-length `l` (taken directly from the compressed stream) fits in the remaining `lft` bytes of the output. A crafted stream can set `l > lft`, causing an out-of-bounds write of attacker-controlled data.  
   - Buffer overflow (heap) — `nsc.c:97`: The tail copy `*((UINT32*)out) = *((UINT32*)in);` unconditionally copies 4 bytes even when fewer than 4 bytes remain (`lft` may be < 4 once the loop exits), so small planes trigger a 1–3 byte overwrite past the buffer end.  
   - Out-of-bounds read — `nsc.c:129`: `context->Planes = Stream_Pointer(s);` captures the remaining stream pointer without verifying that the sum of `context->PlaneByteCount[i]` fits inside the stream. Later, `nsc_rle_decompress_data()` consumes `plnSz` bytes for each plane; if the counts exceed the actual stream length, decoding reads past the supplied data buffer and feeds attacker-controlled memory into the overflow paths above.
",1,1,45.70739030838013
71_riff.c,"
 YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_D4+D5+D6+D7/71_riff.c:288): chunk_header.ckSize is attacker-controlled uint32_t, but     
    it is stored in signed int bytes_to_copy. Values ≥0x80000000 wrap to negative, so the subsequent malloc(bytes_to_copy) requests an   
    impossibly large size (after signed-to-size_t conversion), setting up a crash when the allocation fails.                             
  - Denial of service – unchecked allocation (combo_D4+D5+D6+D7/71_riff.c:289-300): The code never validates buff after malloc. When     
    the allocation above fails (or memory is exhausted), buff becomes NULL but is still passed to DoReadFile, leading to a NULL-pointer  
    dereference and terminating the process on attacker-crafted RIFF chunks.                                                              
",1,1,0.017000675201416016
127_chgdbmailusers.c,"YES  
- Buffer overflow — `main.c:16-20` — `strcpy`/`strcat` append unbounded user-controlled strings into fixed 255-byte `cmnd`, allowing overflow and hijacking execution.  
- Command injection / privilege escalation — `main.c:18-27` — user arguments are concatenated into `cmnd` without sanitization, then executed via `system` after `setuid(0)`, so any user can run arbitrary shell commands as root.
",1,1,15.927672147750854
