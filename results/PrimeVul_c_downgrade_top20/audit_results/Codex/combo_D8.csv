file_name,audit_report,input_token_num,output_token_num,inference_time
35_print-vqp.c,"1. YES
2. - Out-of-bounds Read: `vqp.c:117`, `vqp.c:118`, `vqp.c:119`; the code casts `tptr` to `struct vqp_obj_tlv_t` and immediately calls `EXTRACT_32BITS`/`EXTRACT_16BITS` on `obj_type` and `obj_length` without first confirming that at least `sizeof(struct vqp_obj_tlv_t)` bytes remain. A truncated or malicious packet can make `tlen` smaller than that header size, so these macros read past the capture buffer and crash the dissector.
",1,1,45.360047340393066
63_common.c,"1. YES
2. - Directory traversal (`compose_path`, lines 31-57): The post-`realpath` guard checks `strncmp(dir, home, strlen(home))`, but `dir` still contains the uncanonicalized string (e.g. `/srv/ftp/../../etc/passwd`). Attackers can supply paths starting with the configured prefix followed by `..` segments (such as `../../etc/passwd`), so the prefix comparison passes while the normalized path (`rpath`) resolves outside the intended root, letting them read/write arbitrary filesystem locations when the service runs without a chroot.
",1,1,229.48283624649048
69_nsc.c,"
YES
                                                                                                                                         
  - Heap buffer overflow via integer underflow (combo_D8/69_nsc.c:90-118): During RLE expansion the attacker controls len. When len      
    > left, the unsigned decrement left -= len underflows, the loop keeps running, and FillMemory(out, len, value) writes past the       
    originalSize output buffer, enabling denial of service or code execution.                                                            
  - Heap buffer overflow on final copy (combo_D8/69_nsc.c:126): After the loop it blindly copies four bytes *((UINT32*)out) =            
    *((UINT32*)in); even if the loop already exhausted the originalSize bytes; when the previous underflow occurred, this write also     
    lands out of bounds, compounding the overflow. 
",1,1,0.012000799179077148
71_riff.c,"
YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_D8/71_riff.c:286): chunk_header.ckSize is attacker-controlled uint32_t, but after the &  
    ~1L masking it is stored in signed int bytes_to_copy. Values ≥0x80000000 wrap negative, so when implicitly converted back to size_t  
    for malloc the call requests an absurd size, exhausting memory or failing immediately.                                               
  - Denial of service – unchecked allocation (combo_D8/71_riff.c:287-298): The result of malloc is never validated. When the overflow    
    above (or low-memory conditions) yields buff == NULL, the subsequent DoReadFile(infile, buff, …) dereferences NULL, crashing the     
    process on hostile RIFF input. 
",1,1,0.015995502471923828
127_chgdbmailusers.c,"YES  
- Buffer overflow — `main.c:12-17` — `cmnd` is a fixed 255-byte stack buffer populated via `strcpy`/`strcat` without length checks; crafted arguments can overflow the buffer and overwrite stack data.  
- Command injection with privilege escalation — `main.c:15-23` — unvalidated arguments are concatenated into `cmnd` and executed with `system()` after `setuid(0)`; an attacker can inject shell metacharacters to run arbitrary commands as root.
",1,1,12.94105863571167
