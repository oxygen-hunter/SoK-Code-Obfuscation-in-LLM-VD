file_name,audit_report,input_token_num,output_token_num,inference_time
35_print-vqp.c,"1. YES  
2. - Out-of-bounds read (CWE-125): `vqp_print` `EXTRACT_32BITS(vqp_obj_tlv->obj_type)` and `EXTRACT_16BITS(vqp_obj_tlv->obj_length)` (`vqp_print` around lines 74-75) read 4 and 2 bytes from `tptr` before confirming that `tlen` still holds at least `sizeof(struct vqp_obj_tlv_t)` (6 bytes). With a truncated or maliciously short packet, `tlen` can be less than 6, so these macros dereference beyond the captured buffer, leading to an out-of-bounds read and potential crash.
",1,1,24.34048175811768
63_common.c,"1. YES
2. - Path traversal – `uftpd.c:28-45` (non-chroot mode): the code prepends `home` to `dir` by shifting the existing string but then validates `dir` (still containing unresolved `..`) instead of the canonicalized `rpath`. An attacker can supply inputs such as `../../etc/passwd`, so `realpath()` resolves outside `home` while `strncmp(dir, home, …)` still passes, giving access to filesystem paths beyond the intended FTP root.
   - Stack-based buffer overflow – `uftpd.c:28-29`: when `!chrooted`, `memmove(dir + len, dir, strlen(dir) + 1)` shifts the string right by `len` bytes without ensuring there is at least `len` bytes of free space in the `PATH_MAX` buffer. A long `ctrl->cwd` (controllable via FTP commands) causes writes past the end of `dir`, enabling a crash or potential code execution.
   - Denial of service – `uftpd.c:68-74`: `set_nonblock()` only adds `O_NONBLOCK` when `fcntl(F_GETFL)` returns zero, which never happens on success. Accepted sockets therefore remain blocking, so a client can stall the server simply by not completing a transfer, leading to a resource-exhaustion DoS.
",1,1,245.4549214839936
69_nsc.c,"
YES
                                                                                                                                         
  - Heap buffer overflow (combo_L2/69_nsc.c:105): During RLE decoding the attacker controls len. When len > left, the unsigned decrement 
    left -= len underflows, so FillMemory(out, len, value) writes past the originalSize-sized destination buffer, allowing denial of     
    service or code execution.                                                                                                           
  - Heap buffer overflow (combo_L2/69_nsc.c:116): After the loop the code blindly copies four bytes *((UINT32*)out) = *((UINT32*)in);; if
    the earlier overflow already advanced out past the buffer end, this write also lands out of bounds, compounding the corruption. 
",1,1,0.01199960708618164
71_riff.c,"
YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_L2/71_riff.c:272): The attacker-controlled chunk_header.ckSize (uint32_t) is stored in   
    signed int bytes_to_copy after (ckSize + 1) & ~1L. Values ≥0x80000000 wrap negative; when bytes_to_copy is implicitly cast back to   
    size_t for malloc, it requests an enormous buffer, exhausting memory or failing immediately.                                         
  - Denial of service – unchecked allocation (combo_L2/71_riff.c:273-283): The result of malloc is never checked. If the oversized       
    allocation above (or low memory) yields buff == NULL, the subsequent DoReadFile and WavpackAddWrapper calls dereference NULL,        
    crashing the process on malicious RIFF input.     
",1,1,0.01599907875061035
127_chgdbmailusers.c,"YES  
- Buffer overflow (CWE‑120) at lines 9, 12-13: `strcpy` and repeated `strcat` operations append user-supplied arguments into a fixed 255-byte buffer without bounds checks, so long argv values can overwrite adjacent memory and hijack execution.  
- Command injection (CWE‑78) at lines 12-13 and 20: the program builds a shell command by concatenating raw argv values and runs it with `system`, allowing attackers to inject shell metacharacters (e.g., `;`, `&&`) to execute arbitrary commands.  
- Privilege escalation / unsafe setuid use (CWE‑250) at line 19: the utility unconditionally switches to UID 0 (root) before executing the constructed command, so any command injection or buffer overflow is executed with full root privileges.
",1,1,18.921710729599
