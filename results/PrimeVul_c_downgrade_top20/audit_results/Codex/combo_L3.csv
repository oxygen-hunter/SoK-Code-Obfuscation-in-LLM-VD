file_name,audit_report,input_token_num,output_token_num,inference_time
35_print-vqp.c,"1. YES  
2. • CWE-125 Out-of-Bounds Read — `print-vqp.c:108-113` — `vqp_print()` dereferences `tptr` to read `vqp_obj_tlv->obj_type`/`obj_length` before confirming at least `sizeof(struct vqp_obj_tlv_t)` bytes remain. A truncated or forged packet with `tlen < sizeof(struct vqp_obj_tlv_t)` can force an out-of-bounds read and crash the analyzer (DoS).  
3. Not applicable (code is vulnerable).  
4. Not applicable (finding is confirmed).
",1,1,31.812976598739624
63_common.c,"1. YES  
2. - Stack-based buffer overflow (`uftpd.c:23`): `memmove(dir+len, dir, strlen(dir)+1)` shifts the existing path by `len` bytes without confirming that `len + strlen(dir)` fits within the `PATH_MAX`-sized stack buffer; a long user-controlled path can fill `dir` to near `PATH_MAX`, so the subsequent shift writes past the end of `dir`, enabling remote code execution.  
   - Directory traversal / sandbox escape (`uftpd.c:40`): After canonicalising the resolved path into `rpath`, the code still enforces the `home` confinement by comparing the non-canonical `dir` buffer (`strncmp(dir, home, strlen(home))`). Attackers can supply paths with sequences like `/../` so that `dir` still begins with `home` while the real path in `rpath` resolves outside `home`, letting them access files beyond the intended FTP root when chrooting is disabled.  
3. Not applicable (vulnerabilities found).  
4. Not applicable.
",1,1,73.40697193145752
69_nsc.c,"1. YES
2. - Type: CWE-787 Heap Buffer Overflow; Lines: nsc.c:76-79; Reason: `nsc_rle_decode` trusts the encoded `len` value and subtracts it from `left` without checking `len <= left`, so crafted input can wrap `left` and make `FillMemory(out, len, value)` write far past the plane buffer.
   - Type: CWE-787 Heap Buffer Overflow; Lines: nsc.c:85; Reason: The tail write `*((UINT32*)out) = *((UINT32*)in);` is executed even when fewer than four bytes remain (`left <= 4`), so small or corrupted planes trigger out-of-bounds reads and writes.
   - Type: CWE-190 Integer Overflow / CWE-122 Heap Under-allocation; Lines: nsc.c:124-158; Reason: Width/height values from the message are multiplied in 32-bit arithmetic to size `BitmapData` and plane buffers; large dimensions overflow the calculations, the allocations stay small, and later decode paths still write `width*height` bytes into them.
   - Type: CWE-125 Out-of-bounds Read; Lines: nsc.c:105-115 and nsc.c:93-103; Reason: The stream header supplies per-plane byte counts that are never validated against the remaining stream length, so decompression and `CopyMemory` can read past the provided packet when the counts are forged.
   - Type: CWE-190 Integer Underflow / Undefined Behavior; Lines: nsc.c:20 and nsc.c:38-39; Reason: `ColorLossLevel` comes from the stream, and when it is 0 the computed `shift` becomes 255, leading to an excessive left shift (`*coplane << shift`) that invokes undefined behavior and can crash the decoder.
",1,1,85.50214648246765
71_riff.c,"
YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_L3/71_riff.c:41): chunk_header.ckSize is attacker-controlled uint32_t. After (ckSize +   
    1) & ~1L, the value is stored in signed int bytes_to_copy; when ckSize ≥ 0x80000000, it wraps negative. The subsequent implicit cast 
    back to size_t in malloc requests an absurd allocation, exhausting memory or failing immediately.                                    
  - Denial of service – unchecked allocation (combo_L3/71_riff.c:41): The result of malloc is never validated. If the overflow above (or 
    low memory) yields buff == NULL, DoReadFile(infile, buff, …) dereferences NULL, crashing the process on hostile RIFF chunks.  
",1,1,0.018000125885009766
127_chgdbmailusers.c,"1. YES  
2. - Stack-based Buffer Overflow — `code.c:12` and `code.c:13`; `strcat` appends attacker-controlled arguments into a fixed 255-byte buffer without bounds checking, so long input overflows the stack and enables hijacking control flow while running with elevated privileges.  
   - Command Injection — `code.c:12`–`code.c:20`; attacker-supplied arguments are concatenated into `cmnd` and passed to `system`, which invokes `/bin/sh -c`. Shell metacharacters (`;`, `&&`, `$(…)`) in the arguments let an attacker execute arbitrary commands.  
   - Privileged Command Execution — `code.c:19` and `code.c:20`; the program raises its UID to 0 with `setuid(UID)` and then executes the attacker-crafted command string, so the injected commands run with root authority.
",1,1,30.10865879058838
