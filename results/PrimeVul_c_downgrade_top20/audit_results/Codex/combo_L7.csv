file_name,audit_report,input_token_num,output_token_num,inference_time
35_print-vqp.c,"1. YES  
2. Out-of-bounds read — lines `vqp_print` loop (`vqp_obj_tlv` header parsing, e.g., lines 104-107) — the TLV header fields are read before verifying that `tlen` still holds at least `sizeof(struct vqp_obj_tlv_t)` bytes, so a truncated packet can make `EXTRACT_32BITS`/`EXTRACT_16BITS` read past the buffer and crash the dissector.
",1,1,27.907811641693115
63_common.c,"1. YES
2. - CWE-121 Stack-Based Buffer Overflow — `uftpd.c:28-29`: `memmove(dir + len, dir, strlen(dir) + 1);` shifts the existing path right by `len = strlen(home)` bytes without checking whether there is enough room left in the fixed `PATH_MAX` buffer. A long user-controlled `path` can already fill `dir` close to `PATH_MAX`; adding any non-zero `len` then writes past the end of `dir`, enabling corruption of stack memory.
   - CWE-22 Path Traversal / Root Escape — `uftpd.c:35-48`: when `stat(dir, &st)` finds a non-directory, the code resolves `dir` (which may contain `..` segments or symlinks) with `realpath`, but the subsequent confinement check compares the unnormalised `dir` against `home`. Because `dir` still starts with `home`, crafted input such as `../../etc/passwd` passes the check even though `realpath` returns `/etc/passwd`, allowing access outside the intended FTP root whenever the process is not chrooted.
",1,1,55.66756701469421
69_nsc.c,"
YES
                                                                                                                                         
  - Heap buffer overflow (combo_L7/69_nsc.c:95-139): The inline assembly RLE decoder never bounds-checks the attacker-supplied run       
    length. If len > originalSize, rep stosb writes beyond the originalSize-sized output buffer and subl %eax, %ecx underflows, so the   
    loop keeps running on bogus ecx, corrupting heap memory and enabling remote code execution or a crash.                               
  - Heap buffer overflow (combo_L7/69_nsc.c:95-139): The loop lacks any exit once ecx (bytes left) reaches 0; it continues to read from  
    the input stream and write to the output buffer after all bytes are consumed, so crafted input causes out-of-bounds access even when 
    lengths match exactly. 
",1,1,0.014001607894897461
71_riff.c,"
YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_L7/71_riff.c:284): The attacker controls chunk_header.ckSize (uint32_t). After (ckSize + 
    1) & ~1L, it is stored in signed int bytes_to_copy; values ≥0x80000000 wrap negative. When implicitly cast back to size_t for malloc,    this requests an absurd allocation, exhausting memory or failing immediately.                                                        
  - Denial of service – unchecked allocation (combo_L7/71_riff.c:285-295): The result of malloc is never checked. If the oversized       
    allocation above (or low memory) yields buff == NULL, the following DoReadFile/WavpackAddWrapper use that NULL pointer, crashing the 
    program on malicious RIFF input.    
",1,1,0.016000747680664062
127_chgdbmailusers.c,"1. YES
2. - Stack-based buffer overflow – `main:13-20`; `cmnd` is 255 bytes but `strcpy`/`strcat` copy user-controlled arguments without bounds checks, so long input overflows the stack while the process runs as root.
   - Command injection / privilege escalation – `main:25-27`; user arguments are appended unescaped to `cmnd` and passed to `system`, allowing shell metacharacters to execute arbitrary root-level commands after `setuid(0)`.
",1,1,15.57007360458374
