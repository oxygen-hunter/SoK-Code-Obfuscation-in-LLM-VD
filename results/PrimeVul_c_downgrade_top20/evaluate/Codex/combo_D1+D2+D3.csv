file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES  
2. - Out-of-bounds read – `vqp_print` (`vqp_print`: lines around `vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr;` through `vqp_obj_len = EXTRACT_16BITS(...)`) – the loop dereferences the TLV header without first confirming `tlen >= sizeof(struct vqp_obj_tlv_t)`, so a crafted packet with fewer than 6 bytes left will make the `EXTRACT_32BITS/16BITS` macros read past the captured buffer.
","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,720.0,7.0,1.6835672855377195
63_common.c,"1. YES
2. - Vulnerability: Stack-based buffer overflow (CWE-121)  
     Vulnerable lines: uftpd.c:25-26 (`memmove(dir + len, dir, strlen(dir) + 1);` followed by `memcpy(dir, home, len);`)  
     Reason: When the server runs unchrooted, it prepends `home` to `dir` by shifting the existing contents inside the fixed-size stack buffer `dir[PATH_MAX]` without first ensuring `len + strlen(dir) < PATH_MAX`. An attacker who controls `ctrl->cwd` can push the combined length past `PATH_MAX` and overwrite adjacent stack memory.
   - Vulnerability: Directory traversal / sandbox escape (CWE-22)  
     Vulnerable lines: uftpd.c:29-45 (especially the final check `strncmp(dir, home, strlen(home))`)  
     Reason: After resolving paths with `realpath`, the code verifies containment using the non-canonical `dir` string that still contains sequences like `../`. Because the prefix comparison ignores path segment boundaries and bypasses canonicalisation, inputs such as `../../etc/passwd` yield `rpath` outside `home` (e.g., `/etc/passwd`) while the `strncmp` check still passes, enabling traversal outside the intended FTP root.
","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,917.0,7.0,0.962069034576416
69_nsc.c,"
1. YES
      - Heap-based buffer overflow via integer overflow (combo_D1+D2+D3/69_nsc.c:193, combo_D1+D2+D3/69_nsc.c:83):
        length = context->width * context->height * 4 uses 32-bit arithmetic, so attacker-controlled width/height can
        wrap the product and allocate a too-small BitmapData. The decode loop then writes width*height*4 bytes through
        bmpdata, running past the truncated buffer.
      - Heap-based buffer overflow in RLE decoder (combo_D1+D2+D3/69_nsc.c:117, combo_D1+D2+D3/69_nsc.c:123,
        combo_D1+D2+D3/69_nsc.c:127): The run length len read from the compressed stream is never validated against the
        remaining output size left. A crafted stream can make len > left, causing FillMemory(out, len, value) to overrun
        the destination plane buffer and corrupt heap memory.
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,850.0,7.0,0.7896847724914551
71_riff.c,"
 1. YES
      - CWE-190 Integer Overflow at combo_D1+D2+D3/71_riff.c:288: bytes_to_copy is stored in a signed int even though
        it is derived from the attacker-controlled 32-bit chunk length. Values ≥ 0x80000000 wrap negative, so the
        subsequent I/O call interprets it as a huge unsigned length.
      - CWE-476 Null Pointer Dereference / CWE-789 Uncontrolled Memory Allocation at combo_D1+D2+D3/71_riff.c:289-
        305: the wrapped or simply oversized length is passed to malloc() without checking the result; on failure the
        code still calls DoReadFile() with a NULL buffer, leading to an exploitable crash. Even without wraparound an
        attacker can force extreme allocations and trigger denial of service.
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,834.0,7.0,0.7333650588989258
127_chgdbmailusers.c,"1. YES
2. - Command Injection — `main.c:20` — `system(cmnd)` executes a shell command assembled from user-controlled argv elements without validation, letting attackers run arbitrary commands, especially dangerous after the privilege-changing `setuid`.
   - Buffer Overflow — `main.c:12` and `main.c:13` — successive `strcat` calls copy unbounded argv data into the fixed `cmnd[255]` buffer, so long arguments can overflow the stack buffer and enable code execution or app crashes.
","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",4.0,719.0,7.0,0.7317125797271729
