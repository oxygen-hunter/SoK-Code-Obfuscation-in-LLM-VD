file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES
2. - Vulnerability: Out-of-bounds read / potential crash; Lines: `vqp_print()` where `vqp_obj_tlv` is parsed (e.g., around the assignments to `vqp_obj_tlv`, `vqp_obj_type`, and `vqp_obj_len`); Reason: the code dereferences `vqp_obj_tlv->obj_type` and `obj_length` before checking that at least `sizeof(struct vqp_obj_tlv_t)` bytes remain in the packet buffer, so a truncated VQP packet can make `EXTRACT_32BITS/EXTRACT_16BITS` read past the captured data and trigger a crash or read of attacker-controlled memory.
","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,748.0,7.0,1.6447389125823977
63_common.c,"1. YES
2. - Path traversal / directory escape — `uftpd.c:50` — After resolving the path, the code compares `dir` (which still contains attacker-controlled `..` segments) with `home`, instead of validating the canonicalised `rpath`. An attacker can request paths like `../../etc/passwd`; `realpath` returns `/etc/passwd`, yet the prefix check on `dir` succeeds, so the function hands back a path outside the intended FTP root.  
   - Stack-based buffer overflow — `uftpd.c:31-32` — When the server is not chrooted, it prepends `home` by shifting `dir` with `memmove(dir + len, dir, strlen(dir) + 1)`. If `strlen(dir) + len >= PATH_MAX` (attacker supplies a long path), the shift writes past the end of the fixed-size `dir` buffer, leading to memory corruption.  
   - Privilege-drop bypass — `uftpd.c:122-138` — In `new_session`, even if `setegid()` or `seteuid()` fail, the code only logs a warning, sets `session_info.privs_dropped = 1`, and keeps servicing the session. The process therefore continues running with elevated privileges, enabling full compromise if any other bug is exploited.
3. N/A
4. N/A
","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,928.0,7.0,0.942474126815796
69_nsc.c,"1. YES  
2. - Buffer overflow (heap) — `nsc.c:87`: `FillMemory(out, l, v);` writes `l` bytes into the destination plane buffer without checking that the run-length `l` (taken directly from the compressed stream) fits in the remaining `lft` bytes of the output. A crafted stream can set `l > lft`, causing an out-of-bounds write of attacker-controlled data.  
   - Buffer overflow (heap) — `nsc.c:97`: The tail copy `*((UINT32*)out) = *((UINT32*)in);` unconditionally copies 4 bytes even when fewer than 4 bytes remain (`lft` may be < 4 once the loop exits), so small planes trigger a 1–3 byte overwrite past the buffer end.  
   - Out-of-bounds read — `nsc.c:129`: `context->Planes = Stream_Pointer(s);` captures the remaining stream pointer without verifying that the sum of `context->PlaneByteCount[i]` fits inside the stream. Later, `nsc_rle_decompress_data()` consumes `plnSz` bytes for each plane; if the counts exceed the actual stream length, decoding reads past the supplied data buffer and feeds attacker-controlled memory into the overflow paths above.
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,898.0,7.0,0.765939474105835
71_riff.c,"
 YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_D4+D5+D6+D7/71_riff.c:288): chunk_header.ckSize is attacker-controlled uint32_t, but     
    it is stored in signed int bytes_to_copy. Values ≥0x80000000 wrap to negative, so the subsequent malloc(bytes_to_copy) requests an   
    impossibly large size (after signed-to-size_t conversion), setting up a crash when the allocation fails.                             
  - Denial of service – unchecked allocation (combo_D4+D5+D6+D7/71_riff.c:289-300): The code never validates buff after malloc. When     
    the allocation above fails (or memory is exhausted), buff becomes NULL but is still passed to DoReadFile, leading to a NULL-pointer  
    dereference and terminating the process on attacker-crafted RIFF chunks.                                                              
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,846.0,7.0,0.7366995811462402
127_chgdbmailusers.c,"YES  
- Buffer overflow — `main.c:16-20` — `strcpy`/`strcat` append unbounded user-controlled strings into fixed 255-byte `cmnd`, allowing overflow and hijacking execution.  
- Command injection / privilege escalation — `main.c:18-27` — user arguments are concatenated into `cmnd` without sanitization, then executed via `system` after `setuid(0)`, so any user can run arbitrary shell commands as root.
","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",4.0,708.0,7.0,0.7442159652709961
