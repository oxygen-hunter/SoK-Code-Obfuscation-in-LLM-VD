file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES  
2. - Out-of-bounds read (CWE-125): `vqp_print` `EXTRACT_32BITS(vqp_obj_tlv->obj_type)` and `EXTRACT_16BITS(vqp_obj_tlv->obj_length)` (`vqp_print` around lines 74-75) read 4 and 2 bytes from `tptr` before confirming that `tlen` still holds at least `sizeof(struct vqp_obj_tlv_t)` (6 bytes). With a truncated or maliciously short packet, `tlen` can be less than 6, so these macros dereference beyond the captured buffer, leading to an out-of-bounds read and potential crash.
","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,748.0,7.0,1.20051908493042
63_common.c,"1. YES
2. - Path traversal – `uftpd.c:28-45` (non-chroot mode): the code prepends `home` to `dir` by shifting the existing string but then validates `dir` (still containing unresolved `..`) instead of the canonicalized `rpath`. An attacker can supply inputs such as `../../etc/passwd`, so `realpath()` resolves outside `home` while `strncmp(dir, home, …)` still passes, giving access to filesystem paths beyond the intended FTP root.
   - Stack-based buffer overflow – `uftpd.c:28-29`: when `!chrooted`, `memmove(dir + len, dir, strlen(dir) + 1)` shifts the string right by `len` bytes without ensuring there is at least `len` bytes of free space in the `PATH_MAX` buffer. A long `ctrl->cwd` (controllable via FTP commands) causes writes past the end of `dir`, enabling a crash or potential code execution.
   - Denial of service – `uftpd.c:68-74`: `set_nonblock()` only adds `O_NONBLOCK` when `fcntl(F_GETFL)` returns zero, which never happens on success. Accepted sockets therefore remain blocking, so a client can stall the server simply by not completing a transfer, leading to a resource-exhaustion DoS.
","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,923.0,7.0,0.7678864002227783
69_nsc.c,"
YES
                                                                                                                                         
  - Heap buffer overflow (combo_L2/69_nsc.c:105): During RLE decoding the attacker controls len. When len > left, the unsigned decrement 
    left -= len underflows, so FillMemory(out, len, value) writes past the originalSize-sized destination buffer, allowing denial of     
    service or code execution.                                                                                                           
  - Heap buffer overflow (combo_L2/69_nsc.c:116): After the loop the code blindly copies four bytes *((UINT32*)out) = *((UINT32*)in);; if
    the earlier overflow already advanced out past the buffer end, this write also lands out of bounds, compounding the corruption. 
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,770.0,7.0,0.7435603141784668
71_riff.c,"
YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_L2/71_riff.c:272): The attacker-controlled chunk_header.ckSize (uint32_t) is stored in   
    signed int bytes_to_copy after (ckSize + 1) & ~1L. Values ≥0x80000000 wrap negative; when bytes_to_copy is implicitly cast back to   
    size_t for malloc, it requests an enormous buffer, exhausting memory or failing immediately.                                         
  - Denial of service – unchecked allocation (combo_L2/71_riff.c:273-283): The result of malloc is never checked. If the oversized       
    allocation above (or low memory) yields buff == NULL, the subsequent DoReadFile and WavpackAddWrapper calls dereference NULL,        
    crashing the process on malicious RIFF input.     
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,831.0,7.0,0.7650315761566162
127_chgdbmailusers.c,"YES  
- Buffer overflow (CWE‑120) at lines 9, 12-13: `strcpy` and repeated `strcat` operations append user-supplied arguments into a fixed 255-byte buffer without bounds checks, so long argv values can overwrite adjacent memory and hijack execution.  
- Command injection (CWE‑78) at lines 12-13 and 20: the program builds a shell command by concatenating raw argv values and runs it with `system`, allowing attackers to inject shell metacharacters (e.g., `;`, `&&`) to execute arbitrary commands.  
- Privilege escalation / unsafe setuid use (CWE‑250) at line 19: the utility unconditionally switches to UID 0 (root) before executing the constructed command, so any command injection or buffer overflow is executed with full root privileges.
","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",2.0,784.0,7.0,0.9350790977478028
