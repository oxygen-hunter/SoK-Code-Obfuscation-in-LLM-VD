file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES  
2. • CWE-125 Out-of-Bounds Read — `print-vqp.c:108-113` — `vqp_print()` dereferences `tptr` to read `vqp_obj_tlv->obj_type`/`obj_length` before confirming at least `sizeof(struct vqp_obj_tlv_t)` bytes remain. A truncated or forged packet with `tlen < sizeof(struct vqp_obj_tlv_t)` can force an out-of-bounds read and crash the analyzer (DoS).  
3. Not applicable (code is vulnerable).  
4. Not applicable (finding is confirmed).
","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,730.0,7.0,1.421839952468872
63_common.c,"1. YES  
2. - Stack-based buffer overflow (`uftpd.c:23`): `memmove(dir+len, dir, strlen(dir)+1)` shifts the existing path by `len` bytes without confirming that `len + strlen(dir)` fits within the `PATH_MAX`-sized stack buffer; a long user-controlled path can fill `dir` to near `PATH_MAX`, so the subsequent shift writes past the end of `dir`, enabling remote code execution.  
   - Directory traversal / sandbox escape (`uftpd.c:40`): After canonicalising the resolved path into `rpath`, the code still enforces the `home` confinement by comparing the non-canonical `dir` buffer (`strncmp(dir, home, strlen(home))`). Attackers can supply paths with sequences like `/../` so that `dir` still begins with `home` while the real path in `rpath` resolves outside `home`, letting them access files beyond the intended FTP root when chrooting is disabled.  
3. Not applicable (vulnerabilities found).  
4. Not applicable.
","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,862.0,7.0,0.6769208908081055
69_nsc.c,"1. YES
2. - Type: CWE-787 Heap Buffer Overflow; Lines: nsc.c:76-79; Reason: `nsc_rle_decode` trusts the encoded `len` value and subtracts it from `left` without checking `len <= left`, so crafted input can wrap `left` and make `FillMemory(out, len, value)` write far past the plane buffer.
   - Type: CWE-787 Heap Buffer Overflow; Lines: nsc.c:85; Reason: The tail write `*((UINT32*)out) = *((UINT32*)in);` is executed even when fewer than four bytes remain (`left <= 4`), so small or corrupted planes trigger out-of-bounds reads and writes.
   - Type: CWE-190 Integer Overflow / CWE-122 Heap Under-allocation; Lines: nsc.c:124-158; Reason: Width/height values from the message are multiplied in 32-bit arithmetic to size `BitmapData` and plane buffers; large dimensions overflow the calculations, the allocations stay small, and later decode paths still write `width*height` bytes into them.
   - Type: CWE-125 Out-of-bounds Read; Lines: nsc.c:105-115 and nsc.c:93-103; Reason: The stream header supplies per-plane byte counts that are never validated against the remaining stream length, so decompression and `CopyMemory` can read past the provided packet when the counts are forged.
   - Type: CWE-190 Integer Underflow / Undefined Behavior; Lines: nsc.c:20 and nsc.c:38-39; Reason: `ColorLossLevel` comes from the stream, and when it is 0 the computed `shift` becomes 255, leading to an excessive left shift (`*coplane << shift`) that invokes undefined behavior and can crash the decoder.
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,1008.0,7.0,0.6870737075805664
71_riff.c,"
YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_L3/71_riff.c:41): chunk_header.ckSize is attacker-controlled uint32_t. After (ckSize +   
    1) & ~1L, the value is stored in signed int bytes_to_copy; when ckSize ≥ 0x80000000, it wraps negative. The subsequent implicit cast 
    back to size_t in malloc requests an absurd allocation, exhausting memory or failing immediately.                                    
  - Denial of service – unchecked allocation (combo_L3/71_riff.c:41): The result of malloc is never validated. If the overflow above (or 
    low memory) yields buff == NULL, DoReadFile(infile, buff, …) dereferences NULL, crashing the process on hostile RIFF chunks.  
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,825.0,7.0,0.733626127243042
127_chgdbmailusers.c,"1. YES  
2. - Stack-based Buffer Overflow — `code.c:12` and `code.c:13`; `strcat` appends attacker-controlled arguments into a fixed 255-byte buffer without bounds checking, so long input overflows the stack and enables hijacking control flow while running with elevated privileges.  
   - Command Injection — `code.c:12`–`code.c:20`; attacker-supplied arguments are concatenated into `cmnd` and passed to `system`, which invokes `/bin/sh -c`. Shell metacharacters (`;`, `&&`, `$(…)`) in the arguments let an attacker execute arbitrary commands.  
   - Privileged Command Execution — `code.c:19` and `code.c:20`; the program raises its UID to 0 with `setuid(UID)` and then executes the attacker-crafted command string, so the injected commands run with root authority.
","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",4.0,797.0,7.0,0.7468230724334717
