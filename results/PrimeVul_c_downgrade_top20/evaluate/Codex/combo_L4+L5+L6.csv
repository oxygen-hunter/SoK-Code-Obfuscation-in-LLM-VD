file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES  
2. - `print-vqp.c:64` — Out-of-bounds read (DoS): `process_items()` casts `tptr` to `struct vqp_obj_tlv_t` and reads `obj_type`/`obj_length` before verifying that at least `sizeof(struct vqp_obj_tlv_t)` bytes remain. A truncated or intentionally short packet can force the parser to read past the capture buffer, causing a crash.
","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,697.0,7.0,1.6345820426940918
63_common.c,"1. YES  
2. - Vulnerability: Path traversal / directory escape; Location: `compose_path` in `uftpd.c:47`; Reason: When not chrooted, the code only checks `strncmp(dir, home, strlen(home))` on the pre-normalized string. Inputs such as `/srv/ftp/../../etc/passwd` keep the `home` prefix in `dir`, so the check passes while `realpath` resolves `rpath` outside the FTP root, letting an attacker escape the intended sandbox.  
   - Vulnerability: Stack-based buffer overflow; Location: `compose_path` in `uftpd.c:28`; Reason: `memmove(dir + len, dir, strlen(dir) + 1)` copies `strlen(dir)+1` bytes into `dir + len` without verifying that `strlen(dir) + len < PATH_MAX`. With an attacker-controlled path near `PATH_MAX` bytes, the copy overruns the `dir` stack buffer by `len` bytes, enabling denial of service or code execution when the server runs without chroot.  
3. Not applicable (code is vulnerable).  
4. Not applicable.
","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,878.0,7.0,1.3185241222381592
69_nsc.c,"
YES
                                                                                                                                         
  - Stack exhaustion → denial of service (combo_L4+L5+L6/69_nsc.c:23-67): nsc_decode_recurse processes every pixel via recursion without 
    any depth cap; for typical RDP frame sizes it creates millions of nested calls, overflowing the thread stack and crashing the process    on attacker-supplied frame dimensions.                                                                                               
  - Heap buffer overflow (combo_L4+L5+L6/69_nsc.c:93): While expanding RLE data the attacker controls len; when len > left, the unsigned 
    subtraction left - len underflows and FillMemory(out, len, …) writes past the originalSize buffer, enabling remote code execution or 
    a crash.                                                                                                                             
  - Heap buffer overflow (combo_L4+L5+L6/69_nsc.c:72): The recursion base case always copies four bytes *((UINT32*)out) = *((UINT32*)in);
    even when fewer than four bytes remain (left < 4), corrupting adjacent heap memory and allowing a crafted stream to crash the        
    decoder.    
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,860.0,7.0,1.2673296928405762
71_riff.c,"
YES

  - Denial of service – integer overflow (combo_L4+L5+L6/71_riff.c:275): Attacker-controlled chunk_header.ckSize (uint32_t) is stored    
    in signed int bytes_to_copy after (ckSize + 1) & ~1L; values ≥0x80000000 wrap negative, so when cast back to size_t for malloc the   
    function attempts an absurd allocation, exhausting memory or failing.                                                                
  - Denial of service – unchecked allocation (combo_L4+L5+L6/71_riff.c:276-287): The result of malloc is never validated. If the         
    oversized allocation above (or low memory) yields buff == NULL, the subsequent DoReadFile/WavpackAddWrapper calls dereference NULL,  
    immediately crashing the process on malicious RIFF data.   
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,835.0,7.0,1.5771806240081787
127_chgdbmailusers.c,"YES
- Stack-based buffer overflow (lines 10-11, 18-21): `recursiveConcat` repeatedly calls `strcat` on the fixed 255-byte `cmnd` buffer with unbounded user-controlled argv data, so long inputs can overwrite the stack while the process runs with UID 0.
- OS command injection (lines 21, 27): User-supplied argv values are concatenated directly into `cmnd` and executed via `system`, allowing shell metacharacters to run arbitrary commands with root privileges.
","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",4.0,717.0,7.0,0.739959716796875
