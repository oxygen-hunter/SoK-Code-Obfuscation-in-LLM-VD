file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES  
2. Out-of-bounds read — lines `vqp_print` loop (`vqp_obj_tlv` header parsing, e.g., lines 104-107) — the TLV header fields are read before verifying that `tlen` still holds at least `sizeof(struct vqp_obj_tlv_t)` bytes, so a truncated packet can make `EXTRACT_32BITS`/`EXTRACT_16BITS` read past the buffer and crash the dissector.
","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,703.0,7.0,1.2770202159881592
63_common.c,"1. YES
2. - CWE-121 Stack-Based Buffer Overflow — `uftpd.c:28-29`: `memmove(dir + len, dir, strlen(dir) + 1);` shifts the existing path right by `len = strlen(home)` bytes without checking whether there is enough room left in the fixed `PATH_MAX` buffer. A long user-controlled `path` can already fill `dir` close to `PATH_MAX`; adding any non-zero `len` then writes past the end of `dir`, enabling corruption of stack memory.
   - CWE-22 Path Traversal / Root Escape — `uftpd.c:35-48`: when `stat(dir, &st)` finds a non-directory, the code resolves `dir` (which may contain `..` segments or symlinks) with `realpath`, but the subsequent confinement check compares the unnormalised `dir` against `home`. Because `dir` still starts with `home`, crafted input such as `../../etc/passwd` passes the check even though `realpath` returns `/etc/passwd`, allowing access outside the intended FTP root whenever the process is not chrooted.
","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,878.0,7.0,0.7691996097564697
69_nsc.c,"
YES
                                                                                                                                         
  - Heap buffer overflow (combo_L7/69_nsc.c:95-139): The inline assembly RLE decoder never bounds-checks the attacker-supplied run       
    length. If len > originalSize, rep stosb writes beyond the originalSize-sized output buffer and subl %eax, %ecx underflows, so the   
    loop keeps running on bogus ecx, corrupting heap memory and enabling remote code execution or a crash.                               
  - Heap buffer overflow (combo_L7/69_nsc.c:95-139): The loop lacks any exit once ecx (bytes left) reaches 0; it continues to read from  
    the input stream and write to the output buffer after all bytes are consumed, so crafted input causes out-of-bounds access even when 
    lengths match exactly. 
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,795.0,7.0,0.7719423770904541
71_riff.c,"
YES
                                                                                                                                         
  - Denial of service – integer overflow (combo_L7/71_riff.c:284): The attacker controls chunk_header.ckSize (uint32_t). After (ckSize + 
    1) & ~1L, it is stored in signed int bytes_to_copy; values ≥0x80000000 wrap negative. When implicitly cast back to size_t for malloc,    this requests an absurd allocation, exhausting memory or failing immediately.                                                        
  - Denial of service – unchecked allocation (combo_L7/71_riff.c:285-295): The result of malloc is never checked. If the oversized       
    allocation above (or low memory) yields buff == NULL, the following DoReadFile/WavpackAddWrapper use that NULL pointer, crashing the 
    program on malicious RIFF input.    
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,827.0,7.0,0.7871444225311279
127_chgdbmailusers.c,"1. YES
2. - Stack-based buffer overflow – `main:13-20`; `cmnd` is 255 bytes but `strcpy`/`strcat` copy user-controlled arguments without bounds checks, so long input overflows the stack while the process runs as root.
   - Command injection / privilege escalation – `main:25-27`; user arguments are appended unescaped to `cmnd` and passed to `system`, allowing shell metacharacters to execute arbitrary root-level commands after `setuid(0)`.
","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",4.0,719.0,7.0,0.749164342880249
