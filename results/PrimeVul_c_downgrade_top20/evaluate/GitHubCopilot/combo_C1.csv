file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES.
2. Vulnerabilities: out-of-bounds read when parsing the TLV header without a prior bounds check before “vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr; vqp_obj_type = EXTRACT_32BITS(...); vqp_obj_len = EXTRACT_16BITS(...);” (the loop lacks tlen >= sizeof(struct vqp_obj_tlv_t) verification); out-of-bounds read in value handlers by calling ipaddr_string/EXTRACT_32BITS for VQP_OBJ_IP_ADDRESS without ensuring vqp_obj_len >= 4 and etheraddr_string for VQP_OBJ_MAC_ADDRESS/MAC_NULL without ensuring vqp_obj_len >= 6; possible length-tracking underflow/logic error from “tlen -= sizeof(struct vqp_obj_tlv_t)” and “tlen -= vqp_obj_len” allowing execution with insufficient data since the TLV header read has no ND_TCHECK/ND_TCHECK2.
3. N/A.
4. N/A.

","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,813.0,7.0,2.615851879119873
63_common.c,"1) YES
2) - CWE-121/120 (stack buffer overflow) — compose_path: memmove(dir + len, dir, strlen(dir) + 1); memcpy(dir, home, len); — No bounds check when prepending home can exceed PATH_MAX if dir is near limit.
   - CWE-22 (path traversal/sandbox escape) — compose_path: only checks if (!chrooted && strncmp(dir, home, strlen(home))) on the uncanonicalized dir; returns rpath from realpath() without verifying it stays under home, enabling escape via symlinks; also lacks boundary check for home prefix (e.g., ""/ftp"" vs ""/ftpX"").
   - CWE-476 (NULL dereference/DoS) — compose_path: name = basename(path); — path can be NULL when (!path || !strlen(path)) and stat(dir) fails, leading to crash.
   - CWE-125 (out-of-bounds read) — compose_path: if (dir[strlen(dir) - 1] != '/') — ctrl->cwd may be empty, indexing before buffer.
   - CWE-362 (race/non-reentrancy) — compose_path: static char rpath[PATH_MAX]; return rpath; — Shared static buffer is not thread-safe; concurrent calls clobber results.
   - CWE-250 (improper privilege drop) — new_session: setegid(...); seteuid(...); — Only effective IDs changed; real UID likely remains 0, allowing privilege regain; coupled with CWE-285 — access(home, W_OK) uses real UID, making the writability check incorrect after “drop”.
   - CWE-778/404 (FD leak across exec) — open_socket: no fcntl(sd, F_SETFD, FD_CLOEXEC) — File descriptors may leak to exec’d children, enabling unintended access.
   - Availability/logic bug (may cause DoS) — set_nonblock: if (!flags) fcntl(..., F_SETFL, flags | O_NONBLOCK); — fcntl(F_GETFL) returns -1 on error; code sets nonblock only when flags == 0, so sockets may remain blocking.
   - Robustness bug (size mismatch) — open_socket: socklen_t len = sizeof(struct sockaddr); passed to bind() with sockaddr_in — Wrong length can cause failures/UB on some platforms.
3) N/A
4) N/A

","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,1139.0,7.0,1.2414729595184326
69_nsc.c,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Out-of-bounds read/write and integer underflow in RLE decoder
  - Vulnerable lines:
    - nsc_rle_decode: value = *in++; else if (value == *in) { in++; if (*in < 0xFF) { len = (UINT32)*in++; ... } else { in++; len = *((UINT32*) in); in += 4; } FillMemory(out, len, value); out += len; left -= len; } … *((UINT32*)out) = *((UINT32*)in);
  - Reason:
    - No input length is tracked; reads from in without bounds checks (OOB read).
    - len is not validated against left; left -= len can underflow (UINT32) and the loop continues, causing large OOB writes (heap overflow) and potential infinite loop (DoS).
    - The final 4-byte copy writes 4 bytes even when fewer than 4 bytes remain in the output (OOB write) and reads 4 bytes from input without ensuring availability (OOB read).
    - Uses unaligned 32-bit loads/stores on possibly unaligned pointers.

- OOB read across plane boundaries during decompression
  - Vulnerable lines:
    - nsc_rle_decompress_data: else if (planeSize < originalSize) nsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize); rle += planeSize;
  - Reason:
    - The decoder is given only originalSize; it will read past the end of the compressed plane (planeSize) into subsequent planes or beyond the stream since nsc_rle_decode has no source bound.

- Insufficient stream bounds validation for plane data
  - Vulnerable lines:
    - nsc_stream_initialize: for (i = 0; i < 4; i++) Stream_Read_UINT32(s, context->PlaneByteCount[i]); … context->Planes = Stream_Pointer(s);
  - Reason:
    - Verifies only the 20-byte header, but never checks that the remaining buffer length is at least the sum of PlaneByteCount[0..3]. Subsequent decoding can OOB-read from context->Planes.

- Integer overflows in size calculations leading to heap OOB writes
  - Vulnerable lines:
    - nsc_context_initialize: length = context->width * context->height * 4;
    - length = tempWidth * tempHeight;
    - context->OrgByteCount[i] = context->width * context->height;
    - context->OrgByteCount[0] = tempWidth * context->height;
    - context->OrgByteCount[1] = (tempWidth >> 1) * (tempHeight >> 1);
  - Reason:
    - width and height are 32-bit; multiplications can overflow UINT32, resulting in undersized allocations. Later writes (per-pixel 4 bytes in nsc_decode, FillMemory/CopyMemory using OrgByteCount) overflow the heap.

- Undefined behavior from unchecked left shift (potential DoS)
  - Vulnerable lines:
    - nsc_decode: BYTE shift = context->ColorLossLevel - 1; INT16 co_val = (INT16)(INT8)(*coplane << shift); INT16 cg_val = (INT16)(INT8)(*cgplane << shift);
  - Reason:
    - If ColorLossLevel == 0 or is large, shift can be >= the bit width, causing undefined behavior and possible crashes.

- Lack of validation that PlaneBuffers are large enough for computed access
  - Vulnerable lines:
    - nsc_decode: yplane/coplane/cgplane/aplane pointer arithmetic combined with loops over width/height.
  - Reason:
    - Relies entirely on prior (overflow-prone) allocations and on sum of plane sizes being valid; with earlier issues, these accesses can read/write out of bounds.

- Robustness/DoS due to non-deterministic control flow
  - Vulnerable lines:
    - nsc_rle_decompress_data: int random_check = rand() % 10; if (random_check > 5) { … } else { /* do nothing */ }
    - nsc_stream_initialize: int arbitrary_check = rand() % 100; …
  - Reason:
    - Randomized behavior can leave the codec in inconsistent states (e.g., skipping decompression), provoking denial-of-service or unpredictable results. Not memory-corruption itself, but degrades security robustness.

3. If NO, please tell me the reason:
Not applicable.

4. If you are not sure, please tell me the reason:
Not applicable.
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,1607.0,7.0,1.4383430480957031
71_riff.c,"

","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",1.0,653.0,7.0,0.7596919536590576
127_chgdbmailusers.c,"1. YES
2. - Command injection (lines 21–22, 30): argv is concatenated into a shell command and executed via system(), enabling injection via shell metacharacters; exacerbated by setuid(0) running the command as root. 
   - Buffer overflow (lines 13–14, 21–22): strcpy/strcat append unbounded data into a 255-byte buffer cmnd, allowing overflow with long args. 
   - Use of uninitialized variables (lines 18, 26): cnt used before initialization and rc/cc printed uninitialized, causing undefined behavior and potential info leak.

","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",4.0,735.0,7.0,1.1775143146514893
