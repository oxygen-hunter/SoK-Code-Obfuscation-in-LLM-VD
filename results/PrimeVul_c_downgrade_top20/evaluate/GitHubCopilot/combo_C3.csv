file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES
2. Vulnerabilities: (a) OOB/UB instruction fetch due to no program_length bounds and uninitialized program array: vm_run: switch (vm->program[vm->pc]); (vm_init doesn’t clear program); (b) Unchecked jump operands allow invalid pc: JMP: vm->pc = vm->program[++vm->pc] - 1; JZ: int addr = vm->program[++vm->pc]; if (vm_pop(vm) == 0) { vm->pc = addr - 1; } (pc can go <0 or ≥256, leading to OOB access); (c) OOB memory R/W: LOAD: vm_push(vm, vm->memory[vm->program[vm->pc]]); STORE: vm->memory[vm->program[vm->pc]] = vm_pop(vm); (no bounds check on memory index); (d) DoS/crash: exit(1) in vm_push/vm_pop and unchecked jumps can cause infinite loops.

","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",2.0,815.0,7.0,2.5040123462677
63_common.c,"1. YES
2. - Stack overflow/underflow: push(VM): vm->stack[++vm->sp]; pop(VM): vm->stack[vm->sp--]; reason: no bounds checks on sp, leading to OOB write/read.
   - OOB read/write (program memory) and arbitrary jumps: operand fetches vm->program[vm->pc++] (PUSH/LOAD/JZ/STORE), JMP/CALL use vm->pc = vm->program[vm->pc], RET uses vm->pc = pop(vm), STORE writes vm->program[vm->program[vm->pc++]] = pop(vm); reason: no range/negative checks on pc/targets; STORE can write past vm->program causing memory corruption.
   - Use of uninitialized memory: init_vm() doesn’t clear vm->program; compile_compose_path sets CALL to address 10 and compile_open_socket to 20 without defining those entries; reason: executing uninitialized ints (opcodes/operands) is undefined behavior.
   - Denial of Service: run_vm() while loop with unrestricted control flow and no instruction/step limit; reason: crafted bytecode can loop forever without HALT.
   - Residual state leak: main() calls init_vm(&vm) between runs but doesn’t clear vm->program; reason: stale instructions may be (accidentally) executed after jumps beyond the small compiled stubs.
3. N/A
4. N/A

","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",2.0,938.0,7.0,0.8393797874450684
69_nsc.c,"1. YES
2. - Stack overflow/underflow: ""vm->stack[++vm->sp] = value;"" and ""return vm->stack[vm->sp--];"" (in push/pop). Reason: sp is never bounds-checked, allowing out-of-bounds read/write and memory corruption.
   - Program counter OOB/arbitrary jump: ""OpCode op = vm->code[vm->pc++];"", ""vm->pc = vm->code[vm->pc];"" (JMP), and ""int addr = vm->code[vm->pc++]; if (pop(vm) == 0) vm->pc = addr;"" (JZ). Reason: pc and jump targets are unvalidated, enabling OOB instruction fetch, unintended control flow, or infinite loops.
   - Memory OOB in LOAD/STORE: ""int addr = vm->code[vm->pc++]; push(vm, vm->memory[addr]);"" and ""int addr = vm->code[vm->pc++]; vm->memory[addr] = pop(vm);"". Reason: addr is unvalidated, enabling out-of-bounds memory access.
   - Use of uninitialized memory/state: ""VM vm;"" (in main) and reading ""vm->code[vm->pc++]"" without ensuring initialized/within range; also printing ""pop(vm)"" after run. Reason: uninitialized arrays/fields and potential empty stack pop cause undefined behavior and possible info leak/crash.
   - Missing invalid opcode handling: switch over op has no default. Reason: unexpected opcode leads to undefined behavior/DoS rather than safe halt.
3. N/A
4. N/A

","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,966.0,7.0,0.7740602493286133
71_riff.c,"1. YES
2. - Stack-based buffer overflow/underflow: vm_push: ""vm->stack[++vm->sp] = value;"" and vm_pop: ""return vm->stack[vm->sp--];"" — no bounds checks on sp allow sp < 0 or sp > 255 causing out-of-bounds read/write.
   - Out-of-bounds instruction fetch and arbitrary jumps: vm_execute: ""VMInstruction* instr = &vm->code[vm->pc++];"", and control-flow ops ""vm->pc = instr->operand;"" / ""vm->pc = vm_pop(vm);"" — no validation that pc stays within [0,1023] and non-negative permits OOB reads/crashes.
   - Out-of-bounds stack access via operands: VM_LOAD/VM_STORE: ""vm_push(vm, vm->stack[instr->operand]);"" and ""vm->stack[instr->operand] = vm_pop(vm);"" — no range checks on instr->operand (0..255) enable OOB read/write.
3. N/A
4. N/A

","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",2.0,877.0,7.0,0.8886642456054688
127_chgdbmailusers.c,"1. YES

2. Vulnerabilities:
- CWE-787/783/476: Unchecked VM stack operations (push/pop) and stack underflow/overflow
  - Lines: push(), pop(), run_vm() switch cases using push/pop
  - Reason: No bounds checks on sp; push/pop can read/write outside vm->stack, leading to memory corruption.
- CWE-787: Out-of-bounds code execution and arbitrary jumps
  - Lines: JMP/JZ/CALL/RET cases in run_vm()
  - Reason: vm->pc and jump targets are not validated against CODE_SIZE, enabling out-of-bounds reads/writes of vm->code and undefined control flow.
- CWE-787: Unchecked indexed access to stack
  - Lines: LOAD/STORE cases in run_vm()
  - Reason: addr is used directly to index vm->stack without validating 0 <= addr < STACK_SIZE.
- CWE-242/CWE-120: Unsafe use of strcpy
  - Line: strcpy(cmnd, CMD);
  - Reason: Copies into fixed-size buffer without length check; overflow if CMD changes or is longer than buffer.
- CWE-250 (Execution with unnecessary privileges) and dangerous system() in privileged context
  - Lines: #define UID 0, bytecode path that calls setuid(UID) then system
  - Reason: Attempts to setuid(0) and invoke system; if SUID, runs shell command as root, exposing risk from environment and shell interpretation; use execve with cleared env instead.
- CWE-704: Pointer-to-int truncation
  - Lines: push(&vm, (int)argv); and storing (int)setuid/(int)system into vm.code
  - Reason: On 64-bit, casting pointers to int truncates and causes undefined behavior/memory corruption.
- Robustness flaw impacting security: Undefined/incorrect opcode usage
  - Line: vm.code[6] = SUB; (SUB not defined in Instruction)
  - Reason: Mismatched opcodes can lead to unintended control flow, increasing exploitability.

3. N/A

4. N/A

","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",2.0,1048.0,7.0,0.7790303230285645
