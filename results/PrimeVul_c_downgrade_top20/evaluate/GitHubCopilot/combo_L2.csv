file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES
2. - Out-of-bounds read (TLV header): lines reading TLV header without bounds check: “vqp_obj_tlv = (const struct vqp_obj_tlv_t *)tptr; vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type); vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length); tptr+=sizeof(struct vqp_obj_tlv_t); tlen-=sizeof(struct vqp_obj_tlv_t);” Reason: no ND_TCHECK/ND_TCHECK2 ensuring tlen/capture has ≥ sizeof(struct vqp_obj_tlv_t) before accessing/advancing, leading to OOB read on short/truncated packets.
   - Out-of-bounds read (fixed-size field length too small): “case VQP_OBJ_IP_ADDRESS: ND_PRINT((…, ipaddr_string(ndo, tptr), …));” and “case VQP_OBJ_MAC_ADDRESS/ MAC_NULL: ND_PRINT((…, etheraddr_string(ndo, tptr)));” Reason: only ND_TCHECK2(*tptr, vqp_obj_len) is used; if vqp_obj_len < 4 (IP) or < 6 (MAC), helpers read past the available object bytes and can overrun the captured buffer.
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",4.0,884.0,7.0,1.392303228378296
63_common.c,"1. YES
2. Vulnerabilities: stack buffer overflow when prefixing home into dir without capacity check (memmove(dir + len, dir, strlen(dir) + 1); memcpy(dir, home, len);) because len + strlen(dir) + 1 can exceed sizeof(dir); path traversal/sandbox escape in non-chroot mode due to checking dir against home instead of the resolved path rpath, making the check ineffective (if (!chrooted && strncmp(dir, home, strlen(home))); prior concatenation via memmove/memcpy also aids this); symlink race/TOCTOU by realpath() on parent then appending basename leaves final component unresolved and attacker-controlled (name = basename(path); ptr = dirname(dir); realpath(ptr, rpath); strlcat(rpath, ""/"", ...); strlcat(rpath, name, ...)); NULL dereference/UB by calling basename(path) when path can be NULL (name = basename(path)); incomplete privilege drop allows privilege regain by using seteuid/setegid only (real IDs remain 0) (if (!privs_dropped && pw && geteuid() == 0) { ... setegid(...); seteuid(...); ... }); incorrect permission check using access() after seteuid relies on real UID (likely still 0), yielding unreliable/wrong security decision (if (!do_insecure && !access(home, W_OK))); non-blocking setup bug (DoS risk) since O_NONBLOCK set only if flags == 0 (if (!flags) fcntl(...))
3. N/A
4. N/A

","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,966.0,7.0,0.7698855400085449
69_nsc.c,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Out-of-bounds read/write and integer underflow in RLE decoder
  - Vulnerable lines: 82, 89–103, 105–108, 116
  - Reason: The decoder reads from “in” without any input-length bound and never verifies that len ≤ left before FillMemory. This allows reading past the compressed buffer and writing past the output buffer (left can underflow and wrap). The tail copy unconditionally copies 4 bytes: *((UINT32*)out) = *((UINT32*)in), causing OOB read/write if fewer than 4 bytes remain. Also uses potentially unaligned 32-bit accesses (lines 101, 116).

- OOB read across plane boundaries during decompression (no compressed-size bound)
  - Vulnerable lines: 132–139, 135
  - Reason: nsc_rle_decompress_data passes only originalSize to nsc_rle_decode and never enforces planeSize as the source bound. If the compressed plane is shorter than needed, the decoder reads into the next plane or beyond the stream.

- Insufficient stream bounds validation for plane data
  - Vulnerable lines: 147–158
  - Reason: Only the 20-byte header is checked. The code never verifies that the stream contains at least sum(PlaneByteCount[0..3]) bytes before setting context->Planes, enabling OOB reads when decompressing/copying plane data.

- Integer overflows in size calculations leading to heap OOB writes
  - Vulnerable lines: 171, 196, 215, 220–222
  - Reason: width and height are 32-bit. Calculations like width*height*4 and tempWidth*tempHeight can overflow UINT32, yielding undersized allocations. Subsequent writes in nsc_decode (lines 61–64) and decompression can overflow the heap.

- Undefined behavior due to unchecked shift amount (possible crash/DoS)
  - Vulnerable lines: 28, 56–57
  - Reason: shift = ColorLossLevel - 1 is not validated. If ColorLossLevel is 0 or large, shifting by an invalid amount is undefined behavior.

- Missing validation of untrusted parameters
  - Vulnerable lines: 153–156
  - Reason: ColorLossLevel and ChromaSubsamplingLevel are read from the stream without range checks, enabling the shift UB and inconsistent plane stepping.

- Unaligned 32-bit memory accesses
  - Vulnerable lines: 101, 116
  - Reason: Directly dereferencing UINT32* on possibly unaligned buffers may fault on strict-alignment systems and exacerbates OOB issues.

- Potential DoS via unbounded allocations from untrusted dimensions
  - Vulnerable lines: 171, 175–192, 196–211
  - Reason: Large width/height from the stream drive allocations without caps, allowing memory exhaustion.

3. If NO, please tell me the reason:
N/A

4. If you are not sure, please tell me the reason:
N/A
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,1281.0,7.0,0.7915260791778564
71_riff.c,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Integer truncation/overflow + missing NULL check when copying unknown chunks (can cause crash/heap issues)
  - Vulnerable lines:
    - int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
    - char *buff = malloc(bytes_to_copy);
    - if (!DoReadFile(infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper(wpc, buff, bytes_to_copy))) { ... }
  - Reason:
    - chunk_header.ckSize is uint32_t but bytes_to_copy is int. Large ckSize may truncate to negative or smaller int. malloc result is not checked; DoReadFile then writes bytes_to_copy bytes into buff, which may be NULL, causing a NULL dereference/DoS. Passing a negative int as a byte count also promotes to a huge size_t in called APIs.

- Integer overflow in DS64 table-length validation (validation bypass → excessive reads/DoS)
  - Vulnerable lines:
    - if (ds64_chunk.tableLength * sizeof(CS64Chunk) != chunk_header.ckSize - sizeof(DS64Chunk)) { ... }
    - while (ds64_chunk.tableLength--) { CS64Chunk cs64_chunk; if (!DoReadFile(infile, &cs64_chunk, sizeof(CS64Chunk), &bcount) || bcount != sizeof(CS64Chunk) || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper(wpc, &cs64_chunk, sizeof(CS64Chunk)))) { ... } }
  - Reason:
    - ds64_chunk.tableLength is uint32_t; the multiplication can overflow 32-bit and let the equality check pass incorrectly. The subsequent loop then attempts to read an excessive number of entries, leading to prolonged I/O or EOF-driven denial of service.

- Truncation of 64-bit sizes when writing non-RF64 headers (malformed output)
  - Vulnerable lines:
    - else { riffhdr.ckSize = (uint32_t) total_riff_bytes; datahdr.ckSize = (uint32_t) total_data_bytes; }
  - Reason:
    - do_rf64 is selected based only on total_data_bytes. total_riff_bytes can exceed 32 bits even when data does not; casting truncates, producing invalid RIFF headers that may break downstream parsers.

- Arithmetic overflow in data-rate and size calculations (incorrect metadata, potential logic errors)
  - Vulnerable lines:
    - total_data_bytes = total_samples * bytes_per_sample * num_channels;
    - wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;
  - Reason:
    - total_samples multiplication can overflow int64_t for extreme values; BytesPerSecond uses 32-bit arithmetic and can overflow for large rates/channel counts, yielding incorrect header fields.

3. If NO, please tell me the reason:
N/A

4. If you are not sure, please tell me the reason:
N/A
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,1312.0,7.0,2.0282764434814453
127_chgdbmailusers.c,"1. YES
2. Vulnerabilities:
   - Buffer overflow (lines 9, 12, 13): strcpy/strcat into cmnd[255] without bounds allows overflow via long argv.
   - Command injection (lines 12–13, 20): User input is concatenated into a shell command and passed to system(), enabling injection via shell metacharacters.
   - Privileged command execution with system() (lines 19–20): setuid(0) then system() runs a shell as root, which is unsafe for SUID programs; avoid shells and sanitize/execve with fixed argv.
   - Use of uninitialized variables (line 16): rc and cc are printed before being set, causing undefined behavior and potential info leak.
3. N/A
4. N/A

","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",4.0,773.0,7.0,0.9248340129852296
