file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
35_print-vqp.c,"1. YES
2. - CWE-427/CWE-114 (Insecure dynamic library loading / Uncontrolled Search Path): C line 62: handle = dlopen(""./libvqp.so"", RTLD_LAZY); and Python line 80: lib = ctypes.CDLL('./libvqp.so'); Reason: Loading a .so via a relative path enables DLL side-loading if an attacker places a malicious libvqp.so in the working directory.
   - CWE-843/CWE-787 (Type Confusion / Out-of-bounds Read/Write via unsafe FFI): Python lines 81–86 define empty ctypes.Structure types and call lib.load_and_run_vqp_print without setting argtypes/restype, passing mismatched pointers (NetdissectOptions/UChar) to C’s (netdissect_options*, const u_char*, u_int); Reason: Missing type enforcement can corrupt memory or crash when C treats these as valid buffers/structures.
   - CWE-20/CWE-476/CWE-787 (Improper Input Validation / NULL Pointer Dereference / OOB Read): C line 73: vqp_print(ndo, pptr, len); Reason: No validation of ndo/pptr/len before forwarding to plugin; a NULL/invalid pointer or inconsistent length can cause OOB reads or crashes inside the loaded function.
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2017-13045

The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
",2.0,887.0,7.0,1.814857721328736
63_common.c,"1. YES
2. - Path traversal / sandbox escape when not chrooted — lines: if (!chrooted && strncmp(dir, home, strlen(home))) { ... } plus use of dir (non-canonical) after realpath; reason: check compares non-canonical dir instead of canonical rpath, allowing inputs like ""/srv/ftp/../../etc/passwd"" to resolve outside home while prefix test still passes
   - Stack buffer overflow — lines: memmove(dir + len, dir, strlen(dir) + 1); memcpy(dir, home, len); reason: no bound check on len + strlen(dir) against sizeof(dir) (PATH_MAX), so prepending home can write past dir
   - Unsafe static buffer / race — lines: static char rpath[PATH_MAX]; return rpath; reason: global static return buffer is not thread-safe, enabling cross-request data races and info leaks
   - Incomplete privilege drop — lines: if ((fail1 = setegid(pw->pw_gid))) ... if ((fail2 = seteuid(pw->pw_uid))) ...; reason: only effective IDs changed (seteuid/setegid), allowing potential privilege regain; should permanently drop with setgid/setuid (and possibly setgroups, prctl/seccomp)
   - Unsafe use of basename/dirname and Python capsule — lines: name = basename(path); ptr = dirname(dir); ctrl_t* ctrl = (ctrl_t*)PyCapsule_GetPointer(py_ctrl, NULL); reason: basename may modify input buffer (path from Python ""s""), dirname modifies dir in place, NULL capsule name disables type safety and may yield NULL or arbitrary pointer causing DoS; also possible NULL deref on basename(path) if path is NULL
   - Silent truncation risks — lines: strlcpy/strlcat calls (e.g., strlcat(dir, path, sizeof(dir)); strlcat(rpath, name, sizeof(rpath))); reason: truncation not checked can result in unintended paths or bypasses of prefix checks
   - TOCTOU on filesystem — lines: if (!stat(dir, &st) && S_ISDIR(...)) { if (!realpath(dir, rpath)) ... } else { ... realpath(ptr, rpath) ... }; reason: path may change between stat and realpath leading to incorrect authorization
3. N/A
4. N/A

","CWE: CWE-22
CVE: CVE-2020-5221

In uftpd before 2.11, it is possible for an unauthenticated user to perform a directory traversal attack using multiple different FTP commands and read and write to arbitrary locations on the filesystem due to the lack of a well-written chroot jail in compose_abspath(). This has been fixed in version 2.11
",4.0,1131.0,7.0,0.7219290733337402
69_nsc.c,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Out-of-bounds read/write and length underflow in RLE decoder
  - Vulnerable lines:
    - In nsc_rle_decode: 
      - value = *in++;
      - else if (value == *in) { in++; if (*in < 0xFF) { len = (UINT32)*in++; len += 2; } else { in++; len = *((UINT32*) in); in += 4; } FillMemory(out, len, value); out += len; left -= len; }
      - *((UINT32*)out) = *((UINT32*)in);
  - Reason: No input bound is tracked; reads from “in” without verifying availability (OOB read). len is not validated against left, so left can underflow (UINT32) and writes overflow the output buffer (heap overflow). Tail copy always reads/writes 4 bytes regardless of remaining bytes. Uses potentially unaligned 32-bit accesses.

- OOB read across plane boundaries during decompression
  - Vulnerable lines:
    - In nsc_rle_decompress_data: else if (planeSize < originalSize) nsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize); rle += planeSize;
  - Reason: Decoder is given only originalSize; compressed source length (planeSize) is not enforced, so it can read past the current plane into subsequent data.

- Insufficient stream bounds validation for plane data
  - Vulnerable lines:
    - In nsc_stream_initialize: if (Stream_GetRemainingLength(s) < 20) return FALSE; … Stream_Read_UINT32(s, context->PlaneByteCount[i]); … context->Planes = Stream_Pointer(s);
  - Reason: Does not verify that the remaining buffer contains at least sum(PlaneByteCount[0..3]) bytes before setting Planes, enabling OOB reads.

- Integer overflows in size calculations → undersized allocations and heap overflow
  - Vulnerable lines:
    - In nsc_context_initialize:
      - length = context->width * context->height * 4;
      - tempWidth = ROUND_UP_TO(context->width, 8); tempHeight = ROUND_UP_TO(context->height, 2); length = tempWidth * tempHeight;
      - context->OrgByteCount[i] = context->width * context->height; and subsampled variants.
  - Reason: width/height are 32-bit; multiplications can overflow, causing too-small allocations. Subsequent writes in decode and FillMemory overflow heap buffers.

- Undefined behavior due to unchecked shift
  - Vulnerable lines:
    - In nsc_decode: BYTE shift = context->ColorLossLevel - 1; INT16 co_val = (INT16)(INT8)(*coplane << shift); INT16 cg_val = (INT16)(INT8)(*cgplane << shift);
  - Reason: If ColorLossLevel == 0 or large, shift is invalid, causing undefined behavior and potential crash/DoS.

- Arbitrary code execution risk via unsafe Python module import
  - Vulnerable lines:
    - In nsc_decode: Py_Initialize(); pName = PyUnicode_DecodeFSDefault(""nsc_decoder""); pModule = PyImport_Import(pName); pFunc = PyObject_GetAttrString(pModule, ""decode_line""); PyObject_CallObject(…);
  - Reason: Imports and executes a Python module by name without controlling/sanitizing the module search path. An attacker who can influence PYTHONPATH/CWD could load a malicious module, leading to code execution. Also per-pixel Python calls enable severe performance DoS.

- Python interpreter misuse (thread-safety/DoS)
  - Vulnerable lines:
    - In nsc_decode: Py_Initialize(); Py_Finalize();
  - Reason: Initializing/finalizing the interpreter inside a codec function without GIL management is not thread-safe and can crash in multi-threaded contexts; repeated init/finalize can cause instability.

- Potential unbounded memory usage (DoS)
  - Vulnerable lines:
    - In nsc_context_initialize: calloc/realloc based on unbounded width/height and plane counts.
  - Reason: Large untrusted dimensions or counts can trigger excessive allocations and memory exhaustion.

- Unaligned 32-bit memory access
  - Vulnerable lines:
    - In nsc_rle_decode: len = *((UINT32*) in); *((UINT32*)out) = *((UINT32*)in);
  - Reason: May fault on strict-alignment architectures and exacerbates OOB issues.

- Stride size overflow
  - Vulnerable lines:
    - In nsc_process_message: if (nDstStride == 0) nDstStride = nWidth * GetBytesPerPixel(DstFormat);
  - Reason: nWidth multiplication can overflow 32-bit, propagating incorrect sizes to downstream copy and risking buffer overruns in the destination.

3. If NO, please tell me the reason:
N/A

4. If you are not sure, please tell me the reason:
N/A
","CWE: CWE-787
CVE: CVE-2018-8788

FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
",4.0,1687.0,7.0,0.8293991088867188
71_riff.c,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Integer truncation/overflow and missing NULL check (heap OOB/NULL deref/DoS)
  - Vulnerable lines:
    - ParseRiffHeaderConfig: int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;
    - ParseRiffHeaderConfig: char* buff = malloc(bytes_to_copy);
    - ParseRiffHeaderConfig: DoReadFile(infile, buff, bytes_to_copy, &bcount) and WavpackAddWrapper(wpc, buff, bytes_to_copy)
  - Reason:
    - ckSize is uint32_t but bytes_to_copy is int. Large ckSize can wrap/truncate to negative/small values. malloc result is not checked before use; passing a negative int to read/append promotes to a large size_t. This can cause NULL dereference or out-of-bounds read/write and memory-exhaustion.

- Integer overflow in ds64 table-length validation (validation bypass → excessive reads/DoS)
  - Vulnerable lines:
    - ParseRiffHeaderConfig: if (ds64_chunk.tableLength * sizeof(CS64Chunk) != chunk_header.ckSize - sizeof(DS64Chunk)) { … }
    - ParseRiffHeaderConfig: while (ds64_chunk.tableLength--) { DoReadFile(infile, &cs64_chunk, sizeof(CS64Chunk), &bcount) … }
  - Reason:
    - tableLength is uint32_t; the multiplication is 32-bit and can overflow, letting the check pass incorrectly. The loop may then attempt to read an excessive number of entries beyond the chunk boundary, causing prolonged I/O or EOF-driven denial of service.

- Wrong endianness format string for CS64Chunk (data corruption, potential memory misuse in converter)
  - Vulnerable lines:
    - #define CS64ChunkFormat ""4M""
    - WriteRiffHeader: WavpackNativeToLittleEndian(&cs64_chunk, CS64ChunkFormat);
  - Reason:
    - The expected spec is “4D” (4-byte ID + 64-bit value). Using “4M” is invalid/mismatched and can cause incorrect serialization of cs64_chunk (corrupt output). Depending on the converter’s implementation, it could also read/write past intended field sizes.

- Truncation of 64-bit sizes when writing non-RF64 headers (malformed output)
  - Vulnerable lines:
    - WriteRiffHeader: riffhdr.ckSize = (uint32_t) total_riff_bytes; datahdr.ckSize = (uint32_t) total_data_bytes; (in the non-rf64 branch)
  - Reason:
    - do_rf64 is selected based on data size only. total_riff_bytes can exceed 32 bits even when data does not; casting truncates, generating invalid RIFF headers for consumers.

- 32-bit arithmetic overflow in metadata calculation (incorrect header fields)
  - Vulnerable lines:
    - WriteRiffHeader: wavhdr.BytesPerSecond = sample_rate * num_channels * bytes_per_sample;
  - Reason:
    - Performed in 32-bit int; large values overflow, producing incorrect BytesPerSecond.

- Potential 64-bit overflow in size math (logic/format errors)
  - Vulnerable lines:
    - WriteRiffHeader: total_data_bytes = total_samples * bytes_per_sample * num_channels;
    - WriteRiffHeader: total_riff_bytes accumulation using total_data_bytes and optional chunks
  - Reason:
    - Extreme/unvalidated total_samples can overflow int64_t, yielding incorrect sizes and malformed headers.

- Memory exhaustion risk on unknown chunks (DoS)
  - Vulnerable lines:
    - ParseRiffHeaderConfig: char* buff = malloc(bytes_to_copy); with bytes_to_copy derived directly from untrusted chunk_header.ckSize
  - Reason:
    - No upper bound on allocation for unknown chunks; a crafted ckSize can trigger large allocations and exhaust memory.

3. If NO, please tell me the reason:
N/A

4. If you are not sure, please tell me the reason:
N/A
","CWE: CWE-787
CVE: CVE-2018-10539

An issue was discovered in WavPack 5.1.0 and earlier for DSDiff input. Out-of-bounds writes can occur because ParseDsdiffHeaderConfig in dsdiff.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation.
",4.0,1517.0,7.0,0.8496978282928467
127_chgdbmailusers.c,"1. YES
2. - OS Command Injection (CWE-78): lines 14–16, 21 — argv is concatenated into a command string with strcat and executed via libc.system, allowing shell metacharacter injection.
   - Buffer Overflow (CWE-120/787): lines 11–12, 15–16 — fixed 255-byte buffer and unbounded strcat/memmove enable overflow with long/many args.
   - Unsafe Privilege Management (CWE-250/266): lines 5, 20 — setuid(0) runs the constructed command as root; Python setuid usage is unsafe and magnifies any injection.
   - Unsafe C API use via ctypes (CWE-242/676): lines 8, 15–16, 21 — no argtypes/restype set and passing byref(cmnd) to system (expects char*) risks undefined behavior/DoS.

","CWE: CWE-74
CVE: CVE-2015-2180

The DBMail driver in the Password plugin in Roundcube before 1.1.0 allows remote attackers to execute arbitrary commands via shell metacharacters in the password.
",2.0,799.0,7.0,1.1484289169311523
