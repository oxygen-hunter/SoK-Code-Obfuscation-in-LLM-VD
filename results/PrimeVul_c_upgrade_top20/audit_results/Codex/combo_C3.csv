file_name,audit_report,input_token_num,output_token_num,inference_time
3_fgetwln.c,"1. YES  
2. - Out-of-bounds read (`code.c:18`): `vm_init` copies 512 integers from `program` without checking the actual length; when the caller provides a shorter array (e.g., `code.c:83`), the loop reads past the allocation, risking information disclosure or crashes.  
   - Stack overflow/underflow (`code.c:23`, `code.c:26`, `code.c:35`, `code.c:38`, `code.c:51`): `vm_push` and `vm_pop` never validate `sp`, so crafted bytecode can push past `VM_STACK_SIZE` or pop an empty stack, corrupting adjacent memory.  
   - Unbounded program counter (`code.c:30`, `code.c:48`, `code.c:52`): `vm_run` increments and reassigns `pc` without range checks; `OP_JMP`/`OP_JZ` can drive `pc` outside `vm->program`, enabling uncontrolled instruction fetches.  
   - Arbitrary write via `OP_STORE` (`code.c:61`): The destination index and value come from attacker-controlled bytecode with no bounds validation, allowing writes beyond `vm->program` and corrupting memory.  
   - Pointer truncation/type confusion (`code.c:83`): Casting `&fb->len` to `int` truncates the pointer on 64-bit builds; the VM later treats this truncated value as an array index, leading to undefined behaviour and likely memory corruption when `OP_STORE` executes.  
   - Heap buffer overflow (`code.c:88`, `code.c:101`): The growth check uses `wused > fb->len` instead of `>=`; when `wused == fb->len`, the write at `fb->wbuf[wused++]` overruns the allocation by one wide character.  
3. N/A  
4. N/A
",1,1,63.58643126487732
32_aac_parser.c,"1. YES  
2. - Stack buffer overflow/underflow — `code.c:25` and `code.c:29`. `vm_push` increments `sp` and writes to `stack` without checking `sp < 256`; `vm_pop` decrements without checking `sp >= 0`. Attackers (or malformed bytecode) can drive `sp` past the fixed 256-entry array, corrupting adjacent memory or reading uninitialized data.  
   - Unchecked operand fetch — `code.c:35-77`. Every operand access `vm->program[vm->pc++]` occurs without first ensuring `pc < program_size`, so crafted bytecode can make `pc` equal to `program_size` and trigger out-of-bounds reads from `program`.  
   - Out-of-bounds stack access via LOAD/STORE — `code.c:64-71`. The VM trusts the operand as an index and indexes `vm->stack[addr]` without range checks, enabling arbitrary read/write past the 256-entry stack buffer.  
   - Unbounded control transfers — `code.c:54-80`. `JMP`, `CALL`, and `RET` set `pc` to values pulled from untrusted bytecode / stack without confirming they remain inside `0..program_size`, allowing the VM to continue executing from arbitrary memory and compounding the out-of-bounds read/write issues.
",1,1,33.71566700935364
33_print-rt6.c,"1. YES  
2. - Stack-based buffer overflow (`execute` at lines 24,47): `vm->stack[++vm->sp] = …` grows the stack pointer without checking `sp < STACK_SIZE`, so a hostile program can push or load more than 256 values and overwrite adjacent memory.  
   - Stack underflow / invalid stack access (`execute` at lines 27,30-35,41,50): `POP`, `ADD`, `SUB`, `JZ`, and `STORE` all decrement or read from the stack without ensuring `sp ≥ 0`, allowing execution to read/write before the stack buffer.  
   - Out-of-bounds memory read/write (`execute` at lines 47-50): `program[vm->pc++]` is used directly as an index into `vm->memory` with no range check, so crafted bytecode can read or corrupt memory outside the `memory` array.  
   - Unchecked program counter / code fetch (`execute` at lines 21,38,42): instruction fetches and jumps trust `vm->pc` and operands from `program` without validating they stay within the program array, enabling out-of-bounds reads and undefined control flow.
",1,1,33.95795798301697
134_gdevokii.c,"1. YES
2. - Stack-based buffer overflow / underflow — lines 24-29 (`vm_push`, `vm_pop`): the stack pointer is incremented/decremented without checking `STACK_SIZE` or the empty-stack condition, so crafted bytecode can write past `stack[]` or read before it, leading to memory corruption or data disclosure.
   - Out-of-bounds memory access via unchecked program counter / operands — lines 33-71 (`vm_run`): instruction fetches, jumps, loads, stores, calls, and returns all trust attacker-controlled values from `memory[]` without clamping to `[0, MEMORY_SIZE)`, allowing bytecode to drive the interpreter to read or write outside the VM memory buffer.
   - Use of uninitialized / attacker-controlled registers — lines 14-21 & 72-77: `vm_init` never clears `vm->registers`, yet `PRINT_PAGE`/`OUTPUT_RUN` treat them as pointers and sizes, so execution dereferences uninitialized or attacker-controlled addresses, enabling arbitrary memory access, division-by-zero, or printer back-end abuse.
   - Divide-by-zero / out-of-bounds read in printer output — lines 115-133 (`okiibm_output_run`): `y_mult` and `start_graphics` come straight from `vm->registers`; without validation they can be zero (triggering `count / y_mult`) or outside 0–3 (indexing `""KLYZ""`), causing crashes or memory disclosure.
   - Out-of-bounds table lookup — lines 166-169 (`okiibm_print_page1`): `graphics_modes_9[x_dpi / 60]` assumes `x_pixels_per_inch` ≤ 240; higher or malformed values index past the 5-element table, yielding undefined behavior and potentially controllable memory reads.
",1,1,87.27739381790161
135_gdevepsc.c,"1. YES  
2. - Type: Stack-based buffer overflow/underflow; Lines: `main.c:19`, `main.c:23`; Reason: `vm_push` increments `sp` and writes to `stack` without checking `sp < STACK_SIZE`, and `vm_pop` reads/decrements without verifying `sp >= 0`, so crafted bytecode can drive `sp` out of bounds and corrupt adjacent memory.  
   - Type: Out-of-bounds instruction fetch/control flow; Lines: `main.c:28`, `main.c:49`, `main.c:53`, `main.c:61`, `main.c:64`, `main.c:69`, `main.c:74`; Reason: The interpreter never validates `pc` before reading from `program` or rewriting it via `JMP/JZ/CALL/RET`; hostile input can set `pc` beyond `PROGRAM_SIZE`, leading to out-of-bounds reads and unpredictable jumps.
",1,1,39.33324790000916
