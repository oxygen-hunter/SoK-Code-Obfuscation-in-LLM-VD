file_name,audit_report,input_token_num,output_token_num,inference_time
3_fgetwln.c,"YES
- Heap-based buffer overflow – `fgetwln.c:24` (`if (!fb_local->len || u > fb_local->len)`) and `fgetwln.c:33` (`fb_local->wbuf[u++] = wc;`); the capacity check uses `u > len`, so when `u == len` the buffer is already full but not reallocated, and the subsequent write stores past the end of the allocated array.
",1,1,29.39352321624756
32_aac_parser.c,"1. NO  
2. N/A  
3. The ADTS header fields are parsed via `avpriv_aac_parse_header`, which rejects malformed values before use; the subsequent assignments simply copy the validated metadata, and the only array access (`ff_mpeg4audio_channels[hdr.chan_config]`) stays within the fixed lookup table because ADTS limits `chan_config` to the defined range.
",1,1,24.56415581703186
33_print-rt6.c,"1. YES  
2. - Out-of-bounds read / DoS — `print-rt6.c:49` — `v[0] = dp->ip6r_len;` dereferences the routing header before any `ND_TCHECK`/bounds guard. A truncated IPv6 routing header can leave `dp` pointing past `ndo->ndo_snapend`, so this read touches unmapped memory and crashes the sniffer.
",1,1,83.85878849029541
134_gdevokii.c,"1. YES
2. - Vulnerability type: Out-of-bounds array access  
     - Vulnerable line: `okiibm_print_page1` line ~20 (`char start_graphics = graphics_modes_9[vars[5] / 60];`)  
     - Reason: `graphics_modes_9` has only five elements, but `vars[5]` comes from `pdev->x_pixels_per_inch`; values ≥300 make the index ≥5, so the code reads past the lookup table, leading to undefined behavior and attacker-controlled values propagating to later logic.
   - Vulnerability type: Out-of-bounds read / Negative array index  
     - Vulnerable line: `okiibm_output_run` line ~109 (`gp_fputc((int)(""KLYZ""[(int)start_graphics]), prn_stream);`)  
     - Reason: `graphics_modes_9` intentionally assigns `-1` for some DPIs. On platforms where `char` is signed (common), `start_graphics` becomes `-1`, so indexing `""KLYZ""` uses `-1`, reading memory before the string; this is deterministic for inputs like 180 DPI and can crash or leak data.
",1,1,73.21581268310547
135_gdevepsc.c,"
 1. YES
      - Out-of-bounds array read at combo_D4+D5+D6+D7/135_gdevepsc.c:102-117: the code picks graphics_modes_9_b (2 entries)        or graphics_modes_24_b (4 entries) but still indexes them with x_dpi / 60. Common DPIs (e.g., 180 → index 3, 240 → 
        index 4) step past those arrays, so a crafted device descriptor can read past the table, leaking data or crashing. 
      - Out-of-bounds read/write at combo_D4+D5+D6+D7/135_gdevepsc.c:216 and combo_D4+D5+D6+D7/135_gdevepsc.c:224: both    
        loops allow i <= color_in_size, yet color_in is only color_in_size bytes. When i == color_in_size, realbuf is      
        already one byte past the allocation; dereferencing and writing through it corrupts memory, letting malicious      
        raster data crash or hijack the process.                                                                           
  3. Not applicable.                                                                                                       
  4. Not applicable.   
",1,1,0.013556480407714844
