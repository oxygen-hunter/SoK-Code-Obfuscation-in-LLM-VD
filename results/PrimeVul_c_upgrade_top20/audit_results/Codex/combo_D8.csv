file_name,audit_report,input_token_num,output_token_num,inference_time
3_fgetwln.c,"1. YES  
2. - Heap-based buffer overflow — vulnerable at the lines containing `if (!fb->len || wused > fb->len)` and the subsequent `fb->wbuf[wused++] = wc;`. When `wused` equals `fb->len`, the condition `wused > fb->len` is false, so the buffer is not grown before writing. The write at index `wused` is then one past the allocated buffer, overflowing the heap buffer.
",1,1,16.77007031440735
32_aac_parser.c,"1. NO  
2. N/A  
3. The parser only reads validated ADTS header data via `avpriv_aac_parse_header`, which bounds-checks fields and limits `hdr.chan_config` to the valid table range, so the code makes no unchecked memory accesses or other unsafe operations.
",1,1,29.2546489238739
33_print-rt6.c,"YES  
- Vulnerability: Out-of-bounds read / crash risk — `rt6.c:16`, `rt6.c:18`, `rt6.c:22`  
  Reason: `dp->ip6r_len`, `dp->ip6r_type`, and `dp->ip6r_segleft` are dereferenced before any length check (e.g., `ND_TCHECK`) confirms that the captured packet actually contains those bytes. With a truncated/short packet an attacker can trigger an out-of-bounds read, leading to a crash or data disclosure.
",1,1,31.8516583442688
134_gdevokii.c,"1. YES  
2. - `Out-of-bounds read`, `okiibm_print_page1`: `char start_graphics = graphics_modes_9[x_dpi / 60];` — `x_pixels_per_inch` is unvalidated, so `x_dpi / 60` can exceed 4. The array `graphics_modes_9` has only 5 elements, so higher DPIs index past the buffer, causing undefined behaviour and potentially leaking adjacent memory.  
   - `Out-of-bounds read`, `okiibm_output_run`: `gp_fputc((int)(""KLYZ""[(int)start_graphics]), prn_stream);` — `graphics_modes_9` deliberately stores `-1`, but when reused here it becomes a negative index into the string literal. This underflows the pointer, reading arbitrary memory and emitting attacker-controlled bytes.
",1,1,19.856740474700928
135_gdevepsc.c,"
 1. YES
      - Out-of-bounds array read at combo_D8/135_gdevepsc.c:106-128: the helper gm_get_9/gm_get_24 return modes_*[idx]     
        without validating idx = x_dpi / 60. Many legal DPI values (e.g., 180 → idx 3, 360 → idx 6) exceed the 0–4 or 0–6  
        bounds of the static tables, so a malicious device descriptor can read past the arrays and crash or leak adjacent  
        memory.                                                                                                            
      - Out-of-bounds read/write at combo_D8/135_gdevepsc.c:232 and combo_D8/135_gdevepsc.c:240: both loops permit i <=    
        color_in_size, even though color_in is allocated for exactly color_in_size bytes. When i == color_in_size, realbuf 
        points one byte past the buffer and is dereferenced/written, allowing crafted raster data to corrupt heap memory or
        trigger a crash.                                                                                                   
  3. Not applicable.                                                                                                       
  4. Not applicable. 
",1,1,0.014000415802001953
