file_name,audit_report,input_token_num,output_token_num,inference_time
3_fgetwln.c,"1. YES
2. - Type: Heap buffer overflow; Vulnerable lines: 29-42; Reason: The growth check uses `wused > fb->len`, so when `wused == fb->len` the buffer is not reallocated before writing `fb->wbuf[wused++]`, causing an out-of-bounds write that can be triggered by supplying a line whose length equals the current buffer size.
",1,1,25.056422233581543
32_aac_parser.c,"1. NO  
3. The routine only reads a bounded ADTS header into a fixed-size union, relies on `avpriv_aac_parse_header` to validate header values (including channel configuration), and copies parsed fields into the caller’s context without performing unchecked pointer arithmetic or memory writes; no obvious memory-corruption or trust-boundary violations are present.
",1,1,17.215553045272827
33_print-rt6.c,"1. YES
2. - Out-of-bounds read, `print-rt6.c:17` (`len = dp->ip6r_len;`) and `print-rt6.c:20-22` (the `ND_PRINT` accesses of `dp->ip6r_len`, `dp->ip6r_type`, `dp->ip6r_segleft`). The code reads multiple fields from `dp` before any `ND_TCHECK` validates that those bytes are inside the captured buffer; a truncated packet can therefore drive the parser to read past `ndo->ndo_snapend`, leading to a crash.
",1,1,35.83330535888672
134_gdevokii.c,"YES  
- `CWE-125 Out-of-Bounds Read` – `char start_graphics = graphics_modes_9[x_dpi / 60];` (`okii...print_page1` line 23). The code trusts `pdev->x_pixels_per_inch`; any value ≥300 yields an index ≥5 and reads past `graphics_modes_9[5]`, corrupting control flow for later output.  
- `CWE-129 Improper Validation of Array Index` – `gp_fputc((int)(""KLYZ""[(int)start_graphics]), prn_stream);` (`okii...output_run` line 95). Even with “valid” DPI, `graphics_modes_9[0]` and `[3]` are `-1`; the negative index or any unchecked out-of-range value from the first bug indexes before `""KLYZ""` and reads arbitrary memory, leading to crashes or data disclosure.
",1,1,33.07466959953308
135_gdevepsc.c,"
1. YES
      - Out-of-bounds array read at combo_L2/135_gdevepsc.c:126: x_dpi / 60 indexes graphics_modes_9 or graphics_modes_24  
        without bounds checks. Standard DPI values (e.g., 180 → index 3, 240 → index 4) already exceed the valid range,    
        so a malicious printer descriptor can force the code to read past the static tables, leaking adjacent memory or    
        crashing.                                                                                                          
      - Out-of-bounds read/write at combo_L2/135_gdevepsc.c:230 and combo_L2/135_gdevepsc.c:237: the loops use i <=        
        color_in_size, but color_in only has color_in_size bytes. When i == color_in_size, the code still dereferences and 
        writes through realbuf, which now points one byte beyond the buffer, enabling crafted raster data to corrupt memory
        or trigger a crash.                                                                                                
  3. Not applicable.                                                                                                       
  4. Not applicable.  
",1,1,0.015000581741333008
