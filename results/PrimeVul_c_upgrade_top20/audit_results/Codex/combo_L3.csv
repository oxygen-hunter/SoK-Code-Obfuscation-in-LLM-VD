file_name,audit_report,input_token_num,output_token_num,inference_time
3_fgetwln.c,"1. YES
2. Heap-based buffer overflow – `fgetwln` (`code_obfuscation/fgetwln.c`:32) – The growth check `if (!fb->len || wused > fb->len)` triggers only when `wused` exceeds the buffer length; when `wused == fb->len` the loop still writes to `fb->wbuf[wused++]`, producing an off-by-one write past the allocated heap buffer.
",1,1,17.397395849227905
32_aac_parser.c,"1. NO  
2. —  
3. The snippet only wires AAC parsing helpers together. Bounds and validity checks happen inside `avpriv_aac_parse_header`, and the code here merely propagates the parsed values into the existing context structure without exposing new attack surface.
",1,1,29.088064432144165
33_print-rt6.c,"1. YES
2. - Out-of-bounds read / denial-of-service (lines 8-14 of `rt6_print`): The code dereferences `dp->ip6r_len`, `dp->ip6r_type`, and `dp->ip6r_segleft` before confirming that the capture buffer (`bp`..`ndo->ndo_snapend`) actually contains those bytes. With a truncated packet these reads occur prior to the `ND_TCHECK` guard, so the process can read past the end of the buffer and crash.
   - Out-of-bounds read / denial-of-service (lines 18-22 of `rt6_print`): The same pattern recurs for `dp0->ip6r0_reserved`—the field is evaluated as part of `ND_TCHECK` and `EXTRACT_32BITS` before any successful bounds verification, enabling the same truncated-packet crash.
",1,1,62.15700316429138
134_gdevokii.c,"1. YES
2. - Vulnerability: out-of-bounds read — Line: `char start_graphics=graphics_modes_9[x_dpi/60];` — Reason: `x_dpi/60` is used directly as the index into `graphics_modes_9[5]` with no bounds check. For common resolutions such as 300 dpi (`300/60 = 5`), the index exceeds the array (valid indices 0–4), leading to undefined behavior and potential memory disclosure or process crash.
   - Vulnerability: out-of-bounds read / undefined behavior — Line: `gp_fputc((int)(""KLYZ""[(int)start_graphics]),prn_stream);` — Reason: Several entries in `graphics_modes_9` are `-1`; when selected, `start_graphics` becomes negative, and the subsequent array access treats it as a negative index into the literal `""KLYZ""`, reading memory before the string and again triggering undefined behavior that can crash the process or leak adjacent data.
",1,1,31.133184671401978
135_gdevepsc.c,"1. YES
2. - Type: Denial of Service (division by zero); Lines: provided_code.c:63, provided_code.c:165; Reason: `bytes_per_space` derives from `x_dpi/10` and is never validated—if an attacker supplies a low `HWResolution`, `bytes_per_space` becomes 0 and the later division in `tpos=(outp-out)/bytes_per_space` triggers a crash.
   - Type: Out-of-bounds Read; Lines: provided_code.c:91; Reason: When the page width is forced to 0, `color_line_size` is 0, so `color_line_size-1` underflows to a huge `size_t` in `memcmp`, causing a massive read past the allocated buffer.
   - Type: Out-of-bounds Read / Undefined Behavior; Lines: provided_code.c:60; Reason: The lookup `(y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi/60]` assumes a narrow range of resolutions; crafted `HWResolution` values (large or negative) push the index outside the static arrays, yielding undefined behavior exploitable for crashes or data disclosure.
",1,1,82.00078058242798
