file_name,audit_report,input_token_num,output_token_num,inference_time
3_fgetwln.c,"1. YES  
2. Heap-based buffer overflow — lines 25 and 39: the resize guard uses `wused > fb->len`, so when `wused == fb->len` the buffer is not grown before `fb->wbuf[wused++] = wc;`, causing a write past the allocated bounds and enabling memory corruption.  
   Unbounded recursion / stack exhaustion — line 45: the function recurses once per character with no iterative escape, so an attacker-controlled long line can force deep recursion and crash the process (denial of service).  
3. N/A (code is vulnerable).  
4. N/A
",1,1,30.668214559555054
32_aac_parser.c,"1. NO  
3. The parser only touches fixed-size, stack-allocated buffers; `avpriv_aac_parse_header()` validates the ADTS fields (including `chan_config`) before they are used, so the array lookup stays in-bounds. All early exits simply signal parse failure without leaving invalid state, so there’s no evident memory safety or control-flow risk.
",1,1,11.868014335632324
33_print-rt6.c,"1. YES  
2. - Out-of-bounds read (rt6_print.c:17-23): `rt6_print()` dereferences `dp->ip6r_len`, `dp->ip6r_type`, and `dp->ip6r_segleft` before any `ND_TCHECK`/`ND_TTEST` has confirmed that `bp` actually contains those bytes. If an attacker feeds a truncated IPv6 routing header, these unchecked reads access memory past the captured buffer, leading to a crash/DoS in the sniffer.
",1,1,49.2487952709198
134_gdevokii.c,"YES  
- Out-of-bounds read: `graphics_modes_9[x_dpi / 60]` in `okiibm_print_page1` (around line with `start_graphics = ...`). `x_dpi` is taken from `pdev->x_pixels_per_inch` with no bounds check. Values ≥300 (or any value where `x_dpi/60 ≥ 5`) index the 5-element table past its end, producing undefined behaviour and attacker-controlled reads.  
- Out-of-bounds read: `(""KLYZ""[(int)start_graphics])` in `okiibm_output_run` (around the `gp_fputc` calls). `start_graphics` can be `-1` because `graphics_modes_9` deliberately stores `-1` for several valid DPI slots (e.g., 0, 180 dpi). Passing `-1` to the string index reads before the string buffer, again undefined behaviour that can leak or crash.

These issues stem from unvalidated DPI-derived indices; they allow crafted device settings to trigger memory-safety faults.
",1,1,22.25056624412537
135_gdevepsc.c,"
1. YES
      - Out-of-bounds array read at combo_L4+L5+L6/135_gdevepsc.c:125: x_dpi / 60 is used to index graphics_modes_9/       
        graphics_modes_24 without checking the quotient. Typical or malicious DPI values (e.g., 180 → 3, 360 → 6) exceed   
        the 0–4 or 0–6 bounds of the static tables, so an attacker-controlled printer descriptor can drive the code to read        past the arrays and crash or leak adjacent memory.
      - Out-of-bounds read/write at combo_L4+L5+L6/135_gdevepsc.c:225 and combo_L4+L5+L6/135_gdevepsc.c:232: both loops    
        allow i <= color_in_size, yet color_in is only color_in_size bytes long. When i == color_in_size, realbuf already  
        points one byte beyond the allocation and is dereferenced/written, letting crafted raster data corrupt heap memory 
        or terminate the process.                                                                                          
  3. Not applicable.                                                                                                       
  4. Not applicable.                                                                                                       
 
",1,1,0.01493382453918457
