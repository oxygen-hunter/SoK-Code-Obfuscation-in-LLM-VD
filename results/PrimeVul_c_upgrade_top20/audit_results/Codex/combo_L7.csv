file_name,audit_report,input_token_num,output_token_num,inference_time
3_fgetwln.c,"1. YES
2. - Heap-based buffer overflow (off-by-one) — `snippet.c:56-83` — The growth guard uses `wused > fb->len`, so when `wused == fb->len` the buffer is not reallocated and the inline assembly writes the next character at index `fb->len`, one element past the allocated region before `wused` is incremented. This allows overwriting adjacent heap memory.
   - Heap-based buffer overflow (incorrect element stride) — `snippet.c:73-77` — The inline assembly hard-codes an 8-byte stride `(%%rcx,%%rax,8)` when writing characters. On common platforms where `sizeof(wchar_t)` is 4 or 2 bytes, later writes run off the end of the `reallocarray`-sized buffer, overrunning heap memory soon after the loop begins.
3. N/A
4. N/A
",1,1,45.45560169219971
32_aac_parser.c,"1. NO  
3. The snippet only reads parsed AAC header metadata into trusted structures. Pointer arithmetic stays within the 8-byte union buffer, and field assignments use validated values returned by `avpriv_aac_parse_header`. No unbounded copies, unchecked indexing, or externally controlled writes appear, so no exploitable condition is evident.
",1,1,59.558690309524536
33_print-rt6.c,"1. YES  
2. - Out-of-bounds read / DoS – `rt6_print` (`len = dp->ip6r_len;`, `dp->ip6r_type`, `dp->ip6r_segleft`) – The function dereferences the attacker-controlled packet buffer before any bounds check. If the capture is truncated so that `bp` already points past `ndo->ndo_snapend`, these early reads occur before the first `ND_TCHECK`, leading to an invalid memory access and potential crash.
",1,1,87.66559791564941
134_gdevokii.c,"1. YES  
2. - Type: Out-of-bounds read — `code snippet:22` — `graphics_modes_9` has only five entries, but `x_dpi / 60` is used as the index without bounds checking; DPI values ≥300 (common for printers) yield an index ≥5, so the lookup reads past the array, leading to undefined behaviour/crash or information disclosure if an attacker can influence the device resolution.  
   - Type: Out-of-bounds read — `code snippet:114` — `start_graphics` is later used to index `""KLYZ""` without validation; when the earlier lookup returns `-1` (e.g., for 0 or 180 dpi modes), the code performs a negative index read just before the string literal, again invoking undefined behaviour that an attacker controlling `x_dpi` can trigger.
",1,1,78.04012989997864
135_gdevepsc.c,"
1. YES
      - Out-of-bounds array read at combo_L7/135_gdevepsc.c:151: the value x_dpi / 60 is used directly to index            
        graphics_modes_9 or graphics_modes_24 without checking bounds. Common or malicious DPI settings (e.g., 180 → index 
        3, 360 → index 6) exceed the fixed table sizes, so an attacker-controlled device descriptor can force the driver to        read past these arrays, leaking adjacent memory or crashing.                                                       
      - Out-of-bounds read/write at combo_L7/135_gdevepsc.c:256 and combo_L7/135_gdevepsc.c:264: both loops allow i <=     
        color_in_size, yet color_in is allocated for exactly color_in_size bytes. When i == color_in_size, realbuf points  
        one byte beyond the buffer and the code still reads and writes through it, allowing crafted raster data to corrupt 
        heap memory or trigger a crash.                                                                                    
  3. Not applicable.                                                                                                       
  4. Not applicable. 
",1,1,0.014004945755004883
