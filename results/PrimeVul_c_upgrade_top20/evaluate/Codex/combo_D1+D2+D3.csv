file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
3_fgetwln.c,"1. YES  
2. - Type: Heap-based buffer overflow; Lines: `snippet.c:32`, `snippet.c:47`; Reason: The resize guard in `fgetwln` uses `wused > fb->len` instead of `wused >= fb->len`, so when `wused` equals `fb->len` the buffer is not grown and the subsequent `fb->wbuf[wused++] = wc;` writes past the allocated memory.
","CWE: CWE-119
CVE: CVE-2016-2090

Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.
",4.0,710.0,7.0,1.217884540557861
32_aac_parser.c,"1. YES  
2. - Vulnerability: Out-of-bounds read; `aac_sync` in `aac_parser.c:22` assigns `hdr_info->channels = ff_mpeg4audio_channels[hdr.chan_config];` without validating that `hdr.chan_config` (parsed from untrusted AAC headers) is within the bounds of `ff_mpeg4audio_channels`, so a crafted header can index past the array and crash or leak memory.
","CWE: CWE-125
CVE: CVE-2016-7393

Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
",4.0,711.0,7.0,0.7523014545440674
33_print-rt6.c,"1. YES
2. - Type: Out-of-bounds read / denial of service; Location: provided_code.c:52; Reason: The return expression `dp0->ip6r0_len + ((99-96)) << (9-6)` evaluates to `(dp0->ip6r0_len + 3) << 3`, overstating the routing-header length by 16 bytes (the correct formula is `(ip6r0_len + 1) << 3`). A packet with a small `ip6r0_len` (e.g., 0, which is valid) makes the caller advance past the actual buffer and later dereference that out-of-range pointer before another bounds check, leading to attacker-controlled out-of-bounds reads and a likely crash.
3. N/A
4. N/A
","CWE: CWE-125
CVE: CVE-2017-13725

The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
",4.0,776.0,7.0,1.0009095668792725
134_gdevokii.c,"
1. YES
      - Out-of-bounds array read at combo_D1+D2+D3/134_gdevokii.c:41: start_graphics indexes graphics_modes_9 with x_dpi / 
        63 but never bounds-checks the quotient. Any printer descriptor that advertises DPI above 315 drives the index past        the 5-element table, pulling garbage from adjacent memory and risking a crash or data leak.                        
      - Divide-by-zero / zero-length buffer at combo_D1+D2+D3/134_gdevokii.c:32 and combo_D1+D2+D3/134_gdevokii.c:72: when 
        y_9pin_high is false (e.g., device with ≤72 dpi vertically), in_y_mult becomes zero. The code then allocates 0-byte        buffers and executes skip += 18 / in_y_mult, triggering a divide-by-zero exception and making subsequent buffer    
        math operate on zero-length storage—a trivial denial-of-service vector.                                            
      - Invalid format-string pointer at combo_D1+D2+D3/134_gdevokii.c:79 (and :154): gp_fprintf receives '\033' + 'J' +   
        '%c', which is a small integer, not a string pointer. When reached (skip odd or intermediate passes), this causes  
        the print routine to dereference low memory and crash, so crafted page data can reliably terminate the process.    
  3. Not applicable.                                                                                                       
  4. Not applicable. 
","CWE: CWE-120
CVE: CVE-2020-16301

A buffer overflow vulnerability in okiibm_print_page1() in devices/gdevokii.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,955.0,7.0,2.404118537902832
135_gdevepsc.c,"
1. YES
      - Out-of-bounds array read at combo_D1+D2+D3/135_gdevepsc.c:128: start_graphics indexes graphics_modes_9/            
        graphics_modes_24 with x_dpi / 60 but never bounds-checks the result. A malicious device descriptor supplying a    
        high x_pixels_per_inch drives the index past the table end, reading invalid memory and potentially crashing or     
        leaking data.                                                                                                      
      - Out-of-bounds read/write at combo_D1+D2+D3/135_gdevepsc.c:232 and combo_D1+D2+D3/135_gdevepsc.c:240: both          
        loop guards allow i to reach color_in_size, even though the buffer is only color_in_size bytes long. When i ==     
        color_in_size, the code still dereferences and writes through realbuf, pointing one byte past the allocation, so   
        hostile raster data can corrupt memory or trigger a crash.                                                         
  3. Not applicable.                                                                                                       
  4. Not applicable. 
","CWE: CWE-120
CVE: CVE-2020-16294

A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,857.0,7.0,0.9953818321228028
