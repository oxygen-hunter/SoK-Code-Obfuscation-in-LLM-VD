file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
3_fgetwln.c,"1. YES
2. - Heap-based buffer overflow (off-by-one) — `snippet.c:56-83` — The growth guard uses `wused > fb->len`, so when `wused == fb->len` the buffer is not reallocated and the inline assembly writes the next character at index `fb->len`, one element past the allocated region before `wused` is incremented. This allows overwriting adjacent heap memory.
   - Heap-based buffer overflow (incorrect element stride) — `snippet.c:73-77` — The inline assembly hard-codes an 8-byte stride `(%%rcx,%%rax,8)` when writing characters. On common platforms where `sizeof(wchar_t)` is 4 or 2 bytes, later writes run off the end of the `reallocarray`-sized buffer, overrunning heap memory soon after the loop begins.
3. N/A
4. N/A
","CWE: CWE-119
CVE: CVE-2016-2090

Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.
",4.0,804.0,7.0,1.3975775241851809
32_aac_parser.c,"1. NO  
3. The snippet only reads parsed AAC header metadata into trusted structures. Pointer arithmetic stays within the 8-byte union buffer, and field assignments use validated values returned by `avpriv_aac_parse_header`. No unbounded copies, unchecked indexing, or externally controlled writes appear, so no exploitable condition is evident.
","CWE: CWE-125
CVE: CVE-2016-7393

Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
",1.0,685.0,7.0,0.7550687789916992
33_print-rt6.c,"1. YES  
2. - Out-of-bounds read / DoS – `rt6_print` (`len = dp->ip6r_len;`, `dp->ip6r_type`, `dp->ip6r_segleft`) – The function dereferences the attacker-controlled packet buffer before any bounds check. If the capture is truncated so that `bp` already points past `ndo->ndo_snapend`, these early reads occur before the first `ND_TCHECK`, leading to an invalid memory access and potential crash.
","CWE: CWE-125
CVE: CVE-2017-13725

The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
",4.0,713.0,7.0,0.7874488830566406
134_gdevokii.c,"1. YES  
2. - Type: Out-of-bounds read — `code snippet:22` — `graphics_modes_9` has only five entries, but `x_dpi / 60` is used as the index without bounds checking; DPI values ≥300 (common for printers) yield an index ≥5, so the lookup reads past the array, leading to undefined behaviour/crash or information disclosure if an attacker can influence the device resolution.  
   - Type: Out-of-bounds read — `code snippet:114` — `start_graphics` is later used to index `""KLYZ""` without validation; when the earlier lookup returns `-1` (e.g., for 0 or 180 dpi modes), the code performs a negative index read just before the string literal, again invoking undefined behaviour that an attacker controlling `x_dpi` can trigger.
","CWE: CWE-120
CVE: CVE-2020-16301

A buffer overflow vulnerability in okiibm_print_page1() in devices/gdevokii.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",2.0,809.0,7.0,0.7833161354064941
135_gdevepsc.c,"
1. YES
      - Out-of-bounds array read at combo_L7/135_gdevepsc.c:151: the value x_dpi / 60 is used directly to index            
        graphics_modes_9 or graphics_modes_24 without checking bounds. Common or malicious DPI settings (e.g., 180 → index 
        3, 360 → index 6) exceed the fixed table sizes, so an attacker-controlled device descriptor can force the driver to        read past these arrays, leaking adjacent memory or crashing.                                                       
      - Out-of-bounds read/write at combo_L7/135_gdevepsc.c:256 and combo_L7/135_gdevepsc.c:264: both loops allow i <=     
        color_in_size, yet color_in is allocated for exactly color_in_size bytes. When i == color_in_size, realbuf points  
        one byte beyond the buffer and the code still reads and writes through it, allowing crafted raster data to corrupt 
        heap memory or trigger a crash.                                                                                    
  3. Not applicable.                                                                                                       
  4. Not applicable. 
","CWE: CWE-120
CVE: CVE-2020-16294

A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,856.0,7.0,0.8108606338500977
