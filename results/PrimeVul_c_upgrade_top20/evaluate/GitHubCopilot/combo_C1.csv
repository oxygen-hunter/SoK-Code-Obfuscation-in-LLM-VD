file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
3_fgetwln.c,"1. YES
2. - Heap-based buffer overflow: lines with ""if (!fb->len || wused > fb->len) {"" and the subsequent write ""fb->wbuf[wused++] = wc;"" — using '>' instead of '>=' allows an out-of-bounds write when wused == fb->len.
   - Race condition/thread-unsafe global state: ""static struct filewbuf fb_pool[FILEWBUF_POOL_ITEMS];"" and ""static int fb_pool_cur;"" with shared mutable state and no locking can corrupt buffers and leak data across threads/streams.
   - NULL pointer dereference: ""*lenp = wused;"" is done unconditionally; if lenp is NULL the function dereferences NULL (DoS).
   - Data integrity flaw: ""if (wused % 2 == 0 && wc == L'x') { wc = L'y'; skipIteration = 1; }"" silently modifies/drops input, potentially breaking security-sensitive parsers.
   - Potential information disclosure/misuse: returned buffer is not NUL-terminated and leftover data beyond wused is not cleared; callers using wcslen()/string ops may read stale memory.
3. N/A
4. N/A

","CWE: CWE-119
CVE: CVE-2016-2090

Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.
",4.0,863.0,7.0,1.84376072883606
32_aac_parser.c,"1. YES
2. - Type: Out-of-bounds read/Undefined Behavior; Line: hdr_info->channels = ff_mpeg4audio_channels[hdr.chan_config]; Reason: hdr.chan_config originates from parsed input and is not range-checked before indexing the channel lookup table, allowing attacker-controlled OOB access leading to crash or UB.
   - Type: Potential out-of-bounds read (pointer underflow); Line: init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8); Reason: If AAC_ADTS_HEADER_SIZE exceeds 8 (build/config change), the pointer can move before tmp.u8 buffer, causing invalid memory access; current safety relies on an assumed constant.
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2016-7393

Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
",4.0,782.0,7.0,1.2549786567687988
33_print-rt6.c,"1. YES
2. - Vulnerability: Out-of-bounds read (insufficient bounds checking)
   - Vulnerable lines: ""len = dp->ip6r_len;"" and the immediate use ""int condition = len > 0 ? 1 : 0;"" occur before any ND_TCHECK; also printing dp fields uses dp prior to confirming header size.
   - Reason: The code dereferences fields of dp (ip6r_len, etc.) before confirming that at least a full struct ip6_rthdr (4 bytes) is present in the captured buffer; if the packet is truncated, this can read past snaplen, leading to crashes or information disclosure.

","CWE: CWE-125
CVE: CVE-2017-13725

The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
",4.0,745.0,7.0,0.8056366443634033
134_gdevokii.c,"1. YES
2. Vulnerabilities:
   - Out-of-bounds array index: line 23 (start_graphics = graphics_modes_9[x_dpi / 60]) — x_dpi/60 can be ≥5 (e.g., 300 dpi → 5) or negative, indexing past graphics_modes_9[5], causing undefined behavior.
   - Out-of-bounds read via negative index: line 137 (""KLYZ""[(int)start_graphics]) — graphics_modes_9 contains -1 entries, so start_graphics can be -1; using it to index ""KLYZ"" yields a negative index and OOB read/crash.
   - Integer overflow leading to heap overflow: line 16 (in_size = line_size * (8 * in_y_mult)) uses int; large line_size can overflow, allocating too-small buffers (lines 17–18) then writing with memset/memcpy/transpose (lines 72, 81, 103) causing heap OOB writes.
   - Potential size_t underflow → OOB read: line 46 (memcmp(..., line_size - 1)) — if line_size == 0, the third argument becomes a huge size_t after underflow, reading far past in_data.
   - Integer truncation/overflow on size: line 112 (cast to int of (out_end - out)) and line 135 (xcount = count / y_mult) — large differences can truncate to int, corrupting protocol output and risking logic errors.
3. N/A
4. N/A

","CWE: CWE-120
CVE: CVE-2020-16301

A buffer overflow vulnerability in okiibm_print_page1() in devices/gdevokii.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",2.0,954.0,7.0,1.918262958526612
135_gdevepsc.c,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Out-of-bounds read/write in color separation loop
  - Vulnerable lines:
    - for (current_color = 0; i <= color_in_size && outbuf < in + in_size; outbuf++) { ... }
    - for (*outbuf = 0, j = 8; --j >= lastbits && i <= color_in_size; realbuf++, i++) { ... }
    - *outbuf = 0;
  - Reason:
    - The conditions use i <= color_in_size (off-by-one), allowing a one-past-end read of realbuf (color_in[i]) and potential write to *realbuf. After the outer loop terminates with outbuf == in + in_size, the unconditional ""*outbuf = 0;"" writes one byte past the end of the in buffer (heap overflow).

- Division by zero (crash/DoS)
  - Vulnerable lines:
    - dots_per_space = x_dpi / 10;
    - bytes_per_space = dots_per_space * y_mult;
    - tpos = (outp - out) / bytes_per_space;
  - Reason:
    - If x_dpi < 10, bytes_per_space becomes 0, leading to a division by zero when computing tpos.

- Out-of-bounds read from graphics mode lookup tables
  - Vulnerable line:
    - start_graphics = (char)((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);
  - Reason:
    - x_dpi/60 is used as an index without bounds checking. Values outside the defined ranges (indices > 4 for graphics_modes_9 or > 6 for graphics_modes_24) cause OOB reads.

- Out-of-bounds read due to size underflow in memcmp
  - Vulnerable line:
    - if (color_in[0] == 0 && !memcmp((char *)color_in, (char *)color_in + 1, color_line_size - 1)) { ... }
  - Reason:
    - When color_line_size == 0 (e.g., width == 0), the third argument becomes (size_t)-1, causing memcmp to read far past the buffer.

- Integer overflow leading to under-allocation and subsequent OOB writes
  - Vulnerable lines:
    - int line_size = (pdev->width + 7) >> 3;
    - int in_size = line_size * (8 * y_mult);
    - int out_size = ((pdev->width + 7) & -8) * y_mult;
    - allocations: gs_malloc(..., in_size + 1, ...), gs_malloc(..., out_size + 1, ...)
  - Reason:
    - pdev->width is unvalidated. The arithmetic can overflow 32-bit int, producing too-small allocations. Later transpose loops write up to out_end based on line_size/out_size assumptions, causing heap overflows.

3. If NO, please tell me the reason:
N/A

4. If you are not sure, please tell me the reason:
N/A
","CWE: CWE-120
CVE: CVE-2020-16294

A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,1288.0,7.0,0.8010339736938477
