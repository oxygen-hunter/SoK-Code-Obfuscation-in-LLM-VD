file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
3_fgetwln.c,"1. YES.
2. - Stack buffer overflow/underflow: lines “vm->stack[++vm->sp]” (vm_push) and “vm->stack[vm->sp--]” (vm_pop); reason: no bounds checks on sp allow out-of-bounds reads/writes. - Program OOB read/write and arbitrary PC control: lines “vm->program[vm->pc++]”, “vm->pc = vm->program[vm->pc];”, “if (...) vm->pc = vm->program[vm->pc]; else vm->pc++;”, “vm_push(vm, vm->program[vm->pc++]);”, and “vm->program[vm->program[vm->pc++]] = vm_pop(vm);” (vm_run); reason: no bounds checks on pc or indices allow reading/writing outside VM_PROGRAM_SIZE. - OOB read in initialization: “for (int i = 0; i < VM_PROGRAM_SIZE; i++) { vm->program[i] = program[i]; }” (vm_init); reason: copies 512 ints from a possibly smaller source (as with the local program[]), reading past its end. - Off-by-one heap overflow: “if (!fb->len || wused > fb->len) ... fb->wbuf[wused++] = wc;” (fgetwln); reason: when wused == fb->len the condition fails and write occurs at index == len; also “fb->len *= 2;” risks size_t overflow leading to undersized allocation. - Pointer truncation: “OP_PUSH, (int)&fb->len” (fgetwln’s VM program); reason: casting a pointer to int loses upper bits on 64-bit, causing undefined behavior. - Thread safety issue: static globals “fb_pool” and “fb_pool_cur”; reason: not thread-safe and can cause data races.
3. N/A.

","CWE: CWE-119
CVE: CVE-2016-2090

Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.
",4.0,1009.0,7.0,2.690993547439575
32_aac_parser.c,"1. YES
2. - Stack overflow/underflow
   - Vulnerable lines: ""vm->stack[++vm->sp] = value;"" and ""return vm->stack[vm->sp--];""
   - Reason: No bounds checks on sp; pushing past 255 or popping below -1 causes out-of-bounds write/read.
   - Out-of-bounds memory access via LOAD/STORE
   - Vulnerable lines: ""vm_push(vm, vm->stack[addr]);"" and ""vm->stack[addr] = vm_pop(vm);""
   - Reason: addr from bytecode is unchecked; arbitrary read/write beyond stack[256] corrupts adjacent VM fields (sp, pc, program, etc.).
   - Unchecked control-flow targets (pc)
   - Vulnerable lines: ""vm->pc = vm->program[vm->pc];"", ""if (vm_pop(vm) == 0) vm->pc = addr;"", ""vm->pc = addr;"", ""vm->pc = vm_pop(vm);""
   - Reason: No validation that pc/addr are within [0, program_size); negative or large pc leads to out-of-bounds program fetch and UB.
   - Stack underflow in provided bytecode path
   - Vulnerable lines: In aac_sync_bytecode(), JZ pops the only value; subsequent ""STORE"" and ""RET"" pop again, leading to underflow.
   - Reason: Execution reaches RET with sp < 0, causing vm_pop() to read stack[-1] and set pc to uncontrolled memory.
   - Integer truncation of 64-bit state into int program cell
   - Vulnerable line: ""vm->program[vm->program_size++] = av_be2ne64(state);""
   - Reason: 64-bit to int truncation; combined with ""vm->pc = vm_pop(vm);"" enables unintended large/negative pc and logic errors across platforms.
   - Out-of-bounds read on return value
   - Vulnerable line: ""return vm.stack[vm.sp];""
   - Reason: No check that sp >= 0 and sp < 256 after vm_run(); underflow leads to OOB read.
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2016-7393

Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
",4.0,1080.0,7.0,0.8780627250671387
33_print-rt6.c,"1. YES
2. Vulnerabilities:
   - Stack overflow/underflow and memory corruption: execute(): case PUSH ""vm->stack[++vm->sp] = program[vm->pc++];"", case LOAD ""vm->stack[++vm->sp] = vm->memory[program[vm->pc++]];"", case POP ""vm->sp--;"", case ADD ""vm->stack[vm->sp - 1] += vm->stack[vm->sp]; vm->sp--;"", case SUB ""vm->stack[vm->sp - 1] -= vm->stack[vm->sp]; vm->sp--;"", case JZ ""if (vm->stack[vm->sp--] == 0) ..."": no bounds checks on sp; overflows can overwrite vm->sp/memory fields, underflows read/write invalid stack.
   - Out-of-bounds instruction fetch/jump (pc out-of-range): execute(): ""int opcode = program[vm->pc++];"", case JMP ""vm->pc = program[vm->pc];"", case JZ ""... vm->pc = program[vm->pc]; else vm->pc++;"": no validation of pc or jump targets against program length; can read past program array and lead to arbitrary control flow or crash.
   - Out-of-bounds VM memory access: execute(): case LOAD/STORE use ""program[vm->pc++]"" as an address into vm->memory with no 0<=addr<MEMORY_SIZE check; allows reads/writes outside vm->memory, corrupting adjacent struct fields or heap.
   - Potential DoS: lack of HALT enforcement and unchecked jumps can create infinite loops consuming CPU.
   - Negative indices/overflow: pc, sp, and addresses are int and can become negative or overflow, leading to undefined behavior and memory corruption.
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2017-13725

The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
",2.0,991.0,7.0,0.7916402816772461
134_gdevokii.c,"1. YES
2. Vulnerabilities:
- Type: Stack overflow/underflow; Lines: vm_push, vm_pop; Reason: No bounds checks on stack_pointer before increment/decrement, enabling out-of-bounds write/read on stack[].
- Type: VM memory OOB read/write and PC hijack; Lines: vm_run switch uses vm->memory[vm->program_counter++], JMP/JZ/CALL/RET/LOAD/STORE; Reason: program_counter and memory indices taken from untrusted vm->memory without range validation, causing OOB access, arbitrary control-flow in the VM, and memory corruption within memory[].
- Type: Unsafe pointer casts / pointer truncation; Lines: PRINT_PAGE, OUTPUT_RUN cases in vm_run and setup_instructions ((int)&gs_okiibm_device), casts to (gx_device_printer*), (gp_file*), (byte*); Reason: Casting attacker-controlled int registers to pointers (and truncating pointers to int) can pass invalid/arbitrary addresses to I/O functions, leading to crashes or code execution on 64-bit.
- Type: Divide-by-zero; Lines: okiibm_output_run: int xcount = count / y_mult; Reason: y_mult is unchecked and may be 0.
- Type: OOB string indexing; Lines: okiibm_output_run: ""KLYZ""[(int)start_graphics]; Reason: start_graphics is unchecked and may be negative or >3, causing OOB read.
- Type: OOB array indexing; Lines: okiibm_print_page1: start_graphics = graphics_modes_9[x_dpi / 60]; Reason: x_dpi/60 can exceed 4 (e.g., 300dpi → 5), indexing a 5-element array out of range.
- Type: Propagated OOB via negative mode; Lines: okiibm_print_page1→okiibm_output_run; Reason: graphics_modes_9 contains -1; using it as index into ""KLYZ"" is OOB.
- Type: Integer overflow leading to undersized allocation; Lines: okiibm_print_page1: in_size = line_size * (8 * in_y_mult); Reason: multiplication not checked for overflow before gs_malloc, risking buffer overflow on later writes.
- Type: Out-of-bounds/invalid length memcmp access; Lines: okiibm_print_page1: in_data[0] and memcmp(..., line_size - 1); Reason: If line_size is 0, reads out of bounds and passes a huge size_t to memcmp.
- Type: Potential fixed-size buffer overflow; Lines: okiibm_print_page: memcpy into char init_string[16], end_string[16]; Reason: Appends without explicit bounds checks; currently safe with constants (1+3<=16) but fragile and unsafe if constants change.
- Type: Data pointer overrun on inconsistent params; Lines: okiibm_output_run loop over dp; Reason: Assumes count == xcount*y_mult and y_mult>0; malformed inputs can desynchronize and overrun.
3. N/A
4. N/A

","CWE: CWE-120
CVE: CVE-2020-16301

A buffer overflow vulnerability in okiibm_print_page1() in devices/gdevokii.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,1276.0,7.0,0.7988443374633789
135_gdevepsc.c,"1. YES.
2. Vulnerabilities: (a) Stack overflow/underflow — lines: vm_push: vm->stack[++vm->sp] = value; vm_pop: return vm->stack[vm->sp--]; reason: no bounds checks on sp allows out-of-bounds read/write; (b) Out-of-bounds program access/pc corruption — lines: int op = vm->program[vm->pc++]; OP_JMP: vm->pc = vm->program[vm->pc]; OP_JZ/CALL targets from vm->program[vm->pc++]; reason: no validation that pc/targets stay within [0, PROGRAM_SIZE), leading to OOB reads and undefined behavior; (c) OOB stack index via LOAD/STORE — lines: OP_LOAD: vm_push(vm, vm->stack[vm->program[vm->pc++]]); OP_STORE: vm->stack[vm->program[vm->pc++]] = vm_pop(vm); reason: index from untrusted bytecode is unchecked against [0, STACK_SIZE), causing memory corruption; (d) VM control-flow hijack via writable return addresses — lines: OP_CALL pushes return with vm_push(vm, vm->pc); OP_STORE can write arbitrary stack slots; OP_RET: vm->pc = vm_pop(vm); reason: untrusted bytecode can overwrite saved return addresses to redirect vm->pc; (e) Denial of service — lines: vm_run while(1) without instruction/step limits; reason: crafted bytecode can loop forever.
3. N/A; 4. N/A.

","CWE: CWE-120
CVE: CVE-2020-16294

A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,953.0,7.0,0.7946372032165527
