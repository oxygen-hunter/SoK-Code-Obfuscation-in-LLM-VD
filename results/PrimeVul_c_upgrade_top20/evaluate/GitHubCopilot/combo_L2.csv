file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
3_fgetwln.c,"1. YES.
2. Heap buffer overflow (off-by-one): at the capacity check and write lines “if (!fb->len || wused > fb->len)” and “fb->wbuf[wused++] = wc;” — when wused == fb->len the buffer isn’t grown and the write goes out of bounds; Thread-unsafe global state/race: “static struct filewbuf fb_pool[...]; static int fb_pool_cur;” and their unsynchronized mutations (e.g., “fb_pool_cur++; … fb->fp = stream; fb->wbuf = wp;”) — concurrent calls can corrupt shared memory; Unbounded allocation DoS: “if (fb->len) fb->len *= 2; … wp = reallocarray(...)” — attacker-controlled very long lines can exhaust memory; Potential NULL dereference: “*lenp = wused;” — crashes if caller passes NULL; Pool selection logic risk: “if (fb->fp != stream && fb->fp != NULL) { fb_pool_cur++; … } fb->fp = stream;” — may clobber another stream’s slot leading to incorrect buffer reuse.
3. N/A.
4. N/A.

","CWE: CWE-119
CVE: CVE-2016-2090

Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.
",4.0,861.0,7.0,1.7631092071533203
32_aac_parser.c,"1) YES.
2) Vulnerabilities: (1) Potential out-of-bounds read at ""hdr_info->channels = ff_mpeg4audio_channels[hdr.chan_config];"" because hdr.chan_config comes from untrusted input and there’s no explicit bounds check against the table length; (2) Potential NULL dereference at ""*need_next_header = 0; *new_frame_start = 1;"" and subsequent ""hdr_info->..."" assignments if any of these pointers are NULL; (3) Potential buffer over-read at ""init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);"" if avpriv_aac_parse_header reads beyond AAC_ADTS_HEADER_SIZE bits.
3) N/A.
4) N/A.

","CWE: CWE-125
CVE: CVE-2016-7393

Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
",4.0,780.0,7.0,0.7725460529327393
33_print-rt6.c,"1. YES
2. - Out-of-bounds read / DoS: len = dp->ip6r_len; and the two ND_PRINT calls using dp->ip6r_len and dp->ip6r_type occur before any bounds check; a truncated packet can make these dereferences read past ndo->ndo_snapend.
   - Out-of-bounds read / DoS: return ((dp0->ip6r0_len + 1) << 3); reads dp0->ip6r0_len without an ND_TCHECK for that field/struct size; on short input this can read beyond the captured buffer.
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2017-13725

The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
",4.0,746.0,7.0,0.7832000255584717
134_gdevokii.c,"1. YES.
2. Vulnerabilities: Out-of-bounds array access at ‘char start_graphics = graphics_modes_9[x_dpi / 60];’ and ‘gp_fputc((int)(“KLYZ”[(int)start_graphics]), …);’ because x_dpi/60 can be outside [0..4] and graphics_modes_9 contains -1 entries, leading to negative/invalid indexing and undefined behavior; Integer overflow leading to heap overflow at ‘int in_size = line_size * (8 * in_y_mult);’ (then gs_malloc, memset/memcpy/transpose use in_size) allowing undersized allocation followed by out-of-bounds reads/writes; Potential OOB read when width is zero at ‘if (in_data[0] == 0 && !memcmp((char *)in_data, (char *)in_data + 1, line_size - 1))’ because line_size==0 makes in_data[0] invalid and size_t underflow in memcmp; Denial of service via excessive memory allocation since unvalidated device geometry (line_size, DPI) can make in_size very large.

","CWE: CWE-120
CVE: CVE-2020-16301

A buffer overflow vulnerability in okiibm_print_page1() in devices/gdevokii.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,862.0,7.0,1.1273581981658936
135_gdevepsc.c,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Out-of-bounds read from graphics mode tables
  - Vulnerable lines:
    - char start_graphics = (char)((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);
  - Reason: Index x_dpi/60 is not bounds-checked against graphics_modes_9[5] / graphics_modes_24[7]. Nonstandard DPI can index past the arrays (OOB read), leading to invalid control codes downstream.

- Division by zero (crash/DoS)
  - Vulnerable lines:
    - int dots_per_space = x_dpi / 10; int bytes_per_space = dots_per_space * y_mult; tpos = (outp - out) / bytes_per_space;
  - Reason: If x_dpi < 10, bytes_per_space becomes 0 and the division computing tpos divides by zero.

- Out-of-bounds read/write in color packing (off-by-one)
  - Vulnerable lines:
    - for (current_color = 0; i <= color_in_size && outbuf < in + in_size; outbuf++) { … for (*outbuf = 0, j = 8; --j >= lastbits && i <= color_in_size; realbuf++, i++) { if (*realbuf) { … *realbuf = 0; } } }
    - *outbuf = 0;
  - Reason: Using i <= color_in_size allows i == color_in_size, dereferencing color_in[color_in_size] (OOB). After the loop, writing *outbuf when outbuf may be in + in_size writes one byte past the end (OOB write).

- Out-of-bounds read due to size underflow on blank-line check
  - Vulnerable lines:
    - if (color_in[0] == 0 && !memcmp((char *)color_in, (char *)color_in + 1, color_line_size - 1)) { … }
  - Reason: When color_line_size == 0 (e.g., zero-width), color_in[0] is OOB and memcmp length becomes (size_t)-1, causing massive over-read.

- Integer overflow → under-allocation → heap overflow
  - Vulnerable lines:
    - int line_size = (pdev->width + 7) >> 3; int in_size = line_size * (8 * y_mult); int out_size = ((pdev->width + 7) & -8) * y_mult;
    - allocations: gs_malloc(..., in_size + 1, ...), gs_malloc(..., out_size + 1, ...)
  - Reason: pdev->width and multipliers are 32-bit ints; additions/multiplications can overflow, allocating too-small buffers. Subsequent transposition/packing writes overflow these buffers.

- Negative/huge lengths passed to memset (memory corruption)
  - Vulnerable lines:
    - lcnt = 1 + gdev_prn_copy_scan_lines(...);
    - if (lcnt < 8 * y_mult) { memset(color_in + lcnt * color_line_size, 0, color_in_size - lcnt * color_line_size); if (gx_device_has_color(pdev)) memset(in + lcnt * line_size, 0, in_size - lcnt * line_size); }
  - Reason: If gdev_prn_copy_scan_lines returns negative or too large, the computed size underflows and becomes a huge size_t, corrupting memory.

- Potential OOB read in escape sequence selection
  - Vulnerable lines:
    - gp_fputc(""KLYZ""[(int)start_graphics], prn_stream);
  - Reason: If start_graphics is outside 0..3 (e.g., from prior OOB table read), indexing ""KLYZ"" is OOB, reading arbitrary memory.

- Unbounded memory usage (memory exhaustion DoS)
  - Vulnerable lines:
    - gs_malloc sizes derived directly from pdev->width/height and y_mult without upper bounds (in_size/out_size/color_in_size).
  - Reason: Large device dimensions can trigger excessive allocations.

3. If NO, please tell me the reason:
N/A

4. If you are not sure, please tell me the reason:
N/A
","CWE: CWE-120
CVE: CVE-2020-16294

A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",2.0,1532.0,7.0,1.58603835105896
