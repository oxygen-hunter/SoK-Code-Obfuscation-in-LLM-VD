file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
3_fgetwln.c,"1. YES
2. - Buffer overflow (off-by-one): lines with ""if (!fb->len || wused > fb->len)"" and the subsequent ""fb->wbuf[wused++] = wc;"" allow writing when wused == fb->len (check should be wused >= fb->len), causing out-of-bounds write. 
   - Race condition / not thread-safe: use of static globals ""static struct filewbuf fb_pool[...]; static int fb_pool_cur;"" and shared state (e.g., ""fb = &fb_pool[fb_pool_cur]; fb->fp = stream;"") without synchronization can lead to memory corruption in multi-threaded use. 
   - Potential NULL dereference: ""*lenp = wused;"" dereferences lenp without validating it is non-NULL.
3. N/A
4. N/A

","CWE: CWE-119
CVE: CVE-2016-2090

Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.
",4.0,790.0,7.0,3.261542558670044
32_aac_parser.c,"1. YES
2. - Out-of-bounds read: hdr_info->channels = ff_mpeg4audio_channels[hdr.chan_config]; no bounds check on hdr.chan_config (attacker-controlled) can index past table -> crash/info leak
   - Potential OOB read via bitreader: init_get_bits(&bits, tmp.u8 + 8 - AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE*8); uses a 7-byte stack buffer without AV_INPUT_BUFFER_PADDING_SIZE zero padding that get_bits may overread -> out-of-bounds read
   - NULL dereference: *need_next_header = 0; *new_frame_start = 1; and hdr_info->… assignments; no NULL checks for pointers -> crash if caller passes NULL
   - Uninitialized/stale outputs on parse error: if (avpriv_aac_parse_header(...) < 0) return 0; returns without setting need_next_header/new_frame_start/hdr_info -> undefined caller behavior
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2016-7393

Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
",4.0,831.0,7.0,0.9993431568145752
33_print-rt6.c,"1. YES.
2. CWE-125 Out-of-bounds Read: vulnerable at “len=dp->ip6r_len;” because it reads header fields from bp before any ND_TCHECK/size validation, so a truncated packet (bp >= ndo->ndo_snapend) can trigger invalid memory access/DoS; additionally, there’s no initial base-header bounds check (e.g., ND_TCHECK2(bp, sizeof(*dp))) before accessing ip6r_len/type, compounding the risk.

","CWE: CWE-125
CVE: CVE-2017-13725

The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
",4.0,711.0,7.0,1.0871548652648926
134_gdevokii.c,"1. YES
2. - Out-of-bounds read: start_graphics=graphics_modes_9[x_dpi/60]; if x_dpi/60 is outside 0..4 (e.g., 5 for 300 dpi), array indexed out of range. - Out-of-bounds read/UB: gp_fputc((int)(""KLYZ""[(int)start_graphics]),prn_stream); start_graphics can be -1 (e.g., when graphics_modes_9[...] returns -1 at indices 0 or 3), causing negative indexing into the string. - Integer overflow → heap overflow: int in_size=line_size*(8*in_y_mult); used for allocations and then for gdev_prn_copy_scan_lines/memset, so overflowed in_size can lead to undersized buffers and subsequent overflows.
3. N/A
4. N/A

","CWE: CWE-120
CVE: CVE-2020-16301

A buffer overflow vulnerability in okiibm_print_page1() in devices/gdevokii.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,811.0,7.0,0.8994133472442627
135_gdevepsc.c,"1. YES
2. Vulnerabilities:
   - Out-of-bounds read/write: in epsc_print_page, inner loop uses i<=color_in_size then dereferences and may write to *realbuf (for(*outbuf=0,j=8; --j>=lastbits && i<=color_in_size; realbuf++, i++) { if(*realbuf){ ... *realbuf=0; } }), so when i==color_in_size realbuf is one-past-end.
   - Out-of-bounds read via size underflow: if (color_in[0]==0 && !memcmp(color_in, color_in+1, color_line_size-1)) with no check for color_line_size>0; when 0, length becomes -1.
   - Out-of-bounds array index: start_graphics = (y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi/60]; x_dpi/60 not bounds-checked for arrays of size 7/5.
   - Integer overflow → under-allocation and potential overrun: line_size=(pdev->width+7)>>3; in_size=line_size*(8*y_mult); out_size=((pdev->width+7)&-8)*y_mult; bytes_per_space=(x_dpi/10)*y_mult; all computed in int without overflow checks.
   - Potential pointer underflow/OOB access: nextcolor=realbuf-(7-j) can point before color_in at early iterations; later used as realbuf=nextcolor and i=nextcolor-color_in.
   - Uninitialized output (info leak): epson_map_color_rgb switch over ((ushort)color ^ 7) lacks default; for unexpected color, prgb[0..2] may remain uninitialized but function returns success.
3. N/A
4. N/A

","CWE: CWE-120
CVE: CVE-2020-16294

A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,1002.0,7.0,0.94500994682312
