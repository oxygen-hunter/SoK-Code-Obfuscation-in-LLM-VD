file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
3_fgetwln.c,"1) YES
2) - Integer overflow → heap overflow — line with ""wp = ctypes.cast(reallocarray(fb.contents.wbuf, fb.contents.len * ctypes.sizeof(ctypes.c_wchar)), ...)"" and subsequent ""fb.contents.wbuf[wused] = wc"" — len is doubled in Python but cast to c_size_t may wrap; allocation smaller than len tracked, leading to out-of-bounds writes.
- Missing overflow-checked allocator — lines ""reallocarray = libc.realloc"" and its argtypes — using realloc (not reallocarray) removes nmemb×size overflow checks, enabling the above issue.
- Global unsynchronized buffer pool (race condition) — lines defining fb_pool, fb_pool_cur and updates in fgetwln — no locking; concurrent calls can corrupt pointers/lengths, causing memory corruption.
- Unbounded memory growth (DoS) — loop doubling fb.contents.len without cap — an attacker-controlled long line can exhaust memory.
- Logic bug in newline check — ""if wc == ord('\\n')"" — '\\n' is two chars; ord() would error or compare to backslash, preventing line termination and worsening DoS.
3) N/A
4) N/A

","CWE: CWE-119
CVE: CVE-2016-2090

Off-by-one vulnerability in the fgetwln function in libbsd before 0.8.2 allows attackers to have unspecified impact via unknown vectors, which trigger a heap-based buffer overflow.
",4.0,859.0,7.0,2.806205987930298
32_aac_parser.c,"1. YES
2. - Memory leak (DoS via resource exhaustion): in wrap_aac_sync, the temporaries from PyLong_FromLong are never DECREF’d after PyDict_SetItemString; vulnerable lines: PyObject* dict = PyDict_New(); and each PyDict_SetItemString(dict, ""..."", PyLong_FromLong(...)) — leaking a reference per field on every call
   - Unchecked allocation/return values (NULL deref/uncaught exceptions): return codes from PyDict_New, PyLong_FromLong, and PyDict_SetItemString are ignored; same lines as above can crash or leave exceptions uncleared on allocation failure
   - Potential out-of-bounds read: hdr_info->channels = ff_mpeg4audio_channels[hdr.chan_config]; if avpriv_aac_parse_header does not strictly bound-check chan_config, attacker-controlled headers can index past ff_mpeg4audio_channels
   - Potential pointer underflow/read out of bounds if macro changes: init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, ...) assumes AAC_ADTS_HEADER_SIZE ≤ 8; if it’s 9 (ADTS with CRC), tmp.u8+8-9 underflows
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2016-7393

Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
",4.0,878.0,7.0,0.7897565364837646
33_print-rt6.c,"1. YES
2. - Out-of-bounds read / DoS: ""len = dp->ip6r_len;"" is read before any bounds check (ND_TCHECK is invoked only afterward), so a truncated capture can cause an OOB read and crash. - Missing header-size validation: there is no ND_TCHECK2(dp, sizeof(struct ip6_rthdr)) before accessing dp->ip6r_type/len/segleft, nor ND_TCHECK2(dp0, sizeof(struct ip6_rthdr0)) before using dp0 fields; this permits reads from incomplete headers. - Potential alignment fault: direct dereferences of dp/dp0 fields from untrusted bp (e.g., dp->ip6r_type, dp0->ip6r0_len) can fault on strict-alignment architectures; prefer EXTRACT_* and ND_TCHECK2 over struct field derefs.
3. N/A
4. N/A

","CWE: CWE-125
CVE: CVE-2017-13725

The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
",4.0,799.0,7.0,0.949836015701294
134_gdevokii.c,"1. YES.
2. - Insecure shared library loading (DLL/so hijacking): ""lib = ctypes.CDLL('./printer_driver.so')"" — relative path allows malicious library preloading from the current directory.
   - Unsafe ctypes signature/usage (type confusion, potential memory corruption): argtypes use c_void_p and c_char_p while call passes ctypes.byref(...) and bytearray (""lib.okiibm_print_page1.argtypes = ... c_void_p, ..., c_char_p ..."" and the final call) — byref may pass pointer-to-pointer unexpectedly; c_char_p implies NUL-terminated text while binary control data is used.
   - Potential buffer/length mismatch: fixed 16-byte buffers with unbounded length counters (""init_string = bytearray(16) ... init_length += ...; ... return lib.okiibm_print_page1(..., init_string, init_length, end_string, end_length)"") — no check that init_length/end_length ≤ 16, so the C side may read past buffer based on provided lengths.
   - Lack of pointer validation: passing possibly invalid/untrusted pointers to native code (""ctypes.byref(gx_device_printer_pdev), ctypes.byref(gp_file_prn_stream)"") — could enable arbitrary memory access/crash if inputs are attacker-influenced.

","CWE: CWE-120
CVE: CVE-2020-16301

A buffer overflow vulnerability in okiibm_print_page1() in devices/gdevokii.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",4.0,895.0,7.0,0.7603302001953125
135_gdevepsc.c,"1. YES
2. - Unsafe dynamic library loading (DLL/SO hijacking) — line: lib = ctypes.CDLL('./epson_printer_driver.so') — reason: loading a relative-path library lets an attacker place a malicious .so in the CWD and gain code execution
   - Missing ctypes prototypes (type confusion/memory corruption) — lines: return lib.gx_default_map_rgb_color(...), return lib.gx_default_map_color_rgb(...) — reason: argtypes/restype not set, causing incorrect marshaling, stack/heap corruption, or arbitrary code execution via crafted library
   - Potential out-of-bounds and unsafe pointer arithmetic with ctypes buffers — lines (examples): ctypes.memset(color_in + lcnt * color_line_size, 0, ...), gdev_prn_copy_scan_lines(..., color_in + color_line_size, ...), uses of in_buf.raw/out_buf.raw with arithmetic and indexing in epsc_print_page — reason: manual pointer math on raw buffers with sizes derived from unvalidated pdev fields can overread/overwrite memory (DoS/RCE primitives when combined with native calls)
3. N/A
4. N/A

","CWE: CWE-120
CVE: CVE-2020-16294

A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
",2.0,864.0,7.0,0.777623176574707
