file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
16_Ap4HdlrAtom.cpp,"1. YES  
2. - Out-of-bounds read / information disclosure — `Ap4HdlrAtom.cpp:147-152`: when `AP4_FULL_ATOM_HEADER_SIZE+20+name_size > m_Size32`, the fallback calculation `name_size = (AP4_UI08)(m_Size32-AP4_FULL_ATOM_HEADER_SIZE+20)` incorrectly adds 20 instead of subtracting it. An attacker-controlled `m_Size32` smaller than the header size makes `name_size` much larger than the actual handler-name buffer. The subsequent `stream.Write(m_HandlerName.GetChars(), name_size)` reads past the real string buffer, leaking adjacent memory or crashing.  
   - Denial of Service via integer underflow — `Ap4HdlrAtom.cpp:147-159`: the same bad `name_size` adjustment makes `padding = m_Size32-(AP4_FULL_ATOM_HEADER_SIZE+20+name_size)` underflow to a huge unsigned value. The `while (padding--)` loop then attempts to emit gigabytes of zero bytes, consuming CPU and I/O until the process stalls or the stream errors out, enabling a DoS with a crafted, undersized atom.
","CVE: CVE-2017-14643
CVE Description: The AP4_HdlrAtom class in Core/Ap4HdlrAtom.cpp in Bento4 version 1.5.0-617 uses an incorrect character data type, leading to a heap-based buffer over-read and application crash in AP4_BytesToUInt32BE in Core/Ap4Utils.h.
CWE: ['CWE-119', 'CWE-125']
CWE Description: 
",4.0,900.0,7.0,3.839283227920532
17_comment.cpp,"1. YES
2. - Out-of-bounds read (CWE-125) — `getLineToStop`, snippet line 33 (`while (fulltext[i] != '\n' && i<fulltext.length()) i++;`): `fulltext[i]` is evaluated before verifying `i < fulltext.length()`, so when the loop consumes a `//` comment that runs to end-of-input, `i` reaches `fulltext.length()` and the next evaluation dereferences past the buffer.
   - Out-of-bounds read (CWE-125) — `collectGroups`, snippet line 109 (`while (fulltext[i] != '\n' && i<fulltext.length() ) i++;`): identical ordering bug; reaching EOF inside a `//` comment leads to reading `fulltext[fulltext.length()]`.
   - Out-of-bounds read (CWE-125) — `getDescription`, snippet lines 74-87 (`while (fulltext[start] == ' ' || fulltext[start] == '\t')` and subsequent `while (fulltext[start] != '\n')`): these loops never check `start < fulltext.length()`, so descriptions that terminate at EOF (no trailing newline) cause dereferencing past the end of the string.
3. Not applicable (code is vulnerable).
4. Not applicable (code is vulnerable).
","CVE: CVE-2022-0497
CVE Description: A vulnerbiility was found in Openscad, where a .scad file with no trailing newline could cause an out-of-bounds read during parsing of annotations.
CWE: ['CWE-125']
CWE Description: 
",4.0,903.0,7.0,2.947683095932007
46_LineBasedFrameDecoder.cpp,"1. YES  
2. - Denial of Service (logic bug): `wangle/codec/LineBasedFrameDecoder.cpp:98` forces `searchForEndOfLine` to stop once `i == 42`, so any line whose newline appears after the 43rd byte is never recognized even when it is shorter than `maxLength_`. The decoder then keeps the buffer in `decode`, eventually triggering the over-length failure path and closing or stalling the connection. A remote peer can exploit this with modestly long lines to disrupt service repeatedly.
","CVE: CVE-2019-3563
CVE Description: Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00
CWE: ['CWE-119', 'CWE-787']
CWE Description: 
",4.0,747.0,7.0,2.720345020294189
57_TableLookUp.cpp,"1. YES  
2. - Out-of-bounds read/write — `TableLookUp.cpp:29`, `TableLookUp.cpp:35`, `TableLookUp.cpp:62`, `TableLookUp.cpp:68`: bounds check uses `>` instead of `>=` and never rejects negatives, so callers can pass `ntable`/`n` equal to `ntables` or `<0`, leading to `tables[ntable * TABLE_SIZE]` indexing past the vector (undefined behaviour, potential memory corruption).  
   - Out-of-bounds read — `TableLookUp.cpp:17`, `TableLookUp.cpp:38`, `TableLookUp.cpp:47-56`: the code relies on `assert(!table.empty())`, but in release builds assertions disappear; an empty input table then drives `table[nfilled - 1]` and similar expressions, causing an OOB read that can cascade into writes.  
   - Integer overflow / undersized allocation — `TableLookUp.cpp:14`: `ntables * TABLE_SIZE` is computed in `int`; large `ntables` (≥16384) overflow 32-bit `int`, so the vector is allocated with a much smaller size than expected and later writes walk off the buffer.
","CVE: CVE-2018-25017
CVE Description: RawSpeed (aka librawspeed) 3.1 has a heap-based buffer overflow in TableLookUp::setTable.
CWE: ['CWE-787']
CWE Description: 
",4.0,869.0,7.0,2.3354310989379883
80_helper.cpp,"
YES
                                                                                                                           
  - Symlink race / TOCTOU arbitrary file overwrite: combo_C1/80_helper.cpp:75, combo_C1/80_helper.cpp:163,                 
    combo_C1/80_helper.cpp:168-185 — testFilePath only checks the supplied path for being a symlink once, and the check    
    passes if the file does not yet exist. After prepareBenchmarkFile creates the file, an authorized but unprivileged     
    caller can delete it (directory write permissions suffice) and replace it with a symlink to any root-owned target while
    keeping the .kdiskmark.tmp name. startBenchmarkTest later validates only that the path “exists” and then launches the  
    privileged fio process, which happily follows the symlink and performs the caller-controlled read/write workload on    
    the target. This enables overwriting or corrupting arbitrary files owned by root, a high-severity local privilege-     
    escalation / DoS risk.   
","CVE: CVE-2022-40673
CVE Description: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.
CWE: ['CWE-862']
CWE Description: 
",2.0,810.0,7.0,2.2776057720184326
