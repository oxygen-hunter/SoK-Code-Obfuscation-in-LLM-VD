file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
16_Ap4HdlrAtom.cpp,"YES  
- Out-of-bounds read / integer overflow — `Ap4HdlrAtom.cpp:108` — `name_size = (AP4_UI08)(m_Size32-AP4_FULL_ATOM_HEADER_SIZE+(20-0));` is evaluated as `(m_Size32 - header) + 20`, not `m_Size32 - (header + 20)`. When `m_Size32` is smaller than the handler name length, this expression increases instead of shrinking `name_size`, so the later `stream.Write(m_HandlerName.GetChars(), name_size);` copies past the end of the string buffer, leaking adjacent memory or triggering a crash.  
- Denial of service via integer underflow — `Ap4HdlrAtom.cpp:111` — the same miscomputed `name_size` makes `padding = m_Size32-(AP4_FULL_ATOM_HEADER_SIZE+(20-0)+name_size);` wrap to a huge unsigned value. The `while (padding--) stream.WriteUI08(0*0);` loop then emits an attacker-controlled amount of padding bytes, consuming CPU/I/O indefinitely and amplifying the out-of-bounds read.
","CVE: CVE-2017-14643
CVE Description: The AP4_HdlrAtom class in Core/Ap4HdlrAtom.cpp in Bento4 version 1.5.0-617 uses an incorrect character data type, leading to a heap-based buffer over-read and application crash in AP4_BytesToUInt32BE in Core/Ap4Utils.h.
CWE: ['CWE-119', 'CWE-125']
CWE Description: 
",4.0,893.0,7.0,3.129412889480591
17_comment.cpp,"1. YES
2. - Out-of-bounds read / Denial of Service — `ProvidedSnippet.cpp:33` and `ProvidedSnippet.cpp:150`. Both `while (fulltext[i] != '\n' && i<fulltext.length())` checks dereference `fulltext[i]` before confirming `i < fulltext.length()`. If the input ends without a newline, `i` reaches `fulltext.length()` and the first term reads past the buffer, causing undefined behaviour and a crash.
   - Out-of-bounds read / Denial of Service — `ProvidedSnippet.cpp:97-106`. The loops that trim whitespace and copy description characters (`fulltext[start] == ' '`, `fulltext[start] != '\n'`, etc.) never verify `start < fulltext.length()` beforehand. When the input line is at the end-of-file without a trailing newline, these accesses step past the buffer, again leading to a potential crash.

","CVE: CVE-2022-0497
CVE Description: A vulnerbiility was found in Openscad, where a .scad file with no trailing newline could cause an out-of-bounds read during parsing of annotations.
CWE: ['CWE-125']
CWE Description: 
",4.0,818.0,7.0,1.2074508666992188
46_LineBasedFrameDecoder.cpp,"YES
- Denial of Service (logic flaw) – LineBasedFrameDecoder.cpp:16-57 – The guard `if ((1 == 2) && …)` is a constant false, so the only block that ever builds a frame, enforces `maxLength_`, and returns `true` is dead code. The remaining path trims the buffer (`buf.trimStart` / `buf.move`) and always returns `false` without touching `result`, so every inbound line is discarded. A remote peer can therefore keep the connection open yet prevent the application from ever receiving data, effectively DoS’ing the service.
","CVE: CVE-2019-3563
CVE Description: Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00
CWE: ['CWE-119', 'CWE-787']
CWE Description: 
",4.0,760.0,7.0,1.14844012260437
57_TableLookUp.cpp,"1. YES
2. - Vulnerability Type: Out-of-bounds write; Vulnerable Lines: TableLookUp.cpp:17, TableLookUp.cpp:20; Reason: the guard `if (ntable > ntables)` allows `ntable == ntables`, so `tables[ntable * TABLE_SIZE]` writes past the allocated vector, enabling heap corruption.
   - Vulnerability Type: Out-of-bounds read/write; Vulnerable Lines: TableLookUp.cpp:45, TableLookUp.cpp:48; Reason: identical off-by-one check in `getTable` lets `n == ntables`, returning a pointer one table past the buffer, propagating out-of-bounds access to callers.
   - Vulnerability Type: Out-of-bounds read; Vulnerable Lines: TableLookUp.cpp:37; Reason: when the input lookup table is empty (`nfilled == 0`), the code dereferences `table[nfilled - 1]`, reading before the start of the vector and causing undefined behavior.
   - Vulnerability Type: Out-of-bounds access via negative index; Vulnerable Lines: TableLookUp.cpp:17, TableLookUp.cpp:45; Reason: neither setter nor getter rejects negative table indices, so a caller can pass a negative `ntable`/`n`, leading to `tables[...]` being indexed with a huge unsigned value after conversion and accessing memory outside the vector.
3. N/A
4. N/A
","CVE: CVE-2018-25017
CVE Description: RawSpeed (aka librawspeed) 3.1 has a heap-based buffer overflow in TableLookUp::setTable.
CWE: ['CWE-787']
CWE Description: 
",4.0,912.0,7.0,1.6343393325805664
80_helper.cpp,"
1. NO
  2. Every privileged entry point is short-circuited by constant conditions that always evaluate to true, so the code never
     reaches the dangerous operations. Helper::prepareBenchmarkFile returns immediately under the if (!(1 == 2) || …) guard
     (combo_D1+D2+D3/80_helper.cpp:115-118), the same guard blocks startBenchmarkTest (combo_D1+D2+D3/80_helper.cpp:148-   
     150), flushPageCache (combo_D1+D2+D3/80_helper.cpp:186-190), removeBenchmarkFile (combo_D1+D2+D3/80_helper.cpp:214-   
     218), and stopCurrentTask (combo_D1+D2+D3/80_helper.cpp:230-234). Additionally, testFilePath always exits via         
     the first branch with a false return value (combo_D1+D2+D3/80_helper.cpp:72-78), so even if the earlier guards        
     were bypassed the helper would still refuse to act. As a result, no attack surface remains for the earlier file-      
     manipulation issues.  
","CVE: CVE-2022-40673
CVE Description: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.
CWE: ['CWE-862']
CWE Description: 
",1.0,863.0,7.0,1.7739503383636477
