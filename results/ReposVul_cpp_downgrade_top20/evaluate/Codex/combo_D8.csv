file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
16_Ap4HdlrAtom.cpp,"1. YES  
2. - Vulnerability type: Buffer over-read / information disclosure (`Ap4HdlrAtom.cpp:114`). The fallback assignment `name_size = (AP4_UI08)(m_Size32-AP4_FULL_ATOM_HEADER_SIZE+20);` drops the needed parentheses, so when the original check fails the new value can still exceed the string’s real length. The subsequent `stream.Write(m_HandlerName.GetChars(), name_size);` (`Ap4HdlrAtom.cpp:118`) then reads past the end of the handler-name buffer, disclosing adjacent memory and risking a crash.  
   - Vulnerability type: Integer underflow → unbounded write / DoS (`Ap4HdlrAtom.cpp:121`). Because the mistaken `name_size` remains too large, `AP4_Size padding = m_Size32-(AP4_FULL_ATOM_HEADER_SIZE+20+name_size);` underflows. The unsigned result becomes huge, so the `while (padding--) stream.WriteUI08(getZeroValue());` loop (`Ap4HdlrAtom.cpp:122`) writes an attacker-controlled amount of zero bytes, leading to excessive processing and potential hangs.
","CVE: CVE-2017-14643
CVE Description: The AP4_HdlrAtom class in Core/Ap4HdlrAtom.cpp in Bento4 version 1.5.0-617 uses an incorrect character data type, leading to a heap-based buffer over-read and application crash in AP4_BytesToUInt32BE in Core/Ap4Utils.h.
CWE: ['CWE-119', 'CWE-125']
CWE Description: 
",4.0,896.0,7.0,2.744837999343872
17_comment.cpp,"1. YES  
2. - CWE-125 Out-of-Bounds Read — `getLineToStop` (lines ~28-31): the loop `while (fulltext[i] != '\\n' && i < fulltext.length()) i++;` reads `fulltext[i]` before confirming `i < fulltext.length()`. If an attacker supplies a `fulltext` that ends with `//` and no trailing newline, `i` reaches `fulltext.length()` and the next evaluation dereferences past the buffer, leading to undefined behavior/DoS.  
   - CWE-125 Out-of-Bounds Read — `collectGroups` (lines ~89-92): identical pattern in the `//` handling loop `while (fulltext[i] != '\\n' && i < fulltext.length()) i++;`, so the same crafted input causes an out-of-bounds access during group collection.  
   - CWE-125 Out-of-Bounds Read — `getDescription` (lines ~62-69): the loop `while (fulltext[start] != '\\n')` assumes a newline terminator. When `fulltext` ends directly after the description line, `start` advances to `fulltext.size()` and the next guard evaluation dereferences beyond the string boundary, again allowing an attacker-controlled file to crash the parser.  
3. N/A  
4. N/A
","CVE: CVE-2022-0497
CVE Description: A vulnerbiility was found in Openscad, where a .scad file with no trailing newline could cause an out-of-bounds read during parsing of annotations.
CWE: ['CWE-125']
CWE Description: 
",4.0,899.0,7.0,0.8107545375823975
46_LineBasedFrameDecoder.cpp,"1. NO  
2. N/A  
3. Input processing enforces the configured `maxLength`, cursor walks are bounded by both the buffer length and that maximum, and delimiter handling only trims or splits within the validated range, so there is no apparent path to memory safety issues, injection, or denial-of-service.  
4. N/A
","CVE: CVE-2019-3563
CVE Description: Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00
CWE: ['CWE-119', 'CWE-787']
CWE Description: 
",1.0,704.0,7.0,1.2132940292358398
57_TableLookUp.cpp,"YES
- Out-of-bounds write (TableLookUp.cpp:23): `setTable` only rejects `ntable > ntables`, so callers can pass `ntable == ntables` or negative indexes; `getTablePointer(ntable)` (TableLookUp.cpp:58) then returns a pointer outside the `tables` vector and the subsequent fill loops write beyond the allocation.
- Out-of-bounds read (TableLookUp.cpp:19): the code relies on `assert(!table.empty())`, but assertions disappear in release builds; with an empty `table`, the later reads `table[nfilled - 1]` (TableLookUp.cpp:29 and TableLookUp.cpp:42) underflow to index -1, producing invalid memory reads and tainting the writes into `t`.
- Integer overflow leading to undersized allocation (TableLookUp.cpp:13): `tables.resize(getDynamicTableSize(), …)` uses the `int` result of `ntables * getTableSize()` (TableLookUp.cpp:16); large attacker-controlled `ntables` values overflow this multiplication, yielding a much smaller (even zero) allocation that is later overrun by `setTable`.
","CVE: CVE-2018-25017
CVE Description: RawSpeed (aka librawspeed) 3.1 has a heap-based buffer overflow in TableLookUp::setTable.
CWE: ['CWE-787']
CWE Description: 
",4.0,853.0,7.0,1.8615007400512693
80_helper.cpp,"1. YES
2. - Type: TOCTOU / Symbolic-link race leading to privileged file overwrite. Vulnerable lines: `data/ReposVul_cpp/original/80_helper.cpp:116`, `data/ReposVul_cpp/original/80_helper.cpp:133-142`, `data/ReposVul_cpp/original/80_helper.cpp:150`, `data/ReposVul_cpp/original/80_helper.cpp:166-183`. Reason: `testFilePath` only checks that the provided path is not currently a symlink; immediately afterward the helper stores the attacker-controlled path and launches `fio` with it as `--filename`. Because the privileged helper never reopens the file itself (nor uses `O_NOFOLLOW`) and relies on a separate `fio` process, an attacker can replace the checked path with a symlink between validation and use. `fio` will follow the symlink and create or overwrite the target as root, enabling arbitrary file/device clobbering and privilege escalation.
","CVE: CVE-2022-40673
CVE Description: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.
CWE: ['CWE-862']
CWE Description: 
",2.0,819.0,7.0,1.5027732849121094
