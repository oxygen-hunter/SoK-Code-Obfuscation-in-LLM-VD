file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
16_Ap4HdlrAtom.cpp,"1. YES
2. - Vulnerability Type: CWE-789 Uncontrolled Memory Allocation; Vulnerable Lines: `Ap4HdlrAtom.cpp:70`; Reason: `name_size` comes directly from the untrusted atom `size`, and the code allocates `new char[name_size+1]` without bounding it, so a crafted atom can request an enormous buffer and force the process into an out-of-memory crash (denial of service).
   - Vulnerability Type: CWE-252 Unchecked Return Value / CWE-457 Use of Uninitialized Memory; Vulnerable Lines: `Ap4HdlrAtom.cpp:62-75`; Reason: Every read from the attacker-controlled stream (`ReadUI32`, `Read`) ignores the return codes. On short/failed reads, the subsequent logic still trusts whatever bits remain in the stack/heap buffer (e.g., `name`), propagating uninitialized data into `m_HandlerName` and later outputs—opening both information disclosure and logic-corruption avenues.
","CVE: CVE-2017-14643
CVE Description: The AP4_HdlrAtom class in Core/Ap4HdlrAtom.cpp in Bento4 version 1.5.0-617 uses an incorrect character data type, leading to a heap-based buffer over-read and application crash in AP4_BytesToUInt32BE in Core/Ap4Utils.h.
CWE: ['CWE-119', 'CWE-125']
CWE Description: 
",2.0,864.0,7.0,2.1371686458587646
17_comment.cpp,"1. YES
2. - Out-of-bounds read (code_snippet.cpp:19 & code_snippet.cpp:113): the loops meant to skip `//` comments dereference `fulltext[i]` before checking `i < fulltext.length()`. If the source text ends without a newline after a `//` comment, `i` advances to `fulltext.length()` and the next condition read runs past the buffer, yielding undefined behaviour and a potential crash (DoS vector under untrusted input).
   - Out-of-bounds read (code_snippet.cpp:71 & code_snippet.cpp:73): `getDescription` trims whitespace and copies characters without verifying `start < fulltext.length()` in the loop conditions. When the targeted comment line is the final line and lacks a trailing newline (or is exactly `//`), the code dereferences `fulltext[start]` with `start == fulltext.length()`, again causing undefined behaviour that can be triggered by crafted input.
3. N/A (code is vulnerable).
4. N/A
","CVE: CVE-2022-0497
CVE Description: A vulnerbiility was found in Openscad, where a .scad file with no trailing newline could cause an out-of-bounds read during parsing of annotations.
CWE: ['CWE-125']
CWE Description: 
",4.0,834.0,7.0,1.3008763790130615
46_LineBasedFrameDecoder.cpp,"1. NO  
3. The decoder bounds its search by `maxLength_`, validates the delimiter before reading it, and only emits frames within that limit. All buffer operations (`split`, `trimStart`) are gated by those checks, and exception reporting uses fixed strings with sanitized length values. No memory unsafety, injection vector, or denial-of-service condition is evident in this snippet.
","CVE: CVE-2019-3563
CVE Description: Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00
CWE: ['CWE-119', 'CWE-787']
CWE Description: 
",1.0,712.0,7.0,1.358046054840088
57_TableLookUp.cpp,"1. YES
2. - CWE-787 Out-of-bounds Write — `common/TableLookUp.cpp:17`: `if (ntable > ntables)` allows `ntable == ntables`, so `tables[ntable * TABLE_SIZE]` writes past the vector, enabling heap corruption.
   - CWE-787 Out-of-bounds Write — `common/TableLookUp.cpp:43`: `if (n > ntables)` has the same off-by-one error in `getTable`, returning a pointer one table past the allocated buffer.
   - CWE-125 Out-of-bounds Read — `common/TableLookUp.cpp:13`, `common/TableLookUp.cpp:22`, `common/TableLookUp.cpp:30`: the only guard against an empty `table` is a debug-only `assert`; in release builds an empty vector makes `table[nfilled-1]` dereference memory before the buffer, leading to undefined behavior or disclosure.
3. n/a
4. n/a
","CVE: CVE-2018-25017
CVE Description: RawSpeed (aka librawspeed) 3.1 has a heap-based buffer overflow in TableLookUp::setTable.
CWE: ['CWE-787']
CWE Description: 
",4.0,814.0,7.0,1.8075788021087649
80_helper.cpp,"1. YES  
2. - TOCTOU / symbolic-link race – `helper.cpp:16` together with `helper.cpp:18` & `helper.cpp:19`: `testFilePath` only checks `QFileInfo::isSymLink()` before calling `fio`, but the file can be swapped for a symlink between the check and the `fio` invocation. An attacker with directory access can race the helper and trick the privileged `fio` process into following the symlink, letting them overwrite arbitrary root-owned files (for example by pointing `.kdiskmark.tmp` at a sensitive target).  
   - Use-after-free -> denial of service – `helper.cpp:22`: `stopCurrentTask()` deletes `m_process` but never nulls the pointer. The next DBus request that calls `stopCurrentTask()` dereferences the dangling pointer (`m_process->state()`), leading to undefined behaviour and a likely crash of the privileged helper.  
3. Not applicable (code is vulnerable).  
4. Not applicable.
","CVE: CVE-2022-40673
CVE Description: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.
CWE: ['CWE-862']
CWE Description: 
",2.0,820.0,7.0,1.7430851459503174
