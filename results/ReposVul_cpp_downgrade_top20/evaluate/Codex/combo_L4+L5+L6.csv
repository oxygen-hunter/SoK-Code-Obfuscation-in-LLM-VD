file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
16_Ap4HdlrAtom.cpp,"1. YES
2. - `Unbounded dynamic allocation / DoS` – `Ap4HdlrAtom.cpp:34-38`: The atom’s declared `size` comes from untrusted input and is used directly as `name_size` to allocate `new char[name_size+1]`. An attacker can advertise a huge size to force a multi‑gigabyte allocation; the resulting `std::bad_alloc` is unhandled and will crash the process.
   - `Unchecked stream consumption / Uninitialised data exposure` – `Ap4HdlrAtom.cpp:28-39`: Every `stream.Read*` call ignores its return status. On truncated or malicious streams the reads can fail, leaving stack/heap bytes uninitialised; those bytes are then copied into members and may later be emitted, leaking prior memory contents or triggering undefined behaviour.
   - `Unbounded recursion DoS` – `Ap4HdlrAtom.cpp:67-71`: `WritePadding` recurses once per padding byte with no depth guard. Crafted atoms (or negative padding from earlier arithmetic) can force very large padding values, quickly exhausting the stack or CPU time.
3. 
4.
","CVE: CVE-2017-14643
CVE Description: The AP4_HdlrAtom class in Core/Ap4HdlrAtom.cpp in Bento4 version 1.5.0-617 uses an incorrect character data type, leading to a heap-based buffer over-read and application crash in AP4_BytesToUInt32BE in Core/Ap4Utils.h.
CWE: ['CWE-119', 'CWE-125']
CWE Description: 
",4.0,902.0,7.0,1.855390310287476
17_comment.cpp,"1. YES
2. - Type: Out-of-bounds read / undefined behavior  
     Lines: commentparser.cpp:17  
     Reason: `getLineToStop` calls `getLineToStop(fulltext, fulltext.find(""*/"", idx) + 2, ...)` without checking for `std::string::npos`; on an unterminated block comment `find` returns `npos`, which converts to -1 and drives the next recursion to index `fulltext[-1]`, causing an out-of-bounds read.
   - Type: Out-of-bounds read / undefined behavior  
     Lines: commentparser.cpp:38  
     Reason: `getDescription` loops on `while (fulltext[start] != '\n')` without confirming `start < fulltext.size()`, so a line at EOF without a trailing newline dereferences past the buffer.
   - Type: Out-of-bounds read / undefined behavior  
     Lines: commentparser.cpp:55, commentparser.cpp:61-65  
     Reason: `collectGroups` forwards `fulltext.find('\n', idx) + 1` and `fulltext.find(""*/"", idx) + 2` into recursive calls without guarding against `npos`; missing terminators yield negative indices and subsequent dereferences of `fulltext[-1]`, and the same missing check inflates `lineNo += fulltext.find(""*/"", idx) - idx`, corrupting state.  
3. N/A  
4. N/A
","CVE: CVE-2022-0497
CVE Description: A vulnerbiility was found in Openscad, where a .scad file with no trailing newline could cause an out-of-bounds read during parsing of annotations.
CWE: ['CWE-125']
CWE Description: 
",4.0,922.0,7.0,1.3310747146606443
46_LineBasedFrameDecoder.cpp,"1. YES  
2. 
- Type: Denial of Service (infinite wait) – `LineBasedFrameDecoder.cpp:62` (`findEndOfLineRecursive`)  
  Reason: the search cursor never advances by `i`; every recursive call keeps re-reading the first byte. Any frame whose newline is not at offset 0 is never detected, so the decoder permanently reports “need more data.” An attacker can stall the pipeline with a single well‑formed line, effectively hanging the connection.  
- Type: Denial of Service (stack exhaustion) – `LineBasedFrameDecoder.cpp:59-75` (`findEndOfLineRecursive`)  
  Reason: the recursion depth scales with attacker-controlled `maxLength_`/buffer length and lacks an iterative guard. Large inputs drive recursion deep enough to overflow the stack and crash the process.
","CVE: CVE-2019-3563
CVE Description: Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00
CWE: ['CWE-119', 'CWE-787']
CWE Description: 
",4.0,808.0,7.0,1.2135584354400637
57_TableLookUp.cpp,"1. YES
2. - Out-of-bounds read/write: `common/TableLookUp.cpp:23` and `common/TableLookUp.cpp:65` only check `ntable > ntables` / `n > ntables`, so inputs where `ntable == ntables` or the index is negative slip through, letting the code take `&tables[ntable * TABLE_SIZE]` outside the allocated vector. That enables memory corruption or disclosure.
   - Out-of-bounds read: `common/TableLookUp.cpp:18` relies on `assert(!table.empty())`, which disappears in release builds; a caller supplying an empty table makes every later `table[nfilled - 1]` dereference underflow, leaking memory or crashing.
   - Denial of service (stack exhaustion): `common/TableLookUp.cpp:30-56` fill routines use self-recursing lambdas up to 65,536 deep; that recursion depth can overflow the stack on typical builds, letting an attacker crash the process with crafted input.
","CVE: CVE-2018-25017
CVE Description: RawSpeed (aka librawspeed) 3.1 has a heap-based buffer overflow in TableLookUp::setTable.
CWE: ['CWE-787']
CWE Description: 
",4.0,824.0,7.0,2.123544454574585
80_helper.cpp,"
YES
                                                                                                                           
  - Symlink race / TOCTOU arbitrary file overwrite: combo_L4+L5+L6/80_helper.cpp:70-92, combo_L4+L5+L6/80_helper.cpp:116-  
    187 — testFilePath rejects symlinks only at creation time. After prepareBenchmarkFile writes the benchmark file, an    
    authorized caller can delete it and replace it with a symlink that still ends in /.kdiskmark.tmp. startBenchmarkTest   
    later checks only that the path exists before launching privileged fio, which follows the attacker-controlled symlink  
    and performs writes on the target as root, enabling arbitrary file overwrite or corruption.
","CVE: CVE-2022-40673
CVE Description: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.
CWE: ['CWE-862']
CWE Description: 
",2.0,754.0,7.0,1.5492103099822998
