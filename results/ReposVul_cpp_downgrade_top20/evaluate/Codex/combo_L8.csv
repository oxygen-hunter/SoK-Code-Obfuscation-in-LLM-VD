file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
16_Ap4HdlrAtom.cpp,"1. YES  
2. - Buffer over-read & integer underflow — `Ap4HdlrAtom.cpp:121-130`: When clamping the handler-name length, the expression `m_Size32-AP4_FULL_ATOM_HEADER_SIZE+20` (missing parentheses) evaluates as `(m_Size32 - AP4_FULL_ATOM_HEADER_SIZE) + 20`, so for small `m_Size32` values the reassigned `name_size` can exceed both the actual string length and the atom size, causing `stream.Write` to read past `m_HandlerName` and leaking memory; the same bad value then makes `padding = m_Size32-(AP4_FULL_ATOM_HEADER_SIZE+20+name_size)` underflow, so the subsequent `while (padding--)` loop writes an enormous number of zero bytes, enabling a denial of service.
","CVE: CVE-2017-14643
CVE Description: The AP4_HdlrAtom class in Core/Ap4HdlrAtom.cpp in Bento4 version 1.5.0-617 uses an incorrect character data type, leading to a heap-based buffer over-read and application crash in AP4_BytesToUInt32BE in Core/Ap4Utils.h.
CWE: ['CWE-119', 'CWE-125']
CWE Description: 
",4.0,828.0,7.0,1.484543800354004
17_comment.cpp,"1. YES  
2. - CWE-125 Out-of-bounds Read — `comment.cpp:35` and `comment.cpp:149`: both `while (fulltext[i] != '\n' && i < fulltext.length())` evaluate `fulltext[i]` before checking the bound, so a `//` comment that runs to end-of-file makes `i == fulltext.length()` and the unchecked `fulltext[i]` access reads past the buffer.  
   - CWE-125 Out-of-bounds Read — `comment.cpp:47` and `comment.cpp:162`: the loops that scan block comments call `fulltext.compare(i, 2, ""*/"")` before confirming `i < fulltext.length()`, which triggers undefined behavior when `i` reaches the end of `fulltext` (e.g., an unterminated `/*` at EOF).  
   - CWE-190 Integer Underflow → CWE-125 Out-of-bounds Read — `comment.cpp:73`: `startText < comment.length() - 1` underflows when the extracted line is empty, so the loop still executes and later dereferences `comment[startText]`, reading outside the buffer.  
   - CWE-125 Out-of-bounds Read — `comment.cpp:98` and `comment.cpp:100`: `getDescription` advances `start` and loops on `fulltext[start]` with no bounds check; if the comment line is the last line (no trailing newline), `start` reaches `fulltext.length()` and the subsequent dereference reads past the string.  
3. Not applicable.  
4. Not applicable.
","CVE: CVE-2022-0497
CVE Description: A vulnerbiility was found in Openscad, where a .scad file with no trailing newline could cause an out-of-bounds read during parsing of annotations.
CWE: ['CWE-125']
CWE Description: 
",4.0,953.0,7.0,1.0144221782684326
46_LineBasedFrameDecoder.cpp,"YES  
- **Type** Denial of Service / Race Condition (`LineBasedFrameDecoder.cpp:45-52`) – `fail()` calls `Py_Initialize()` and `Py_Finalize()` on every oversized frame error. These CPython C-API lifecycle calls are process-global and explicitly documented as not thread-safe; invoking them concurrently from multiple decoder threads (which wangle commonly uses) can corrupt the interpreter state or crash the process. An attacker who sends many overlong lines can repeatedly hit this path and trigger the crash, producing a remote DoS.
","CVE: CVE-2019-3563
CVE Description: Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00
CWE: ['CWE-119', 'CWE-787']
CWE Description: 
",2.0,746.0,7.0,0.9837262630462646
57_TableLookUp.cpp,"YES  
- Heap buffer overflow — `TableLookUp.cpp:26` and `TableLookUp.cpp:27`: allowing `ntable == ntables` or a negative `ntable` slips past the `if (ntable > ntables)` check, so `tables[ntable * TABLE_SIZE]` indexes beyond the allocated vector. Attacker-controlled indices can corrupt adjacent heap memory.  
- Heap buffer overflow — `TableLookUp.cpp:49` and `TableLookUp.cpp:51`: identical bounds mistake on read; `ntable == ntables` or negative returns a pointer outside the vector, exposing adjacent heap contents and enabling out-of-bounds reads/writes via the caller.  
- Out-of-bounds read/write — `TableLookUp.cpp:23`, `TableLookUp.cpp:30`, `TableLookUp.cpp:43`: the empty-table guard relies on `assert`, which disappears in release builds. Supplying an empty `table` makes `nfilled` zero and `table[nfilled - 1]` underflows, dereferencing before the buffer.
","CVE: CVE-2018-25017
CVE Description: RawSpeed (aka librawspeed) 3.1 has a heap-based buffer overflow in TableLookUp::setTable.
CWE: ['CWE-787']
CWE Description: 
",4.0,833.0,7.0,0.9293088912963868
80_helper.cpp,"
1. YES
  2. Symlink race / TOCTOU arbitrary file overwrite — combo_L8/80_helper.cpp:99-120, combo_L8/80_helper.cpp:123-213.       
     testFilePath rejects symlinks only before prepareBenchmarkFile creates the file. After creation, an authorized        
     attacker can delete it and replace it with a symlink that still matches /.kdiskmark.tmp. startBenchmarkTest later     
     checks only for existence and then runs privileged fio, which follows the attacker-controlled symlink and performs    
     root-level I/O on the target, enabling arbitrary file overwrite or corruption. 
","CVE: CVE-2022-40673
CVE Description: KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.
CWE: ['CWE-862']
CWE Description: 
",2.0,739.0,7.0,0.8306348323822021
