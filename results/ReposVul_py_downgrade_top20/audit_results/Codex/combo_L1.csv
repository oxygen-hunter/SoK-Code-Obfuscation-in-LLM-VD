file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"YES  
- Type: Arbitrary module import → possible remote code execution  
  Lines: `OX3E1B4E78`, line with `OX5C1F3A96 = import_module(OXA4C2D0E4).Auth`  
  Reason: The authentication “type” string is taken straight from configuration and passed to `import_module` without validation. If an attacker can influence that setting (or the config file), they can point it at any module on the Python path that exposes an `Auth` attribute, allowing execution of attacker‑controlled code during authentication.  
- Type: Plaintext credential handling  
  Lines: `OX7A2E0B9D.__init__` branch `elif self.OX7E1A3B9C == ""plain"":`, plus `OX3D9E7C2F`  
  Reason: Selecting the `plain` htpasswd method causes passwords to be stored and compared in clear text (`return OX8B4D1A6E == OX9B8E1D5C`). Anyone with read access to the htpasswd file can recover credentials instantly, violating basic password‑storage security expectations.
",1,1,54.47878456115723
132_recursive_url_loader.py,"1. YES  
2. - Vulnerability type: Improper TLS certificate validation (CWE-295); Vulnerable line: `data/ReposVul_py/combo_L1/132_recursive_url_loader.py:148`; Reason: the async branch builds `aiohttp.ClientSession` with `aiohttp.TCPConnector(ssl=False)`, explicitly disabling HTTPS certificate verification and exposing every fetch to MITM tampering.  
   - Vulnerability type: Server-Side Request Forgery (CWE-918); Vulnerable lines: `data/ReposVul_py/combo_L1/132_recursive_url_loader.py:95` and `data/ReposVul_py/combo_L1/132_recursive_url_loader.py:156`; Reason: the loader issues `requests.get(...)` / `session.get(...)` to whatever URL is supplied (and to any redirects it follows) without host allowlisting or scheme checks, enabling an attacker who controls the base URL to pivot the crawler toward internal or otherwise sensitive services.
",1,1,72.4967360496521
133_tests.py,"
1. NO                                                                                                                    
  2. combo_L1/133_tests.py is an obfuscated Django unit-test module that only exercises existing proxy/download behavior   
     inside the test harness; it introduces no production request handling, no sensitive data exposure, and no exploitable 
     attack surface.   
",1,1,0.016002178192138672
143_binary_server_asyncio.py,"1. YES  
2. - Denial of Service (memory exhaustion): `OX7E3F0A47.data_received` around lines 39‑55 trusts the client‑supplied `body_size` without any upper bound, so an attacker can announce an enormous payload and stream data until the process runs out of memory.  
   - Denial of Service (queue flood): `OX7E3F0A47.__init__` around lines 17‑22 creates `self.OX3F7B9D1E = asyncio.Queue()` without a `maxsize`, and `data_received` (lines 46‑48) uses `put_nowait`; a fast sender can overwhelm the unbounded queue faster than `_process_received_message` drains it, leading to uncontrolled memory growth.
",1,1,65.80598282814026
165_admin.py,"1. YES  
2. - Spreadsheet formula injection — `OX1F4A2B8B` (`code.py`:8) only sanitizes when `type(value) is str`. Any string subclass (e.g. Django `SafeString`, lazy translation objects) carrying user-controlled data skips the guard, so payloads starting with `=`, `+`, `-`, or `@` remain and will execute when the exported sheet opens, enabling CSV formula injection.
",1,1,36.34597897529602
