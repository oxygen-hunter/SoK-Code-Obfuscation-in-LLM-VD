file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES
2. - Remote Code Execution – `provided_code.py:11-13`: `load()` calls `import_module(auth_type)` on a configuration-controlled string without any allow-list or sandbox; an attacker who can influence that setting can import attacker-controlled modules (or ones with malicious side effects), giving arbitrary code execution under the service account.
   - Authentication Bypass – `provided_code.py:7-13`, `provided_code.py:22-26`: selecting the `None` authentication type instantiates `NoneAuth`, whose `is_authenticated()` unconditionally returns `True`, completely disabling authentication if an attacker can force or tamper with that configuration value.
   - Plaintext Credential Storage – `provided_code.py:34-35`, `provided_code.py:58-59`: choosing the `plain` htpasswd mode stores and compares credentials in clear text; compromise of the htpasswd file immediately exposes all passwords, which is considered a high-severity weakness.
",1,1,78.96835350990295
132_recursive_url_loader.py,"YES  
- Server-Side Request Forgery (SSRF); `requests.get(url, timeout=..., headers=...)` in the recursive fetch path and `session.get(url)` in `_async_get_child_links_recursive`; any caller-supplied URL (including internal hosts such as `http://169.254.169.254`) is fetched without whitelisting or scheme/IP validation, so an attacker who controls `self.url` can coerce the loader into reaching internal services.  
- Insecure TLS configuration; `_async_get_child_links_recursive` creates the client session with `aiohttp.TCPConnector(ssl=False)`, which disables HTTPS certificate verification and allows trivial man-in-the-middle tampering of fetched documents.
",1,1,25.81534576416016
133_tests.py,"
1. NO                                                                                                                    
  2. combo_L3/133_tests.py is a Django unit-test module that just exercises existing proxy/download protections; it isn’t  
     production code and doesn’t trust user input, so it introduces no exploitable vulnerability.
",1,1,0.015004873275756836
143_binary_server_asyncio.py,"1. YES
2. - Resource Exhaustion (Memory DoS) – `binary_server.py:31-48`: `data_received` keeps concatenating incoming bytes into `_buffer` and only hands off a message once the entire body (size dictated by a client-controlled header) has arrived. A malicious client can advertise an enormous `body_size` and stream until RAM is exhausted, taking down the server.
   - Resource Exhaustion (Unbounded Queue DoS) – `binary_server.py:12,44`: `self.messages` is created with the default unbounded `asyncio.Queue`, and `put_nowait` enqueues every parsed message. A fast sender can flood the queue faster than `_process_received_message_loop` can drain it, causing unbounded memory growth and denial of service.
",1,1,57.63382005691528
165_admin.py,"1. YES  
2. - Vulnerability: `CSV/Formula Injection` — `InvenTreeResource.export_resource` (`type(val) is str` check around line 9). The guard only matches exact `str` objects; any string subclass (e.g., Django’s `SafeString` from `mark_safe`, lazy translation objects) skips the sanitization loop, so an attacker can supply a subclass instance starting with `=`, `+`, `-`, or `@` and re-enable spreadsheet formula execution when the export is opened.
",1,1,67.42848992347717
