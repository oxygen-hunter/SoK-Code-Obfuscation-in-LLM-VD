file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES  
2. - `Remote Code Execution` at `snippet.py:15`: `import_module(auth_type).Auth` lets any user-controlled `auth_type` trigger importing and running arbitrary Python modules, so an attacker who can edit configuration can execute code during authentication setup.  
   - `Authentication Bypass` at `snippet.py:30`: selecting the built-in `NoneAuth` class causes `is_authenticated` to unconditionally return `True`, so if an attacker can flip the configuration to `""None""` they disable all authentication checks.  
   - `Weak Password Storage` at `snippet.py:69`: the `""plain""` mode compares stored and provided passwords directly, meaning credentials are kept in clear text and are immediately exposed if the htpasswd file is read.  
   - `Weak Hashing Algorithm` at `snippet.py:75`: the `""sha1""` mode accepts unsalted SHA‑1 digests, which are fast to brute-force and permit offline recovery of user passwords if the htpasswd file leaks.  
3. N/A (code is vulnerable).  
4. N/A
",1,1,63.180726528167725
132_recursive_url_loader.py,"1. YES  
2. - Vulnerability: Improper TLS certificate validation (CWE-295)  
   - Location: `RecursiveUrlLoader._async_get_child_links_recursive` at `aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False), …)` (≈ lines 152-158)  
   - Reason: Passing `ssl=False` disables certificate verification for every HTTPS request made by the async crawler, allowing man-in-the-middle interception or spoofed responses.
",1,1,45.23925042152405
133_tests.py,"
 1. NO
  2. combo_L4+L5+L6/133_tests.py is strictly a Django test module that mocks and verifies proxy/download behaviour; it     
     never runs in production or trusts user-controlled input, so it exposes no exploitable attack surface.    
",1,1,0.0169985294342041
143_binary_server_asyncio.py,"1. YES
2. - Denial of Service — `binary_server.py:80`, `binary_server.py:87` — `_process_message_recursively` calls itself for every message without unwinding until a sentinel arrives, so a client that keeps the connection open and streams messages forces unbounded recursion. After ~1000 iterations this hits Python’s recursion limit, the task crashes, and message processing for that client stops, effectively allowing an attacker to kill the session.
   - Denial of Service — `binary_server.py:146`, `binary_server.py:149` — `_close_tasks_recursively` uses the same unbounded recursion pattern in a long-lived background task. Even with no attacker, this will eventually hit the recursion limit (~2.8 hours at the hard-coded 10 s loop); an attacker keeping the server busy accelerates the crash, taking down the cleanup loop for all clients.
",1,1,58.133278131484985
165_admin.py,"1. YES
2. Denial of Service — lines 12-17 (`sanitize_value`) — recursive self-call removes one character at a time; an attacker-controlled value with >~1000 leading illegal characters (e.g. `'@'*2000`) will exceed Python’s recursion limit and crash the export, allowing DoS. Denial of Service — lines 19-22 (`process_row`) — recursion over every column means a wide export (>~1000 columns) will also hit the recursion limit, letting crafted data trigger the same crash.
3. N/A
4. N/A
",1,1,38.190359115600586
