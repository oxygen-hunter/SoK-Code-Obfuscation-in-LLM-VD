file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES  
2. - `auth.py:9` – Unsafe native library load: `CDLL('./auth_lib.so')` pulls a shared object from the current working directory with no validation or restricted search path, so an attacker who can drop a crafted `auth_lib.so` alongside the program gains arbitrary code execution at import time.  
   - `auth.py:17` – Insecure dynamic module import: `import_module(auth_type)` lets a user-controlled configuration value choose which module to import; if an attacker can influence the config and place a malicious module (or reuse an unexpected one exposing `Auth`), the import executes attacker code and hands over authentication control.
",1,1,38.50140690803528
132_recursive_url_loader.py,"1. YES  
2. - Type: Insecure TLS configuration; Lines: 143-146; Reason: `aiohttp.TCPConnector(ssl=False)` disables certificate validation for every HTTPS request, enabling man-in-the-middle attacks and spoofed responses.  
   - Type: Arbitrary native code execution / DLL hijacking; Lines: 219-223; Reason: `ctypes.CDLL(os.path.abspath(""example""))` loads a library from the current working directory without validation, so an attacker who can place `example.dll` / `example.so` there can run arbitrary native code.  
3. N/A (code is vulnerable).  
4. N/A (findings are definitive).
",1,1,32.25624942779541
133_tests.py,"
1. NO
  2. combo_L8/133_tests.py is a Django unit-test module that only exercises proxy/download behaviour inside the testing    
     harness; it doesn’t run in production or process external input (the ctypes.CDLL('libc.so.6') call loads a constant   
     library without exposing any interface), so it doesn’t create an exploitable attack surface.  
",1,1,0.01700425148010254
143_binary_server_asyncio.py,"YES  
- Denial of Service (memory exhaustion) — lines 44-70 (`OPCUAProtocol.data_received` handling of `self._buffer`) — a client-controlled `header.body_size` is trusted without validation; the code keeps appending incoming bytes to `self._buffer` until that many bytes arrive, allowing an attacker to declare an enormous body size and force the server to accumulate unbounded data in memory, exhausting resources and crashing the service.
",1,1,29.56883215904236
165_admin.py,"YES  
- Insecure dynamic library loading (arbitrary code execution): `ctypes.CDLL(""gcc -shared -o remove_illegal_chars.so -fPIC remove_illegal_chars.c"")` and `ctypes.CDLL(""./remove_illegal_chars.so"")` in `export_resource`. Both calls load a shared object from the current working directory without verifying its origin or integrity. An attacker who can drop a crafted `.so` (or a file named exactly like the first string) gains code execution inside the Django process when the export runs.  
- Denial of service (unhandled `OSError`): the same `ctypes.CDLL` calls try to load libraries that will not exist on a clean system—`ctypes` treats the first string as a literal path and the second relies on a file that was never compiled. These raise `OSError`, and the exception bubbles up, so any trigger of `export_resource` will reliably fail and can be abused to keep the feature (or wider request) broken.
",1,1,68.61343598365784
