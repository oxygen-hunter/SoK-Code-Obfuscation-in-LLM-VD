file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES
2. - Arbitrary code execution via untrusted module import — line: import_module(auth_type).Auth in load_vm else-branch — reason: attacker-controlled config can import/run arbitrary module code at import time.
   - Authentication bypass — line: NoneAuth.is_authenticated returns True — reason: accepts any credentials when auth type is ""None"".
   - Weak/insecure password storage/verification — lines: _plain, _sha1, _md5apr1, _crypt, _ssha — reason: plaintext, unsalted SHA-1, MD5/apr1, legacy crypt, and SSHA (SHA-1) are deprecated/weak.
   - SSHA verification flaw — lines: in _ssha: hash_value = hash_value[:20]; salt_value = hash_value[20:] after base64 decode — reason: reassigning hash_value truncates to 20 bytes so salt becomes empty, effectively downgrading to unsalted SHA-1; also decode(""base64"") is invalid in Py3 causing DoS.
   - Timing side-channel and DoS — lines: early return on success; time.sleep(1 + random.random()) on failure — reason: observable timing difference leaks validity and 1–2s sleep per failure enables request-flood slowdown.
   - Arbitrary file read via configurable path — lines: self.filename from configuration; open(self.filename) in is_authenticated — reason: if config is attacker-controlled, can read arbitrary files (information disclosure).
   - Unsafe VM dispatch/stack ops — lines: getattr(self, f""op_{instr}"") and op_LOAD/op_STORE without bounds checks — reason: if instructions are influenced, can trigger unintended ops or IndexError DoS.
   - Pop from empty stack DoS — line: return vm.op_POP() after vm.run() already executed ""POP"" — reason: empty stack pop raises IndexError, crashing the process.
   - DoS via attacker-controlled encoding — lines: password.encode(self.configuration.get(""encoding"", ""stock"")) — reason: invalid/malicious encoding name raises LookupError and breaks auth.
3. N/A
4. N/A

",1,1,62.00455951690674
132_recursive_url_loader.py,"1. YES.
2. Vulnerabilities: Improper TLS verification (CWE-295) via aiohttp.TCPConnector(ssl=False) in _async_get_child_links_recursive, enabling MITM; SSRF (CWE-918) by requests.get(url, ...) and session.get(url) on user-controlled url and recursive crawl without private IP/scheme restrictions; Arbitrary global mutation/invocation risk (CWE-94/CWE-20) in VM via STORE: globals()[var] = value and CALL: func = globals()[inst[1]](...), allowing code execution if instructions are attacker-controlled and likely KeyError since methods aren’t in globals; DoS (CWE-400) in sync _get_child_links_recursive because visited is never updated (missing visited.add(url)), causing redundant fetches; Potential sensitive data exposure in logs (CWE-532) by logging full URLs and exception details.
3. N/A.
4. N/A.

",1,1,40.77285480499268
133_tests.py,"
1. Whether the code is vulnerable or not: YES

2. Vulnerabilities:
- Unchecked opcode dispatch (arbitrary method invocation / crash)
  - Vulnerable lines: class VM.execute: getattr(self, op)(*args)
  - Reason: op is taken directly from the instruction stream without validation against an allowed opcode set. A crafted instruction could resolve to any attribute/method name on the VM object (including dunder methods) and be invoked. Missing try/except leads to unhandled exceptions and DoS.

- Out-of-bounds instruction fetch and uncontrolled jump (DoS)
  - Vulnerable lines: VM.run: instr = instructions[self.pc]; self.pc += 1; VM.JMP/VM.JZ: self.pc = addr
  - Reason: No bounds check on pc before indexing instructions. JMP/JZ can set pc to negative or beyond the list, causing IndexError or unintended negative indexing. No validation or termination guarantees → potential infinite loops or crashes.

- Stack underflow in arithmetic/branch ops (DoS)
  - Vulnerable lines: VM.POP, VM.ADD, VM.SUB, VM.JZ (uses POP)
  - Reason: POP is called without ensuring stack is non-empty. ADD/SUB/JZ pop values blindly. With malformed instruction sequences, this raises IndexError and terminates execution.

- Missing HALT/termination check in interpreter loop (infinite loop / CPU burn)
  - Vulnerable lines: VM.run: while self.running: ...
  - Reason: If the instruction stream never triggers HALT (or an unconditional loop via JMP), the VM spins indefinitely, consuming CPU (DoS).

- Undefined/unsupported opcodes not handled (crash)
  - Vulnerable lines: VM.execute (no default case/guard)
  - Reason: Instructions like CALL_GET/CALL_EQ/CALL_NE/STORE_RESULT used later are not implemented; getattr will raise AttributeError, uncaught, causing abrupt termination.

3. If NO, please tell me the reason:
N/A

4. If you are not sure, please tell me the reason:
N/A
",1,1,0.015998363494873047
143_binary_server_asyncio.py,"1. YES
2. - Denial of Service (infinite loop/event-loop blocking): lines 74–75, 116–117, 121 — JMP uses len(self.instruction_sequence)+1 evaluated as 1, causing the VM to loop back to the first instruction; VM.run is called synchronously in the protocol factory and invoked per connection by create_server, allowing any client to hang the event loop.
   - Arbitrary callable execution (unsafe VM op): lines 55–56 — op_CALL invokes any provided function without validation; if an attacker can influence the instruction stream, this yields code execution in-process.
   - Insecure transport (plaintext): line 121 — create_server is used without SSL, exposing traffic to eavesdropping/MITM.
   - Information disclosure via verbose exception logging: lines 155–156 — logger.exception leaks full stack traces, which can reveal sensitive internal details.
   - Crash/DoS via unchecked stack operations: lines 29–35, 37–50, 52–53 — POP/ADD/SUB/LOAD/STORE/JZ access the stack without bounds checks, enabling exceptions that can terminate processing if reachable from untrusted inputs.
3. N/A
4. N/A

",1,1,65.04086971282959
165_admin.py,"1. YES
2. - CSV/Excel Formula Injection (lines 42-47, 48-61, 68): control chars are checked as literal strings ('\\t','\\r','\\n') so real tab/CR/LF pass; VM program logic never changes the value (JZ always jumps), leaving leading = + - @ (and real control chars) intact and exported.
   - Infinite loop/DoS (lines 65-66): while loop never terminates when a value starts with an illegal char because preprocess_vm returns the same string.
   - Unsafe VM operations/DoS (lines 17, 19-21, 23-25, 26-33, 30, 36-37): missing stack bounds checks and index validation (pop on empty stack, STORE to out-of-range index, arbitrary JMP) can raise exceptions or hang if ever fed unexpected programs.
3. N/A (vulnerable).
4. N/A.

",1,1,51.68291473388672
