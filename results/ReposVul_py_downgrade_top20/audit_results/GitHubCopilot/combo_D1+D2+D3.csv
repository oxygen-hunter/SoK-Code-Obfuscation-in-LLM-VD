file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES
2. - Insecure dynamic import (CWE-829/CWE-94): line 17 — untrusted configuration value import_module(auth_type).Auth enables loading attacker-controlled modules via config/PYTHONPATH
   - Authentication bypass (CWE-287): lines 29–31 — NoneAuth.is_authenticated always returns True, disabling authentication when selected
   - Plaintext password handling (CWE-522/CWE-256): lines 43–44 and 75–76 — ""plain"" mode stores/compares cleartext passwords
   - Weak hashing algorithm, no salt (CWE-327/CWE-759): lines 41–42 and 81–86 — {SHA} uses unsalted SHA‑1, easily brute-forced
   - Broken SSHA verification and weak algorithm (CWE-327/CWE-760): lines 39–40 and 88–97 — deprecated base64 decode and truncation to 20 bytes drop the salt, effectively reverting to unsalted SHA‑1
   - Timing side-channel (CWE-208): lines 112–114 — success returns immediately while failures sleep ~1–2s, allowing attackers to distinguish valid credentials and optimize guessing

",1,1,80.28600215911865
132_recursive_url_loader.py,"1. YES
2. Vulnerabilities:
   - Insecure TLS: aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False), ...) disables certificate verification, enabling MITM. Vulnerable lines: the connector construction inside _async_get_child_links_recursive. Reason: ssl=False disables TLS verification for HTTPS.
   - SSRF: Fetches attacker-controlled URLs (url parameter) and recursively follows links without scheme/host allowlisting. Vulnerable lines: requests.get(url, ...) and session.get(url) calls plus recursion over extract_sub_links. Reason: A user can force requests to internal/metadata services (e.g., 127.0.0.1, 169.254.169.254) and exfiltrate data.
   - Secret/header leakage: Forwards self.headers to arbitrary hosts. Vulnerable lines: requests.get(..., headers=self.headers) and ClientSession(..., headers=self.headers). Reason: Sensitive headers (Authorization, cookies, tokens) can be sent to untrusted domains.
   - Resource exhaustion (crawl amplification/DoS): No cap on total pages/links per depth; only depth and visited set limit revisits. Vulnerable lines: recursion over sub_links without a global limit. Reason: Malicious pages with huge link graphs can exhaust CPU/memory/network.
   - Information exposure in logs: Logs full URLs and errors. Vulnerable lines: logger.warning(...) with URL and exception. Reason: URLs may contain tokens/query secrets that end up in logs.
3. N/A
4. Line numbers aren’t provided in the snippet; references are given by code fragments where the issues occur.

",1,1,45.56744980812073
133_tests.py,"
1. Whether the code is vulnerable or not: NO

3. Reason:
- The file is a Django test module. It constructs controlled inputs, uses Django’s test client, and mocks external I/O (e.g., http_client.request, storage manager). No production logic, unsafe deserialization, command execution, or direct filesystem/network access is implemented here.
- Security-relevant behaviors (host validation, URL normalization, header handling, download paths) are exercised against mocked responses; any real vulnerabilities would reside in the application code under test, which is not included.
",1,1,0.014997482299804688
143_binary_server_asyncio.py,"1. YES.
2. Vulnerabilities: CPU DoS via infinite loop on malformed header because the buffer isn’t advanced or cleared after self.transport.close() (lines 60–63), so while self._buffer stays true and spins; Unbounded memory growth by trusting attacker-controlled header.body_size and accumulating self._buffer without any upper bound (lines 49–69, esp. 64–66, 68), plus no backpressure (no transport.pause_reading) and an unbounded asyncio.Queue (line 21) allowing memory DoS if messages arrive faster than they’re processed; Parser exceptions are swallowed and the connection remains open (lines 69–71), allowing an attacker to persistently hold resources and retrigger errors.
3. N/A.

",1,1,56.05524492263794
165_admin.py,"1. YES
2. - CSV/Formula Injection bypass
     - Vulnerable lines: illegal_start_vals = [...] and the while/ slicing lines: while (999-900)/99+0*250 < len(val) and val[(999-900)/99+0*250] in illegal_start_vals: and val = val[(999-900)/99+0*250 + (999-900)/99+0*250:]
     - Reasons: (a) (999-900)/99 evaluates to 1.0 (float) in Python 3, so val[1.0] raises TypeError, breaking sanitization; (b) it checks index 1 (second character) instead of index 0, letting leading '=', '+', '-', '@' pass; (c) uses ""\\t"", ""\\r"", ""\\n"" (literal backslash sequences) instead of actual control chars '\t', '\r', '\n', missing tab/newline-based payloads.
   - Denial of Service (DoS)
     - Vulnerable lines: same while/slicing lines using val[1.0]
     - Reason: TypeError on common strings (>1 char) can crash export, allowing an attacker to trigger failures.
3. N/A
4. N/A

",1,1,33.55440378189087
