file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1) YES; 2) Vulnerabilities: (a) Insecure dynamic import at line 17: import_module(OXA4C2D0E4).Auth — config-controlled module name enables arbitrary code execution; (b) Authentication bypass via ""None"" auth at lines 12–18 and 29–31 — always returns True; (c) Insecure password storage/verification options: ""plain"" at 66–67 (plaintext), ""sha1"" at 72–77 (unsalted SHA-1), ""ssha"" at 79–87 (salted SHA-1), ""crypt"" at 57–63 and 69–71 (legacy crypt, potentially weak) — all deprecated/weak; (d) Non-constant-time comparisons at 66–67, 70, 77, 87 — susceptible to timing attacks (use hmac.compare_digest); (e) Timing oracle/DoS at 101–103 — success returns immediately while failures sleep 1–2s, enabling response-time oracle and request amplification; 3) N/A; 4) N/A.

",1,1,60.21893835067749
132_recursive_url_loader.py,"1. YES
2. - Insecure TLS/SSL configuration (CWE-295): aiohttp.TCPConnector(ssl=False) inside async OX4F3BDE78 disables certificate verification, enabling MITM.
   - Server-Side Request Forgery (SSRF) (CWE-918): requests.get(OX4F3A3BF9, ...) and async with OX6A1E3A45.get(OX4F3A3BF9) fetch arbitrary URLs with no scheme/host/IP allowlist or redirect/IP validation, allowing access to internal services.
   - Information exposure via logs (CWE-532): OX7B4DF339.warning(f""Unable to load from {OX4F3A3BF9}...{e}..."") logs full target URLs and error details, potentially leaking sensitive endpoints or tokens.
   - Uncontrolled resource consumption (CWE-400): Recursive crawling via extract_sub_links(...) and asyncio.gather(*OX3A7B5DF9) has no breadth limits or rate limiting, enabling DoS with large link graphs.
   - Race condition/type confusion leading to ineffective locking (CWE-362): self.OX5A1D5AA7 is reassigned as recursion depth, asyncio.Lock, and headers dict (e.g., self.OX5A1D5AA7 = asyncio.Lock(); headers=self.OX5A1D5AA7; async with self.OX5A1D5AA7), causing lock misuse and potential concurrent state corruption.
   - LLM prompt injection risk: Raw HTML text is passed directly to Document(page_content=...) without sanitization, allowing embedded instructions to influence downstream LLMs.
3. N/A
4. N/A

",1,1,53.46077346801758
133_tests.py,"
1. NO

2. N/A

3. Reason: File is a suite of Django test cases (lines 35–335) exercising proxy, download, and tag behaviors. It does not implement production logic handling external input; it mocks network calls (e.g., lines 88–95, 124–131, 165–172) to validate SSRF protections, header normalization, and path cleanup. Hardcoded credentials (lines 58, 199, 231, 258, 303) occur in a controlled test context. No dynamic code execution, injection sinks, insecure cryptography, unsafe file writes, or trust boundary violations appear. Obfuscated identifiers reduce readability but do not create a security flaw.

4. N/A
",1,1,0.015001296997070312
143_binary_server_asyncio.py,"1. YES
2. - Denial of Service (unbounded memory growth): data_received uses attacker-controlled body_size without any maximum (lines with ""if len(OX8F1E7C3B) < OX5D7B9F3A.body_size: ... return"" and then buffer slice ""self.OX4B6A9E1D = self.OX4B6A9E1D[(OX5D7B9F3A.header_size + OX5D7B9F3A.body_size):]""); an attacker can advertise a huge body_size to force the server to buffer until OOM. - Denial of Service (unbounded queue): __init__ creates an unbounded asyncio.Queue() and data_received uses put_nowait(...) without backpressure; a fast sender can fill memory (lines: ""self.OX3F7B9D1E = asyncio.Queue()"" and ""self.OX3F7B9D1E.put_nowait((...))""). - Denial of Service (no read backpressure): data_received never calls transport.pause_reading()/resume_reading(); under load the server cannot throttle and will over-accumulate data. - Information disclosure: broad ""except Exception: OX7C8B61E5.exception(...)"" logs full trace, and ""Got malformed header {OX5D7B9F3A}"" logs user-controlled header; this can leak internal details to logs. - Service disruption/DoS: on fragmented/partial headers the server immediately closes the connection (lines: ""except OX6EB44E9F: ... self.OX9C8E2B1A.close(); return""), enabling trivial connection churn attacks.

",1,1,64.38556671142578
165_admin.py,"1. YES.
2. CSV/Spreadsheet Formula Injection bypass: vulnerable at the line defining OX8E3F1B2D = ['@', '=', '+', '-', '@', '\t', '\r', '\n'] and the subsequent sanitization lines OX6D7F8C9A = OX6D7F8C9A.strip() and while len(OX6D7F8C9A) > 0 and OX6D7F8C9A[0] in OX8E3F1B2D: ...; it only filters ASCII triggers and basic control chars, missing Unicode whitespace/zero‑width/RTL marks that some spreadsheet apps ignore (e.g., U+200B=SUM(1,1)), and it destructively strips instead of safely prefixing with a single quote to force text.
3. N/A; 4. N/A.

",1,1,47.72227025032044
