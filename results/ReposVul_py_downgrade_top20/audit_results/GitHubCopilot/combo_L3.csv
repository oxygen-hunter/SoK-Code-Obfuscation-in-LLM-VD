file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES.
2. Vulnerabilities: (a) Untrusted dynamic import → potential RCE if config is attacker-controlled (load(): import_module(auth_type).Auth); (b) Authentication bypass via NoneAuth (NoneAuth.is_authenticated always True); (c) Insecure password schemes: plain (no hashing), sha1 (unsalted), ssha implemented incorrectly (drops salt due to slicing bug), md5/apr1 and crypt are obsolete/weak (Auth.__init__, _plain, _sha1, _ssha, _md5apr1, _crypt); (d) Timing side-channel via non-constant-time equality and faster success vs. uniformly delayed failure (verify funcs, is_authenticated); (e) DoS risk: _ssha uses ""decode('base64')"" (Python 2-only) causing exceptions/availability issues; (f) DoS amplification via time.sleep on every failed attempt (is_authenticated).
3. N/A.
4. N/A.

",1,1,34.218425989151
132_recursive_url_loader.py,"1. YES
2. - Insecure TLS/SSL configuration (CWE-295): aiohttp.TCPConnector(ssl=False) in _async_get_child_links_recursive; disables certificate verification, enabling MITM and accepting forged certs.
   - Server-Side Request Forgery (SSRF) (CWE-918): requests.get(url, ...) and async with session.get(url) as response plus recursive traversal via extract_sub_links(...); accepts user-controlled URLs, follows redirects by default, and lacks host/IP/scheme allowlists, allowing access to internal endpoints even if prevent_outside is True (applies only to sub-links and is configurable).
   - Denial of Service via unbounded concurrency/traversal (CWE-400): sub_tasks.append(...); next_results=await asyncio.gather(*sub_tasks) and the sync for link in sub_links without caps; no limits on number of pages or concurrent tasks, so a page with many links can exhaust CPU/memory/network.
   - Potential ReDoS (CWE-400): extract_sub_links(..., pattern=self.link_regex, ...); user-supplied/unsafe regex can cause catastrophic backtracking on large inputs.
   - Information exposure through logs (CWE-532): logger.warning(f""Unable to load from {url}..."") and logger.warning(f""Unable to load {url}...""); logging full URLs/exceptions may leak secrets in query strings or credentials.
3. N/A
4. N/A

",1,1,40.91751408576965
133_tests.py,"
1. NO

2. N/A

3. Reason: The file is a Django test suite exercising proxy, download, and tag behaviors using controlled inputs and mocks. Hardcoded test credentials and external URLs are confined to test context. No user-controlled data reaches dangerous sinks (command execution, injection, insecure deserialization). Network calls are either mocked or part of validation logic for SSRF protections. No exploitable security flaws in production code are introduced by these tests.

4. N/A
",1,1,0.015000343322753906
143_binary_server_asyncio.py,"1. YES
2. - Denial of Service (memory exhaustion): data_received uses an unbounded input buffer with no max frame/body size check (self._buffer+=data; if len(buf)<header.body_size: return; self._buffer=self._buffer[(header.header_size+header.body_size):]); an attacker can advertise huge header.body_size to force arbitrary memory growth. Vulnerable lines: in data_received(...) where self._buffer is appended, body_size is trusted, and no max limits are enforced. Reason: allows unbounded accumulation of bytes in memory.
   - Denial of Service (queue growth/backpressure): unbounded per-connection queue (self.messages=asyncio.Queue()) and producer enqueues without limits (self.messages.put_nowait((header,buf))). Vulnerable lines: __init__ (self.messages=asyncio.Queue()) and data_received(...) (self.messages.put_nowait(...)). Reason: attacker can flood messages faster than the consumer loop, causing unbounded memory growth.
   - Insecure transport (missing TLS): server created without SSL/TLS (asyncio.get_running_loop().create_server(self._make_protocol,self.hostname,self.port)). Vulnerable lines: start(...). Reason: unencrypted/unauthenticated TCP allows eavesdropping and MITM on OPC UA traffic.
   - Information disclosure via verbose logging: logger.exception(...) on attacker-triggerable paths leaks stack traces to logs; f'Got malformed header {header}' may log untrusted header content. Vulnerable lines: data_received(...) logger.exception(...), _process_received_message_loop(...) logger.exception(...), data_received(...) logger.error(f'Got malformed header {header}'). Reason: detailed internal errors and untrusted data can expose implementation details if logs are accessed.

",1,1,61.15737318992615
165_admin.py,"1. YES
2. - CSV/Formula Injection bypass via improper type check — line: ""if type(val) is str:""; reason: subclasses of str (e.g., django.utils.safestring.SafeString) won’t match and thus won’t be sanitized, allowing cells starting with ""="", ""+"", ""-"", ""@"", etc. to execute in spreadsheets.
   - CSV/Formula Injection bypass via invisible Unicode/control prefixes — lines: ""val = val.strip()"" and ""while len(val) > 0 and val[0] in illegal_start_vals:""; reason: only first codepoint is checked against a small ASCII list and strip() doesn’t remove format chars like U+200B/U+FEFF, enabling an attacker to prefix an invisible char before ""="" so spreadsheet apps still interpret a formula.
   - Data integrity risk (potential business logic/security impact) — lines: ""illegal_start_vals = ['@','=','+','-','@','\t','\r','\n']"" and the while loop; reason: removing leading '-' alters legitimate negative values/identifiers, which can corrupt data and enable confused-deputy scenarios.

",1,1,38.253257513046265
