file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES
2. Insecure dynamic import/RCE — lines 12-16 (esp. 15): import_module(auth_type) loads and executes arbitrary module code from configuration; Authentication bypass — lines 27-29: NoneAuth.is_authenticated always returns True if auth_type is ""None""; Weak/obsolete password hashing — lines 75-76 (_plain), 81-86 (_sha1), 88-97 (_ssha uses SHA-1), 78-79 (_crypt), 102-103 (apr_md5_crypt): plaintext/MD5/SHA-1/crypt are fast, crackable, and not recommended for password storage; Broken SSHA verification/DoS — lines 88-97: salt is discarded (92-93) so valid SSHA entries won’t verify, effectively locking users out; Non-constant-time comparisons (timing leak) — lines 75-76, 79, 86, 97: uses == on secret-derived values enabling timing attacks; Unbounded recursion/stack exhaustion — lines 108-116: one recursive call per file line can exceed recursion limits on large htpasswd files (DoS); File descriptor leak/DoS — line 106: iter(open(self.filename)) never closes the file, leading to resource exhaustion under load.

",1,1,66.32857370376587
132_recursive_url_loader.py,"1) YES

2) Vulnerabilities:
- Type: Insecure TLS/SSL verification disabled (CWE-295)
  - Vulnerable line(s): aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False), ...)
  - Reason: Disables TLS certificate verification, enabling man-in-the-middle and spoofing attacks on HTTPS requests.
- Type: Server-Side Request Forgery (SSRF) (CWE-918)
  - Vulnerable line(s): requests.get(url, ...); async with session.get(url) as response:; recursive crawling of sub_links
  - Reason: Fetches arbitrary URLs derived from an attacker-controlled base URL without allowlisting or private IP blocking; prevent_outside only constrains to the attacker-controlled base domain and does not prevent access to internal services via redirects/DNS tricks.
- Type: Regular Expression Denial of Service (ReDoS) (CWE-400)
  - Vulnerable line(s): extract_sub_links(..., pattern=self.link_regex, ...)
  - Reason: If link_regex is attacker-supplied or derived from user input, catastrophic backtracking can hang the process.
- Type: Resource exhaustion / unbounded concurrency DoS (CWE-400)
  - Vulnerable line(s): In async path, sub_tasks.append(recursive_async_crawl(...)) followed by await asyncio.gather(*sub_tasks); in sync path, breadth-first recursion over all sub_links without cap
  - Reason: No concurrency limits or rate limiting; a page with many links can exhaust CPU/memory/file descriptors.
- Type: Information exposure through logs (CWE-532)
  - Vulnerable line(s): logger.warning(f""Unable to load from {url}... Received error {e} ..."") in both sync and async paths
  - Reason: Logs may include sensitive data embedded in URLs (tokens/credentials) and full exception text; also susceptible to log injection via control characters.

3) N/A

4) N/A

",1,1,60.73385238647461
133_tests.py,"
1. YES

2. Vulnerabilities:
- Infinite recursion / potential denial of service: Lines 75-81, 88-94, 102-108, 126-130, 256-265, 294-300, 327-341, 360-368. The helper methods (_recursive_check*, etc.) recursively call themselves with the same response when the expected status code is not met; if a non-handled code (e.g. 500) persists, this causes unbounded recursion and stack overflow.
- Hardcoded weak credentials: Lines 98, 252, 290, 323. Using username ""admin"" with password ""admin"" encourages reliance on a weak default admin credential. If such defaults migrate outside test environments they create an easy brute-force/login risk.

3. N/A

4. N/A
",1,1,0.014973163604736328
143_binary_server_asyncio.py,"1. YES
2. Vulnerabilities:
- Denial of Service (unbounded buffering): in OPCUAProtocol._process_data -> ""if len(buf) < header.body_size: return"" and later ""self._buffer = self._buffer[(header.header_size + header.body_size):]"" without any max message size check; an attacker can advertise a huge body_size to force the server to buffer arbitrarily large data and exhaust memory.
- Denial of Service (unbounded queue growth): ""self.messages = asyncio.Queue()"" and ""self.messages.put_nowait((header, buf))"" have no maxsize or backpressure; a fast sender can enqueue messages faster than they are processed, causing memory exhaustion.
- Denial of Service (stack exhaustion via recursion): in OPCUAProtocol._process_message_recursively -> it calls itself recursively after each message; sustained traffic accumulates deep call stacks leading to stack overflow/crash.
- Denial of Service (stack exhaustion via recursion): in BinaryServer._close_tasks_recursively -> awaits sleep then calls itself recursively forever; over time this grows the call stack until crash.
- Insufficient header sanity checks: ""_process_data"" only checks ""header.header_size + header.body_size <= header.header_size"" but not excessively large values; combined with the above, enables oversized length DoS.

",1,1,61.56980919837952
165_admin.py,"1. YES
2. - Type: Denial of Service (unbounded recursion). Vulnerable lines: sanitize_value recursion “return sanitize_value(val[1:])” and process_row recursion “process_row(index + 1)”. Reason: >~1000 leading illegal chars (or very wide rows) can exceed Python’s recursion limit and crash export.
   - Type: Incomplete sanitization/type-check bypass. Vulnerable line: “if type(val) is str:”. Reason: str subclasses (e.g., Django SafeString) won’t be sanitized, enabling CSV formula injection.
   - Type: Insufficient CSV injection mitigation coverage. Vulnerable lines: illegal_start_vals and sanitize_value logic. Reason: uses '\\t','\\r','\\n' (literal backslash sequences) and relies on strip(); does not robustly neutralize edge cases (e.g., zero-width control chars); OWASP recommends prefixing with a single quote to safely neutralize without data loss.
3. N/A
4. Some bypasses (e.g., zero-width characters) depend on spreadsheet behavior; exploitability may vary by client.

",1,1,46.61835956573486
