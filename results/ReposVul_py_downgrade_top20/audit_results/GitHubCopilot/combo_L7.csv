file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES
2. Vulnerabilities: (a) Authentication bypass: class NoneAuth.is_authenticated -> return True (anyone can log in); (b) Unsafe dynamic import/code execution: load(): class_ = import_module(auth_type).Auth (untrusted config can load arbitrary module); (c) Weak/broken password verification: _plain: return hash_value == password (plaintext), _sha1 uses hashlib.sha1 without salt and compares to base64 (weak/unsalted), _ssha: hash_value.replace(...).encode(""ascii"").decode(""base64""); hash_value = hash_value[:20]; salt_value = hash_value[20:] (SHA-1/SSHA weak, Python 3-incompatible decode, slicing bug drops salt), _md5apr1 uses MD5-based apr1 (weak), _crypt passes hash_value to crypt.crypt(...) (may accept legacy weak schemes); (d) Timing side-channel and DoS: is_authenticated returns immediately on success but on failure calls time.sleep(1 + random.random()) and uses == comparisons (oracle for valid creds and attacker-driven delays); (e) Unvalidated file path from config: __init__/is_authenticated open(self.filename) (arbitrary file read/DoS if config is attacker-controlled); (f) Unhandled parsing/decoding errors -> DoS: is_authenticated line.split("":"") (ValueError on extra ':'), _sha1 base64.b64decode(...) and _ssha ...decode(""base64"") (invalid data/Py3 raises) crash auth; (g) Solidity snippet logic flaw: function authenticate(...) with assembly { mstore(0x0, eq(hash, password)) } compares bytes32 password directly to stored hash (no hashing/KDF, trivially wrong auth model).
3. N/A
4. N/A

",1,1,95.87276315689088
132_recursive_url_loader.py,"1. YES

2. Vulnerabilities:
   - CWE-295 (Improper TLS/SSL Validation) — Line: aiohttp.TCPConnector(ssl=False) inside _async_get_child_links_recursive; Reason: Disables certificate verification, enabling MITM and credential/header leakage.
   - CWE-918 (Server-Side Request Forgery) — Lines: requests.get(url, ...) in _get_child_links_recursive and session.get(url) in _async_get_child_links_recursive; Reason: Fetches attacker-controlled URLs and follows redirects across hosts without an allowlist; prevent_outside only filters extracted links and can be bypassed via HTTP redirects/DNS tricks.
   - CWE-400 (Uncontrolled Resource Consumption) — Lines: sub_tasks creation and asyncio.gather(*sub_tasks) without a semaphore in _async_get_child_links_recursive; Reason: Unbounded parallel requests can exhaust network/file descriptors/CPU causing DoS.
   - CWE-532/CWE-200 (Information Exposure via Logs) — Lines: logger.warning(...) including URL and exception in both fetch paths; Reason: Logs may disclose sensitive internal URLs or error details.

3. N/A

4. N/A

",1,1,40.392728328704834
133_tests.py,"
1. NO

2. N/A

3. Reason: File is a Django test suite using controlled, hardcoded inputs and mocks. Hardcoded admin credentials are typical for tests and do not expose production secrets. No execution of untrusted input, no injection sinks, no insecure cryptography, no file or network operations beyond mocked or framework-handled calls. Assertions verify proxy and download behaviors; they do not introduce runtime vulnerabilities.

4. N/A
",1,1,0.01600027084350586
143_binary_server_asyncio.py,"✗ Find Buffer class definition
   $ Get-ChildItem -Recurse -File | Select-String -Pattern ""class Buffer\b"" -List | Select Path |
   ForEach-Object { $_.Path }
   Permission denied and could not request permission from user

1. YES
2. - Unbounded memory consumption / Denial of Service: lines 51-54, 66-74; reason: trusts client-controlled header.body_size and buffers until that size without any maximum, allowing a single client to grow _buffer arbitrarily.
   - Unbounded producer queue (no backpressure): lines 22, 73, 79-88; reason: asyncio.Queue() defaults to unlimited size and put_nowait enqueues faster than the consumer can process, enabling memory exhaustion via message flooding.
   - Unsafe native code usage (ctypes null function pointer cast): lines 158-163; reason: creates a callable to address 0 (CFUNCTYPE + cast), which if invoked will crash the process and indicates a pattern that could be weaponized if the address ever becomes attacker-influenced.
   - DoS via premature close on partial headers: lines 63-65; reason: closing the connection on NotEnoughData enables trivial connection churn and log amplification by sending fragmented headers.
3. N/A
4. N/A

",1,1,76.91493535041809
165_admin.py,"1. YES
2. - CSV Formula Injection (Improper output encoding/validation): lines defining illegal_start_vals and the loop do not actually prevent leading =, +, -, @, tabs/CR/LF from being exported (illegal_start_vals is unused, no escaping/prefixing), and val.strip() can worsen it by removing protective leading whitespace/apostrophes; vulnerable lines: illegal_start_vals = [...], for idx, val in enumerate(row):, if type(val) is str:, val = val.strip(), row[idx] = val. 
   - Dangerous function usage (exec) and DoS: exec(asm_code) executes arbitrary Python; here asm_code is invalid Python, causing a runtime exception that can halt exports (availability risk) and increases attack surface if ever influenced by input; vulnerable line: exec(asm_code). 
   - Logic flaw causing ineffective sanitization: enumerate(row) iterates dict keys (ModelResource often returns a dict-like row), and row[idx] = val writes by numeric index, so intended cell sanitization likely never occurs, effectively bypassing protection; vulnerable lines: for idx, val in enumerate(row): and row[idx] = val.
3. N/A
4. N/A

",1,1,49.59731197357178
