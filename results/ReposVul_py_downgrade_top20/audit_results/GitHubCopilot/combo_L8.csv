file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES

2. Vulnerabilities:
- Arbitrary native code execution via unsafe library load (line 9): CDLL('./auth_lib.so') loads a native library from the current working directory without validation/signature, enabling DLL preloading/hijacking.
- Arbitrary code execution via dynamic import from config (lines 18–19): import_module(auth_type) uses untrusted configuration to import and execute module top-level code.
- Authentication disabled by config (lines 14–15, 31–33): ""None"" auth type returns True for any credentials, enabling full auth bypass if misconfigured.
- Insecure password storage/verification options:
  - Plaintext passwords (lines 45–46, 77–78): stores/verifies passwords in cleartext.
  - Unsalted SHA-1 (lines 43–44, 83–89): weak, fast, and collision-prone, not suitable for password hashing.
  - SSHA with SHA-1 and salt handling bug (lines 41–42, 90–99): uses SHA-1; moreover, salt is lost due to reusing hash_value (salt_value = hash_value[20:] after truncation), effectively verifying as unsalted SHA-1 or failing; also uses deprecated decode(""base64"") idiom.
  - APR1-MD5 (lines 47–55, 104–105): MD5-based scheme is outdated and weak for passwords.
  - crypt() (lines 64–71, 80–81): may fall back to weak algorithms (e.g., DES-based), not memory-hard.
- Timing side-channel/user enumeration (lines 114–116): success returns immediately while failures sleep 1–2s, allowing attackers to distinguish valid credentials or usernames via response time.
- Unvalidated htpasswd path from config (lines 38–40, 108): attacker-controlled or world-writable path could allow adding credentials or reading arbitrary files; no permission/ownership checks.
- Non-constant-time comparisons (e.g., lines 77–78, 80–81, 88–89, 102–105 implicitly): direct equality comparisons may leak timing info for hash comparisons.

3. N/A

4. N/A

",1,1,38.7419011592865
132_recursive_url_loader.py,"1. YES
2. - Type: Insecure TLS/SSL verification disabled; Lines: aiohttp.TCPConnector(ssl=False) in _async_get_child_links_recursive; Reason: Disables certificate verification, enabling MITM attacks.
   - Type: SSRF via unvalidated URL and redirects; Lines: requests.get(url, ...) and async session.get(url) calls; Reason: User-controlled url can target internal services and follows redirects to arbitrary hosts; prevent_outside only filters discovered links, not initial fetch/redirects.
   - Type: Arbitrary code execution/DLL preloading; Lines: libname = os.path.abspath(""example""); example = ctypes.CDLL(libname); c_result = call_c_function(); Reason: Loads a native library from the working directory without validation and executes it at import time.
   - Type: Import-time side effects; Lines: c_result = call_c_function() at module scope; Reason: Executes native code on import, violating least surprise and increasing attack surface.
   - Type: DoS via unbounded async fan-out; Lines: sub_tasks.append(...); await asyncio.gather(*sub_tasks); Reason: No concurrency limits on spawned tasks can exhaust resources on pages with many links.
   - Type: DoS via revisiting links (sync path); Lines: in _get_child_links_recursive, visited.add(url) only executed at depth >= max_depth and missing otherwise; Reason: Allows repeated visits before depth limit, potentially exploding requests.
   - Type: Sensitive data exposure in logs; Lines: logger.warning(f""Unable to load from {url}... {e}""); Reason: Logs full URLs/errors which may contain tokens/credentials.
   - Type: ReDoS; Lines: extract_sub_links(... pattern=self.link_regex ...); Reason: User-supplied regex can cause catastrophic backtracking on large pages.
   - Type: Resource exhaustion; Lines: reading response.text and parsing without size/content-type checks; Reason: Large responses can consume excessive memory/CPU.
   - Type: Unsafe ctypes call prototype; Lines: result = example.c_function(); Reason: Missing argtypes/restype can cause memory corruption/UB if signature mismatches.
3. N/A
4. N/A

",1,1,49.851165771484375
133_tests.py,"
1. YES

2. Vulnerabilities:
- Unsafe native library loading (DLL hijacking risk): Line with c_lib = ctypes.CDLL('libc.so.6'). Reason: Loads a non‑absolute filename; dynamic loader search order can be abused if an attacker can place a malicious libc.so.6 earlier in the search path (current working directory or user-writable paths), leading to arbitrary code execution when tests run.
- Weak hardcoded credentials: Lines where self.client.login(username=""admin"", password=""admin"") is called. Reason: Reliance on default admin/admin credentials; if copied to non-test code or reused in seeded databases it eases brute-force or credential stuffing.

3. N/A

4. N/A
",1,1,0.015989303588867188
143_binary_server_asyncio.py,"1. YES
2. - Unbounded receive buffer and unvalidated message size (lines 52–71): header.body_size is not bounded and data is accumulated in self._buffer without limits, enabling memory-exhaustion DoS by advertising very large bodies; no maximum frame/message size is enforced.
   - Unbounded internal message queue / missing backpressure (lines 24, 70, 76–84): messages = asyncio.Queue() has no maxsize and producer puts with put_nowait while a single consumer processes sequentially, allowing attacker to flood and exhaust memory.
   - Unsafe/unnecessary native library loading (line 11): ctypes.CDLL(""libc.so.6"") may allow DLL preloading/injection via library-path manipulation and introduces portability/crash risk (DoS) despite being unused.
3. N/A
4. N/A

",1,1,92.93260884284972
165_admin.py,"1. YES

2. Vulnerabilities:
- Type: Insecure dynamic library loading / arbitrary code execution (DLL preloading)
  - Vulnerable lines:
    - ctypes.CDLL(""gcc -shared -o remove_illegal_chars.so -fPIC remove_illegal_chars.c"").remove_illegal_chars
    - c_func = ctypes.CDLL(""./remove_illegal_chars.so"").remove_illegal_chars
  - Reason: CDLL is given a relative path (and in the first case, a string that will be treated as a library filename, not a command), allowing an attacker to place a malicious shared object in the working directory (or one literally named ‘gcc -shared -o …’) to get executed.

- Type: Insecure temporary file handling / predictable filename (symlink/clobber attack)
  - Vulnerable line:
    - with open(""remove_illegal_chars.c"", ""w"") as f: f.write(c_code)
  - Reason: Writes to a predictable file in the current directory without safe temp file APIs; an attacker can pre-create or symlink this name to cause arbitrary file overwrite.

- Type: TOCTOU/race condition around native library artifact
  - Vulnerable lines:
    - File write of remove_illegal_chars.c and subsequent load of ./remove_illegal_chars.so
  - Reason: Between file creation and later library loading, an attacker could swap/replace the .so in the working directory, resulting in loading attacker-controlled code.

- Type: Unsafe native code (buffer handling) leading to undefined behavior/DoS
  - Vulnerable lines (in embedded C):
    - while (strlen(val) > 0 && strchr(illegal_chars, val[0])) { ... }
    - memmove(val, val + 1, strlen(val));
  - Reason: memmove copies strlen(val) bytes and omits the NUL terminator, leaving val non–NUL-terminated; subsequent strlen/strchr read past bounds causing crashes or memory corruption.

3. N/A

4. N/A

",1,1,39.80920147895813
