file_name,audit_report,input_token_num,output_token_num,inference_time
63_auth.py,"1. YES.
2. Vulnerabilities:
   - Weak/insecure password hashing options: enabling ""plain"", ""crypt"", ""sha1"", or ""ssha"" (in Auth.__init__ branches selecting self.verify and in _plain/_crypt/_sha1/_ssha) allows plaintext, unsalted, or fast/obsolete hashes that are trivial to brute-force. 
   - SSHA parsing bug (in _ssha): hash_value = hash_value[:20]; salt_value = hash_value[20:] slices the already-truncated value, making salt empty and effectively comparing an unsalted SHA-1; also "".decode('base64')"" is legacy/unsafe in Py3; result is authentication failure/DoS for valid SSHA entries. 
   - Timing side-channel/user enumeration: is_authenticated only calls verify() when login matches; despite time.sleep(1 + random.random()), extra verify cost (e.g., bcrypt) lets attackers average response times to detect existing usernames; also fixed 1–2s sleep per failure can be abused for DoS. 
   - Dynamic import from config (load → import_module(auth_type).Auth): if configuration is attacker-controlled, this is arbitrary code execution. 
   - Dangerous configuration option: ""NoneAuth"" (auth_type == ""None"") makes is_authenticated always True (no authentication).
3. N/A.
4. N/A.

",1,1,56.44119119644165
132_recursive_url_loader.py,"
1. YES

2. Vulnerabilities:
- Server-Side Request Forgery (SSRF): Lines 163-165, 180-187, 235-238, 257-264, 271-275. Arbitrary URLs are fetched recursively without strong restriction; prevent_outside can be disabled and same-host links can pivot to internal services.
- Disabled SSL Verification (MITM risk): Line 227. aiohttp.TCPConnector(ssl=False) disables certificate validation, enabling interception.
- Unbounded Async Concurrency / Resource Exhaustion: Lines 268-276. Spawns one task per discovered link with no cap; large pages can cause high memory, socket exhaustion, DoS.
- Regex Denial of Service (ReDoS) risk: Lines 184, 261. User-supplied link_regex passed to extract_sub_links; a crafted catastrophic regex can freeze processing.
- Unbounded Response Size / Memory Consumption: Lines 163, 235-236, 172, 248. Entire response bodies loaded into memory (.text) without size/content-type checks; large or binary responses can exhaust memory.
- Race / Incomplete Synchronization on visited set: Lines 232-233, 268-283. Lock used, but URLs gathered before definitive deduplication; duplicates can increase load.
- Broad Exception Swallowing: Lines 166-170, 239-243. Catching Exception hides specific network/security errors; may impede detection/logging of malicious behavior.
- Missing robots.txt / crawl policy compliance: No checks anywhere; can unintentionally crawl disallowed paths (ethical/legal exposure).

3. (Not applicable)

4. (Not applicable)
",1,1,0.012998580932617188
133_tests.py,"
1. NO

2. N/A

3. Reason: This file contains test cases rather than production logic. It does not introduce exploitable behaviors itself; instead it verifies protections (e.g., path normalization, SSRF blocking, header handling, zip download behavior). Hardcoded credentials (admin/admin) and external network reliance appear only in a controlled test context and do not constitute a runtime vulnerability in the application code. No unsafe file writes, command execution, insecure deserialization, injection points, or trust boundary violations are present in these tests.

4. N/A
",1,1,0.01700305938720703
143_binary_server_asyncio.py,"1. YES

2. Vulnerabilities:
- Denial of Service (CPU spin) on malformed header: lines 65–69; after close(), the while self._buffer loop continues without consuming/clearing data, repeatedly re-parsing the same malformed header and logging, causing tight-loop CPU exhaustion.
- Unbounded memory growth (DoS): line 24 (unbounded asyncio.Queue), line 53 (unbounded self._buffer growth), lines 70–75 (accepts arbitrary header.body_size and enqueues messages without size caps); a fast sender can force large in-memory buffering.
- Slowloris/read-timeout absence: lines 70–72; when body bytes are incomplete it returns and keeps the connection open with no read timeout or progress checks, allowing many stalled connections to exhaust resources.
- Insecure transport (cleartext): line 125; create_server is used without SSL/TLS, so traffic is unencrypted/authentication not enforced at transport (unless separately handled by UaProcessor policies).
- Information disclosure via logging: line 28 (__str__ includes self.processor.session which may expose sensitive session info if logged), lines 77/90/166 (logger.exception leaks stack traces), and line 67 (logs attacker-controlled header content).

3. N/A

4. N/A

",1,1,64.28173899650574
165_admin.py,"1. YES
2. - Improper neutralization of CSV/Excel formulas (Formula/CSV Injection): lines defining illegal_start_vals and the while loop; reason: it strips leading symbols instead of safely escaping (e.g., prefixing with a single quote), which is not robust across spreadsheet apps and silently alters data.
   - Incorrect control character handling: line with illegal_start_vals uses ""\\t"", ""\\r"", ""\\n""; reason: these match literal backslash sequences, not actual tab/CR/LF, allowing control-char-led formulas to slip through in some contexts.
   - Sanitization bypass via strict type check: line ""if type(val) is str""; reason: str-like objects (subclasses, Django SafeString, translation proxies) won’t be sanitized; use isinstance(val, str).
   - Data integrity/business logic risk: inclusion of '-' and removal loop; reason: negative numbers or IDs starting with '-' are changed (e.g., ""-5"" becomes ""5"").
3. N/A
4. If the backslashes were only formatting in the snippet and the real code uses '\t', '\r', '\n', the control-character issue may not apply, but the other issues still stand.

",1,1,37.923203229904175
