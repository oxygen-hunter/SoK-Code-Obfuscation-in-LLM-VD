file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
63_auth.py,"1. YES.
2. Vulnerabilities: (a) Untrusted dynamic import → potential RCE if config is attacker-controlled (load(): import_module(auth_type).Auth); (b) Authentication bypass via NoneAuth (NoneAuth.is_authenticated always True); (c) Insecure password schemes: plain (no hashing), sha1 (unsalted), ssha implemented incorrectly (drops salt due to slicing bug), md5/apr1 and crypt are obsolete/weak (Auth.__init__, _plain, _sha1, _ssha, _md5apr1, _crypt); (d) Timing side-channel via non-constant-time equality and faster success vs. uniformly delayed failure (verify funcs, is_authenticated); (e) DoS risk: _ssha uses ""decode('base64')"" (Python 2-only) causing exceptions/availability issues; (f) DoS amplification via time.sleep on every failed attempt (is_authenticated).
3. N/A.
4. N/A.

","CVE: CVE-2017-8342
CVE Description: Radicale before 1.1.2 and 2.x before 2.0.0rc2 is prone to timing oracles and simple brute-force attacks when using the htpasswd authentication method.
CWE: ['CWE-362']
CWE Description: 
",2.0,831.0,7.0,1.4386584758758545
132_recursive_url_loader.py,"1. YES
2. - Insecure TLS/SSL configuration (CWE-295): aiohttp.TCPConnector(ssl=False) in _async_get_child_links_recursive; disables certificate verification, enabling MITM and accepting forged certs.
   - Server-Side Request Forgery (SSRF) (CWE-918): requests.get(url, ...) and async with session.get(url) as response plus recursive traversal via extract_sub_links(...); accepts user-controlled URLs, follows redirects by default, and lacks host/IP/scheme allowlists, allowing access to internal endpoints even if prevent_outside is True (applies only to sub-links and is configurable).
   - Denial of Service via unbounded concurrency/traversal (CWE-400): sub_tasks.append(...); next_results=await asyncio.gather(*sub_tasks) and the sync for link in sub_links without caps; no limits on number of pages or concurrent tasks, so a page with many links can exhaust CPU/memory/network.
   - Potential ReDoS (CWE-400): extract_sub_links(..., pattern=self.link_regex, ...); user-supplied/unsafe regex can cause catastrophic backtracking on large inputs.
   - Information exposure through logs (CWE-532): logger.warning(f""Unable to load from {url}..."") and logger.warning(f""Unable to load {url}...""); logging full URLs/exceptions may leak secrets in query strings or credentials.
3. N/A
4. N/A

","CVE: CVE-2023-46229
CVE Description: LangChain before 0.0.317 allows SSRF via document_loaders/recursive_url_loader.py because crawling can proceed from an external server to an internal server.
CWE: ['CWE-918']
CWE Description: 
",4.0,918.0,7.0,0.8278722763061523
133_tests.py,"
1. NO

2. N/A

3. Reason: The file is a Django test suite exercising proxy, download, and tag behaviors using controlled inputs and mocks. Hardcoded test credentials and external URLs are confined to test context. No user-controlled data reaches dangerous sinks (command execution, injection, insecure deserialization). Network calls are either mocked or part of validation logic for SSRF protections. No exploitable security flaws in production code are introduced by these tests.

4. N/A
","CVE: CVE-2023-40017
CVE Description: GeoNode is an open source platform that facilitates the creation, sharing, and collaborative use of geospatial data. In versions 3.2.0 through 4.1.2, the endpoint `/proxy/?url=` does not properly protect against server-side request forgery. This allows an attacker to port scan internal hosts and request information from internal hosts. A patch is available at commit a9eebae80cb362009660a1fd49e105e7cdb499b9.
CWE: ['CWE-918']
CWE Description: 
",1.0,784.0,7.0,0.7637934684753418
143_binary_server_asyncio.py,"1. YES
2. - Denial of Service (memory exhaustion): data_received uses an unbounded input buffer with no max frame/body size check (self._buffer+=data; if len(buf)<header.body_size: return; self._buffer=self._buffer[(header.header_size+header.body_size):]); an attacker can advertise huge header.body_size to force arbitrary memory growth. Vulnerable lines: in data_received(...) where self._buffer is appended, body_size is trusted, and no max limits are enforced. Reason: allows unbounded accumulation of bytes in memory.
   - Denial of Service (queue growth/backpressure): unbounded per-connection queue (self.messages=asyncio.Queue()) and producer enqueues without limits (self.messages.put_nowait((header,buf))). Vulnerable lines: __init__ (self.messages=asyncio.Queue()) and data_received(...) (self.messages.put_nowait(...)). Reason: attacker can flood messages faster than the consumer loop, causing unbounded memory growth.
   - Insecure transport (missing TLS): server created without SSL/TLS (asyncio.get_running_loop().create_server(self._make_protocol,self.hostname,self.port)). Vulnerable lines: start(...). Reason: unencrypted/unauthenticated TCP allows eavesdropping and MITM on OPC UA traffic.
   - Information disclosure via verbose logging: logger.exception(...) on attacker-triggerable paths leaks stack traces to logs; f'Got malformed header {header}' may log untrusted header content. Vulnerable lines: data_received(...) logger.exception(...), _process_received_message_loop(...) logger.exception(...), data_received(...) logger.error(f'Got malformed header {header}'). Reason: detailed internal errors and untrusted data can expose implementation details if logs are accessed.

","CVE: CVE-2023-26151
CVE Description: Versions of the package asyncua before 0.9.96 are vulnerable to Denial of Service (DoS) such that an attacker can send a malformed packet and as a result, the server will enter into an infinite loop and consume excessive memory.
CWE: ['CWE-835']
CWE Description: 
",4.0,988.0,7.0,0.7891411781311035
165_admin.py,"1. YES
2. - CSV/Formula Injection bypass via improper type check — line: ""if type(val) is str:""; reason: subclasses of str (e.g., django.utils.safestring.SafeString) won’t match and thus won’t be sanitized, allowing cells starting with ""="", ""+"", ""-"", ""@"", etc. to execute in spreadsheets.
   - CSV/Formula Injection bypass via invisible Unicode/control prefixes — lines: ""val = val.strip()"" and ""while len(val) > 0 and val[0] in illegal_start_vals:""; reason: only first codepoint is checked against a small ASCII list and strip() doesn’t remove format chars like U+200B/U+FEFF, enabling an attacker to prefix an invisible char before ""="" so spreadsheet apps still interpret a formula.
   - Data integrity risk (potential business logic/security impact) — lines: ""illegal_start_vals = ['@','=','+','-','@','\t','\r','\n']"" and the while loop; reason: removing leading '-' alters legitimate negative values/identifiers, which can corrupt data and enable confused-deputy scenarios.

","CVE: CVE-2022-2112
CVE Description: Improper Neutralization of Formula Elements in a CSV File in GitHub repository inventree/inventree prior to 0.7.2.
CWE: ['CWE-1236']
CWE Description: 
",4.0,844.0,7.0,0.7392683029174805
