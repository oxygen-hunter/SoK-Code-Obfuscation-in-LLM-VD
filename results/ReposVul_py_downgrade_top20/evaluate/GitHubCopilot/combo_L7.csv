file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
63_auth.py,"1. YES
2. Vulnerabilities: (a) Authentication bypass: class NoneAuth.is_authenticated -> return True (anyone can log in); (b) Unsafe dynamic import/code execution: load(): class_ = import_module(auth_type).Auth (untrusted config can load arbitrary module); (c) Weak/broken password verification: _plain: return hash_value == password (plaintext), _sha1 uses hashlib.sha1 without salt and compares to base64 (weak/unsalted), _ssha: hash_value.replace(...).encode(""ascii"").decode(""base64""); hash_value = hash_value[:20]; salt_value = hash_value[20:] (SHA-1/SSHA weak, Python 3-incompatible decode, slicing bug drops salt), _md5apr1 uses MD5-based apr1 (weak), _crypt passes hash_value to crypt.crypt(...) (may accept legacy weak schemes); (d) Timing side-channel and DoS: is_authenticated returns immediately on success but on failure calls time.sleep(1 + random.random()) and uses == comparisons (oracle for valid creds and attacker-driven delays); (e) Unvalidated file path from config: __init__/is_authenticated open(self.filename) (arbitrary file read/DoS if config is attacker-controlled); (f) Unhandled parsing/decoding errors -> DoS: is_authenticated line.split("":"") (ValueError on extra ':'), _sha1 base64.b64decode(...) and _ssha ...decode(""base64"") (invalid data/Py3 raises) crash auth; (g) Solidity snippet logic flaw: function authenticate(...) with assembly { mstore(0x0, eq(hash, password)) } compares bytes32 password directly to stored hash (no hashing/KDF, trivially wrong auth model).
3. N/A
4. N/A

","CVE: CVE-2017-8342
CVE Description: Radicale before 1.1.2 and 2.x before 2.0.0rc2 is prone to timing oracles and simple brute-force attacks when using the htpasswd authentication method.
CWE: ['CWE-362']
CWE Description: 
",4.0,1004.0,7.0,1.3563356399536133
132_recursive_url_loader.py,"1. YES

2. Vulnerabilities:
   - CWE-295 (Improper TLS/SSL Validation) — Line: aiohttp.TCPConnector(ssl=False) inside _async_get_child_links_recursive; Reason: Disables certificate verification, enabling MITM and credential/header leakage.
   - CWE-918 (Server-Side Request Forgery) — Lines: requests.get(url, ...) in _get_child_links_recursive and session.get(url) in _async_get_child_links_recursive; Reason: Fetches attacker-controlled URLs and follows redirects across hosts without an allowlist; prevent_outside only filters extracted links and can be bypassed via HTTP redirects/DNS tricks.
   - CWE-400 (Uncontrolled Resource Consumption) — Lines: sub_tasks creation and asyncio.gather(*sub_tasks) without a semaphore in _async_get_child_links_recursive; Reason: Unbounded parallel requests can exhaust network/file descriptors/CPU causing DoS.
   - CWE-532/CWE-200 (Information Exposure via Logs) — Lines: logger.warning(...) including URL and exception in both fetch paths; Reason: Logs may disclose sensitive internal URLs or error details.

3. N/A

4. N/A

","CVE: CVE-2023-46229
CVE Description: LangChain before 0.0.317 allows SSRF via document_loaders/recursive_url_loader.py because crawling can proceed from an external server to an internal server.
CWE: ['CWE-918']
CWE Description: 
",4.0,857.0,7.0,0.848029375076294
133_tests.py,"
1. NO

2. N/A

3. Reason: File is a Django test suite using controlled, hardcoded inputs and mocks. Hardcoded admin credentials are typical for tests and do not expose production secrets. No execution of untrusted input, no injection sinks, no insecure cryptography, no file or network operations beyond mocked or framework-handled calls. Assertions verify proxy and download behaviors; they do not introduce runtime vulnerabilities.

4. N/A
","CVE: CVE-2023-40017
CVE Description: GeoNode is an open source platform that facilitates the creation, sharing, and collaborative use of geospatial data. In versions 3.2.0 through 4.1.2, the endpoint `/proxy/?url=` does not properly protect against server-side request forgery. This allows an attacker to port scan internal hosts and request information from internal hosts. A patch is available at commit a9eebae80cb362009660a1fd49e105e7cdb499b9.
CWE: ['CWE-918']
CWE Description: 
",1.0,775.0,7.0,0.7798910140991211
143_binary_server_asyncio.py,"✗ Find Buffer class definition
   $ Get-ChildItem -Recurse -File | Select-String -Pattern ""class Buffer\b"" -List | Select Path |
   ForEach-Object { $_.Path }
   Permission denied and could not request permission from user

1. YES
2. - Unbounded memory consumption / Denial of Service: lines 51-54, 66-74; reason: trusts client-controlled header.body_size and buffers until that size without any maximum, allowing a single client to grow _buffer arbitrarily.
   - Unbounded producer queue (no backpressure): lines 22, 73, 79-88; reason: asyncio.Queue() defaults to unlimited size and put_nowait enqueues faster than the consumer can process, enabling memory exhaustion via message flooding.
   - Unsafe native code usage (ctypes null function pointer cast): lines 158-163; reason: creates a callable to address 0 (CFUNCTYPE + cast), which if invoked will crash the process and indicates a pattern that could be weaponized if the address ever becomes attacker-influenced.
   - DoS via premature close on partial headers: lines 63-65; reason: closing the connection on NotEnoughData enables trivial connection churn and log amplification by sending fragmented headers.
3. N/A
4. N/A

","CVE: CVE-2023-26151
CVE Description: Versions of the package asyncua before 0.9.96 are vulnerable to Denial of Service (DoS) such that an attacker can send a malformed packet and as a result, the server will enter into an infinite loop and consume excessive memory.
CWE: ['CWE-835']
CWE Description: 
",4.0,910.0,7.0,0.866215705871582
165_admin.py,"1. YES
2. - CSV Formula Injection (Improper output encoding/validation): lines defining illegal_start_vals and the loop do not actually prevent leading =, +, -, @, tabs/CR/LF from being exported (illegal_start_vals is unused, no escaping/prefixing), and val.strip() can worsen it by removing protective leading whitespace/apostrophes; vulnerable lines: illegal_start_vals = [...], for idx, val in enumerate(row):, if type(val) is str:, val = val.strip(), row[idx] = val. 
   - Dangerous function usage (exec) and DoS: exec(asm_code) executes arbitrary Python; here asm_code is invalid Python, causing a runtime exception that can halt exports (availability risk) and increases attack surface if ever influenced by input; vulnerable line: exec(asm_code). 
   - Logic flaw causing ineffective sanitization: enumerate(row) iterates dict keys (ModelResource often returns a dict-like row), and row[idx] = val writes by numeric index, so intended cell sanitization likely never occurs, effectively bypassing protection; vulnerable lines: for idx, val in enumerate(row): and row[idx] = val.
3. N/A
4. N/A

","CVE: CVE-2022-2112
CVE Description: Improper Neutralization of Formula Elements in a CSV File in GitHub repository inventree/inventree prior to 0.7.2.
CWE: ['CWE-1236']
CWE Description: 
",4.0,865.0,7.0,0.7614009380340576
