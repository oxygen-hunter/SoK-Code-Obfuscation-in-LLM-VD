file_name,audit_report,input_token_num,output_token_num,inference_time
11_ElGamal.py,"1. YES
2. - Broken state isolation / secret leakage — `VM.load_program:13-14`, `VM.run:16-45`, `ElGamalobj.execute_vm:52-55`: the VM instance is reused without resetting `stack`, `registers`, `pc`, or `running`. After a program halts, `running` stays `False` and the old stack (which contains sensitive values like the private exponent) is returned on the next call. Any later operation such as `encrypt` therefore hands out leftover secrets instead of fresh results, fully exposing private key material.
   - Cryptographic failure — `VM.execute:22-45` together with `encrypt:57-75`, `decrypt:83-96`, `sign:107-126`, `verify:134-159`, `generate:164-205`: the VM never implements handlers for opcodes such as `CALL`, `MUL`, or `MOD`. Consequently the crypto routines never invoke `pow`, never perform modular arithmetic, and simply store previously pushed operands (e.g., the modulus `p`). Encryption ignores the plaintext and randomness, signatures aren’t computed, and key generation never produces real parameters, so confidentiality and authenticity collapse completely.
",1,1,296.0400528907776
14_static.py,"1. YES
2. - Denial-of-Service (Resource exhaustion) — `static_view.py:17`, `static_view.py:77`, `static_view.py:84`, `static_view.py:92`: every request appends new instructions to the shared `VM.instructions` list and `VM.execute` never resets `pc` or trims old entries, so the instruction tape grows without bound; an attacker can send many requests to exhaust memory.
   - Denial-of-Service (Resource exhaustion) — `static_view.py:135-151`: with `reload` false (the default), `self.filemap` stores every requested `resource_name` even when no file exists, so repeated requests for random paths steadily grow the cache until memory is exhausted.
   - Input Validation / DoS — `static_view.py:179-183`: `_invalid_element_chars` checks for the literal string `'\\x00'` instead of the null byte `'\x00'`, so a request containing an embedded null is accepted and later triggers `ValueError: embedded null character` in filesystem calls, allowing an attacker to crash the view repeatedly.
3. N/A
4. N/A
",1,1,319.6680035591125
55_pathutils.py,"YES
- Path Traversal / Input Validation Bypass: code_obfuscation.py:35, code_obfuscation.py:43-89 – the VM’s `STORE` handler replaces the entire stack with the literal key (`self.stack = [args[0]]`), so later `LOAD ""path""`/`""split_path""` instructions operate on the string names, not the user-supplied value. All guard branches (`JZ` checks for `""""`, `.`, `..`, drive letters, etc.) therefore run against constant truthy values and never execute. Components such as `../../etc/passwd` are never stripped or rejected, so the sanitizer provides no protection against directory traversal.
- Security Control Bypass: code_obfuscation.py:78-89 – `compile_path_to_filesystem` pushes `ValueError(""Unsafe path"")` onto the stack but never raises it, and the function exits returning the literal `""error""`. Callers expecting an exception when the path is unsafe will continue executing with an unchecked path, defeating the intended safeguard.
",1,1,345.18449234962463
111_general.py,"1. YES  
2. - CWE-362 (race condition via shared mutable globals) — `aggregates.py:25`, `aggregates.py:70`, `aggregates.py:90`, `aggregates.py:104`  
    Reason: `compile_aggregation()` writes aggregator configuration (`function`, `allow_distinct`, `output_field`, `delimiter`, etc.) into the module `globals()`, and each aggregator’s `__init__` immediately reads those globals back. In a real Django deployment that serves concurrent requests, those globals are process-wide. An attacker who can trigger aggregator construction (e.g., via API queries) can race another request: after their `compile_aggregation()` call poisons the globals but before the victim request copies them, they hand the victim a mismatched `function`/`delimiter`. That forces the victim query to execute with attacker-controlled settings, yielding database errors (denial of service) or malformed results.
",1,1,267.58011984825134
116_utils.py,"Vulnerable: YES

- Denial of Service (`code.py:20-27,29-32`): `POP`, `ADD`, `SUB`, and the jump opcodes trust that the stack and program counter always hold valid state. With attacker-controlled bytecode, a crafted sequence can trigger stack underflow or set `self.pc` out of range, raising uncaught exceptions (IndexError/TypeError) and crashing the service.
- Fail-Open Privilege Loading (`code.py:39-44`): `load_privilege()` swallows every exception from `load_yaml()` and falls back to an empty dict. If an attacker can point `AUTHZ_FILE` to an unreadable/invalid path (or delete/corrupt the file), the system silently continues with effectively “no restrictions,” defeating the privilege model.

Recommended next steps: 1) Harden the VM by validating stack depth and jump targets before executing untrusted instruction streams. 2) Make privilege loading fail closed—log the error, abort startup, or enforce a minimal-deny policy when the configuration cannot be parsed.
",1,1,69.49079370498657
