file_name,audit_report,input_token_num,output_token_num,inference_time
11_ElGamal.py,"1. YES
2. - Improper nonce/randomness handling (caller-supplied K): lines 51, 53, 55-58, 64-72; reason: K not generated internally—reuse or K=0 enables plaintext disclosure in encryption and private key recovery in signatures.
   - Signature over raw message (no hashing): lines 64-72, 73-79; reason: signing M directly makes ElGamal signatures forgeable (not EUF-CMA); must use H(M).
   - Undefined variable in verify: line 74 uses p instead of self.p; reason: NameError/logic flaw enables verification bypass/DoS and lacks full range checks.
   - Brittle import/use of inverse: lines 62, 71; reason: inverse may be undefined in scope → runtime error/DoS; inconsistent with number.inverse used elsewhere.
   - No input validation on ciphertext/signature elements: lines 59-63, 73-79; reason: invalid values (e.g., M[0]=0) can cause inverse failure/timing differences → DoS/side-channel.
   - Malleable, unauthenticated encryption: lines 55-58; reason: raw ElGamal without MAC/KDF is IND-CPA only and malleable (attackers can tweak plaintext by scaling b).
   - Timing side-channels: lines 61, 69 (ops with secret x); reason: Python big-int pow/inverse not constant-time → potential key leakage via timing.
   - Broken construct/public key assembly: lines 35-40 (uses tuple builtin instead of tup); reason: raises TypeError, breaking publickey() and enabling DoS; also shadowing builtins (line 85 object=ElGamalobj) is unsafe.
3. N/A
4. N/A

",1,1,56.1097674369812
14_static.py,"1) YES. 2) Vulnerabilities: (1) Symlink traversal: get_resource_name returns filesystem paths via resource_path = normcase(normpath(join(self.norm_docroot, path))) and __call__ serves them with FileResponse(...) without verifying os.path.realpath(path).startswith(self.norm_docroot), allowing a symlink inside docroot to escape; (2) Null-byte sanitization bug: _invalid_element_chars = {'/', os.sep, '\\x00'} used by _contains_invalid_element_char/_secure_path does not block the real '\x00', so a decoded null byte can bypass checks and trigger ValueError in filesystem/resource APIs, causing 500 DoS; (3) Unbounded cache DoS: get_possible_files caches self.filemap[resource_name] unbounded when reload=False, letting attackers flood unique paths to exhaust memory; (4) Content negotiation flaw: find_best_match unconditionally adds None to acceptable_encodings even if client sent identity;q=0, potentially serving disallowed variants and risking cache inconsistencies when Vary is present. 3) N/A. 4) N/A.

",1,1,57.55347657203674
55_pathutils.py,"1. YES
2. - Symlink traversal / TOCTOU risk: lines 57–76 (esp. 68–71 and 76). Reason: Only per-component checks are done; the final path is returned without resolving or enforcing it stays within base_folder, allowing symlink-based escapes if an attacker can create symlinks inside base_folder.
   - Log injection / information disclosure: line 69. Reason: Logs untrusted path verbatim; embedded newlines/control chars can forge log lines or leak sensitive input.
   - Incomplete normalization on Windows if sanitize_path is used alone: lines 23–41. Reason: Uses posixpath and splits only on ""/"", so backslash-separated traversal (e.g., ""..\\.."") isn’t removed; unsafe if later used for filesystem/security decisions without additional checks.
3. N/A
4. N/A

",1,1,48.93323349952698
111_general.py,"1. NO
3. Reason: The code uses Django ORM Aggregates with constant function names and parameterized inputs (e.g., StringAgg wraps the delimiter in Value), avoiding dynamic SQL/string concatenation, eval/exec, or unsafe I/O. JSONField from contrib is deprecated but not a security risk.

",1,1,17.68454623222351
116_utils.py,"1. YES.
2. - Missing authentication/authorization for SP registration and primary promotion: simple_PSP_policy(): update_sp({...}) when sp not found and later psp[""primary""] = True; promote_sp(): psp[""primary""] = True and current_psp[""primary""] = False; reason: any caller can register/overwrite SPs and force leadership without verification (privilege escalation/IDOR).
   - Potential unsafe YAML deserialization and untrusted file loading: load_privilege(): privilege = load_yaml(privilege_file) where privilege_file = os.environ[""AUTHZ_FILE""]; reason: if load_yaml uses an unsafe loader this can lead to code execution; even with safe loader, attacker-controlled env var can read arbitrary files.
   - Bare except hides authz load failures: load_privilege(): except: privilege = dict(); reason: silently defaulting to empty rules may weaken or bypass authorization if callers treat missing rules as permissive.
   - Race condition in primary election/promotion: simple_PSP_policy() and promote_sp() mutate “primary” without locking/uniqueness enforcement; reason: concurrent calls can create split-brain or overwrite a legitimate primary.
   - Information disclosure: print(f""{psp['sp_end_point']} online/promoted/demoted""); reason: leaks internal service endpoints and state to logs/stdout.

",1,1,47.31100702285767
