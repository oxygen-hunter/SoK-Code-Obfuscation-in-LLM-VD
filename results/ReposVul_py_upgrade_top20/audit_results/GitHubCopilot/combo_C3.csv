file_name,audit_report,input_token_num,output_token_num,inference_time
11_ElGamal.py,"1. YES
2. Vulnerabilities: (a) Incorrect ElGamal signature algorithm — in sign(...) VM program and verify(...): no k^{-1} multiplication and no hashing of M, enabling forgery and violating scheme definition; (b) User-controlled nonce K in encrypt(...) and sign(...): caller supplies K with no randomness/reuse protection, allowing nonce reuse/predictability and private key recovery; (c) Missing parameter validation — in construct(...) and generate(...): accepts external (p,g,y[,x]) without checks and picks g without ensuring subgroup order q (e.g., g=p-1 of order 2), enabling small-subgroup/invalid-parameter attacks; (d) Incomplete signature checks — in verify(...): checks range of a only, not 1 ≤ b ≤ p−2, enabling invalid signatures; (e) Side-channel risk — pow and arithmetic not constant-time over secrets (x, K), enabling timing leakage; (f) VM opcode gaps/DoS — VM.execute lacks CALL/MUL/MOD used by encrypt/decrypt/sign/verify/generate, causing runtime failures or denial of service; (g) Wildcard import — from Crypto.PublicKey.pubkey import * increases namespace collision risk
3. N/A
4. N/A

",1,1,51.16367030143738
14_static.py,"1. YES.
2. - Open redirect: add_slash_redirect builds an absolute URL from request.path_url and echoes the Host header, enabling host-header–based redirects/cache poisoning (function add_slash_redirect).
   - DoS/info disclosure: VM.execute lacks a 'CALL' handler, so CALL steps in static_view.__init__/__call__ corrupt the stack and trigger TypeError/NameError during path resolution (VM.execute, static_view.__init__/__call__, find_resource_path uses undefined resource_* symbols).
   - NUL-byte filtering bug: _invalid_element_chars uses the literal ""\\x00"" instead of the NUL character, failing to block actual NULs in path elements (declaration of _invalid_element_chars).
   - Cache poisoning risk: Vary: Accept-Encoding is only added when multiple files exist; serving a single compressed variant without unconditional Vary can poison shared caches (static_view.__call__ around FileResponse and _add_vary).
   - Potential arbitrary file read: if manifest_spec is attacker-controlled, ManifestCacheBuster resolves and reads arbitrary filesystem paths without validation (ManifestCacheBuster.__init__/get_manifest).
3. N/A.
4. N/A.

",1,1,53.48005509376526
55_pathutils.py,"1. YES.
2. Vulnerabilities: Path traversal via broken sanitization and unsafe concatenation — uses posixpath.normpath on Windows and splits only on ""/"", allowing ""\""-based traversal and preserving leading "".."" (lines with posixpath.normpath(path), path.split(""/""), and string ADDs to build paths); Component check is bypassed by validating the literal ""split_path"" instead of the actual segment (code.append((""LOAD"", compile_is_safe_filesystem_path_component(""split_path"")))), so unsafe parts (.., absolute, drives) pass; No enforcement that the final path stays under base_folder (no os.path.commonpath check), enabling directory escape; VM logic invalidates checks — STORE overwrites the whole stack, LOAD never reads variables, and JZ compares popped values to 0 (string vs int), so conditionals don’t work (VM methods: POP/ADD/SUB/JZ/STORE); Potential DoS via unchecked stack underflows (POP/ADD/SUB) if instruction sequencing goes wrong.

",1,1,32.53655242919922
111_general.py,"1. YES.
2. Vulnerabilities: (a) Arbitrary global overwrite via VM STORE (""globals()[var_name] = self.stack.pop()"") in VM.run—if the instruction stream is attacker-controlled, any module global (even __builtins__) can be replaced, enabling code execution/logic tampering; (b) Race condition/global state leakage: aggregators read from globals()['function'/'allow_distinct'/'output_field'/'delimiter_expr'] after compile_aggregation (e.g., in ArrayAgg.__init__, StringAgg.__init__, JSONBAgg.__init__), making behavior cross-request/thread-unsafe in Django; (c) Unchecked control-flow/stack underflow: multiple self.stack.pop() and pc jumps (JMP/JZ) allow negative/invalid jumps and empty-stack pops, enabling DoS or unintended execution when instructions are untrusted.
3. N/A.
4. N/A.

",1,1,47.07975959777832
116_utils.py,"1) YES
2) Vulnerabilities:
- Arbitrary file read / potential unsafe YAML deserialization: load_privilege(): privilege_file = os.environ.get(""AUTHZ_FILE"", ""privilege.yml""); privilege = load_yaml(privilege_file) — ENV-controlled path can read sensitive files; if load_yaml uses unsafe loader, malicious YAML could execute code.
- Authorization bypass via fail-open: load_privilege(): bare except sets privilege = dict(), silently disabling authz on parsing/IO errors.
- Denial of Service: VM.execute(): multiple self.stack.pop() calls (POP/ADD/SUB) without underflow checks and JMP/JZ set self.pc = inst[1]-1 without bounds validation; crafted instructions can crash or loop indefinitely.
- Log/terminal injection: promote_sp(): f""Unable to promote {sp['sp_end_point']}, ..."": untrusted endpoint echoed to logs.
- Minor info disclosure: printing backend selection reveals deployment details.
(Note: Exact line numbers aren’t available from the single-line snippet; the vulnerable statements are shown above.)

",1,1,44.33729195594788
