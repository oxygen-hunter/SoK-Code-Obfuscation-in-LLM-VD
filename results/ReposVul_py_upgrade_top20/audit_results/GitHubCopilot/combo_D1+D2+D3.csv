file_name,audit_report,input_token_num,output_token_num,inference_time
11_ElGamal.py,"1. YES.
2. Vulnerabilities: (a) Broken generator validation using invalid operators allows unsafe g selection (generate(): lines with “safe = (1 == 2) || …”, “if pow(obj.g, …): safe=(1 == 2) && …”, “divmod(obj.p-1, obj.g)”, “divmod(obj.p-1, ginv)”) — small-subgroup/weak-generator risk; (b) User-controlled K without range checks in encryption (def _encrypt(self, M, K): a=pow(self.g, K, self.p)…), K=0 reveals plaintext (a=1, b=M); (c) Signature uses caller-supplied K and no hashing of M (def _sign(self, M, K): …), K reuse leaks x and lack of hashing enables forgery; (d) Broken verification and missing parameter checks (def _verify: uses undefined “p” instead of self.p and checks only a, not b) — DoS and invalid-sig acceptance; (e) construct() misuses “tuple” and performs no key parameter validation (def construct: “if len(tuple)…”, “setattr(…, tuple[i])”) — attacker can load non-prime/weak params; (f) Raw ElGamal without padding/AE (encrypt/decrypt) — malleable, not CCA-secure; (g) Potential timing side-channels due to non-constant-time operations (inverse/pow).
3. N/A.
4. N/A.

",1,1,38.69283962249756
14_static.py,"1. YES
2. Vulnerabilities:
   - Path traversal via absolute/drive-letter paths: in static_view.get_resource_name -> resource_path = normcase(normpath(join(self.norm_docroot, path))) and _secure_path (which does not forbid drive letters or absolute paths). Reason: an element like ""C:"" followed by ""Windows"" becomes ""C:/Windows"", causing os.path.join to discard the docroot and serve files outside the intended directory.
   - Symlink/junction escape: same line in get_resource_name; no post-join containment check (e.g., ensuring realpath(resource_path) starts with realpath(docroot)). Reason: a symlink inside docroot can point outside and be served.
   - NUL-byte check ineffective: _invalid_element_chars = {'/', os.sep, '\\x00'} used by _contains_invalid_element_char and _secure_path. Reason: '\\x00' is the literal backslash-x-zero-zero string, not the NUL byte '\x00', so the intended NUL check can be bypassed (though Python typically rejects NUL in paths, this check is misleading and may fail in other contexts).
   - Potential header injection risk: add_slash_redirect concatenates url = request.path_url + '/' and then url = url + '?' + qs without sanitizing qs. Reason: if the WSGI stack allows CR/LF in query_string, this can lead to a Location header injection; at minimum, it relies on upstream sanitization.
3. —
4. Exact line numbers cannot be provided because the snippet lacks stable line numbering; I referenced the precise code statements and functions instead.

",1,1,57.7596869468689
55_pathutils.py,"1. YES
2. - Symlink traversal (lines 50-61): No realpath/canonicalization containment check after join; a symlinked component inside base_folder can point outside, enabling escape from base_folder.
   - Log injection (line 58): Logs user-controlled path without sanitization; attacker can inject newlines/control chars to forge or poison logs.
3. N/A
4. N/A

",1,1,75.98168683052063
111_general.py,"1. NO
2. N/A.
3. Reason: These are Django ORM Aggregate wrappers that rely on Django’s query compiler and parameter binding (e.g., delimiter wrapped in Value), with no raw SQL concatenation or untrusted input interpolation; function names are constant and no unsafe eval/I/O/deserialization is used.
4. N/A.

",1,1,27.482784509658813
116_utils.py,"1) YES.
2) Vulnerabilities: Missing authentication/authorization on control-plane actions lets spoofed endpoints register/promote themselves (simple_PSP_policy: uses incoming_sp[...] directly; promote_sp: promotes any online sp and sets psp['primary'] = (1==2)||(…) → True); Unsafe/extensible config loading may allow arbitrary file read/RCE via YAML if unsafe loader is used (load_privilege: privilege_file = os.environ['AUTHZ_FILE']; privilege = load_yaml(privilege_file)); Error suppression hides authz failures and can default to empty policy (load_privilege: bare “except:” sets privilege = dict()); DoS via unvalidated datetime parsing (update_sp_state: datetime.fromisoformat(sp['last_heartbeat'])); Insecure default/downgrade risk by falling back to in-memory store if OVERSEER_STORE is unset/invalid (store selection and default .mem_store import).

",1,1,34.983131885528564
