file_name,audit_report,input_token_num,output_token_num,inference_time
11_ElGamal.py,"1. YES
2. - Textbook ElGamal encryption (no KDF/MAC/padding) → malleable and CCA-insecure: lines with def encrypt(...), def _encrypt(...), return pubkey.encrypt(...), a=pow(self.g,K,self.p); b=(M*pow(self.y,K,self.p))%self.p; reason: multiplicative malleability and no integrity.
   - Caller-supplied nonce K with no randomness/uniqueness enforcement: lines with def encrypt(self, plaintext, K), def sign(self, M, K), def _sign(self, M, K); reason: K reuse/predictability breaks confidentiality (encryption) and reveals private key (signature), only GCD check done.
   - Signing without hashing the message: lines with def sign(...), def _sign(...), def _verify(...); reason: using raw M breaks EUF-CMA security and enables forgeries; standard requires hashing M.
   - Broken signature verification uses undefined p: line in _verify: if sig[0] < 1 or sig[0] > p-1: (should be self.p); reason: raises NameError → DoS or potential bypass if caller swallows exceptions.
   - Broken construct(): uses tuple instead of tup repeatedly: lines in construct() checking len(tuple), iterating range(len(tuple)), accessing tuple[i]; reason: runtime errors/DoS, prevents safe key handling.
   - Flawed generator selection: lines in generate() where safe set to 0 if pow(obj.g, q, obj.p)==1 and odd divmod checks on (p-1, g) and its inverse; reason: may reject subgroup-order-q generators and accept unsuitable g, undermining subgroup-safety assumptions.
   - No key size enforcement: generate(bits, ...) accepts arbitrary small bits; reason: weak keys possible.
   - Side-channel risk: all big-int ops (pow, inverse) non-constant time in Python; reason: timing leakage of x/K.
   - Weak RNG surface: randfunc and K fully trusted from caller; reason: predictable RNG or adversarial K compromises keys/signatures.
3. N/A
4. N/A

",1,1,60.44123125076294
14_static.py,"1. YES.
2. Vulnerabilities: Symlink traversal (get_resource_name: c = normcase(normpath(join(self.norm_docroot, b))); find_resource_path: elif exists(name): return name) — no realpath/prefix check allows serving files outside docroot via symlinks; Missing Vary on content negotiation (__call__: if len(b) > 1: _add_vary(f, 'Accept-Encoding')) — when only one encoded variant exists, caches may serve compressed content to clients without Accept-Encoding, enabling cache poisoning; Potential open redirect (add_slash_redirect: a = request.path_url + '/' then appending '?' + request.query_string) — untrusted Host/query can produce a malicious Location header; NUL-byte check bug (_invalid_element_chars = {'/', os.sep, '\\x00'}) — uses literal “\\x00” instead of actual '\x00', failing to block NUL bytes and risking 500s or filter bypass.
3. N/A.
4. N/A.

",1,1,50.36614418029785
55_pathutils.py,"1. YES

2. Vulnerabilities
- Absolute path/drive/UNC injection (directory traversal/base escape on Windows)
  - Vulnerable lines: in is_safe_filesystem_path_component:
    - ""components[0], _ = z"" followed by ""if components[0]: return components[0]""
  - Reason: Returning the drive string (truthy) treats presence of a drive/UNC as “safe”; then path_to_filesystem joins components with os.path.join, allowing inputs like ""C:\Windows"" or ""\\server\share"" to discard base and escape confinement.
- Symlink traversal (TOCTOU)
  - Vulnerable lines: in path_to_filesystem (entire function flow), no post-join confinement check.
  - Reason: The code never verifies that the final resolved path (e.g., os.path.realpath) remains under base, so a symlink inside base can redirect outside.
- Log injection
  - Vulnerable lines: log.LOGGER.debug(""Can't translate path safely to filesystem: %s"", d[1])
  - Reason: Logs untrusted input p; attackers can inject control characters to manipulate logs.

3. N/A

4. N/A

",1,1,55.98293805122376
111_general.py,"1. NO
2. N/A
3. Reason: Aggregates use Django ORM compilation and parameterization (e.g., Value for delimiters) with static function names; no raw SQL string interpolation or unsafe I/O/deserialization apparent in the snippet.
4. Note: Cannot assess the unseen OrderableAggMixin; if it injects raw ORDER BY fragments, that could introduce SQL injection risk.

",1,1,21.59419107437133
116_utils.py,"1. YES
2. - Improper exception handling / fail-open (lines 11–16): bare except returns empty dict for AUTHZ_FILE, likely bypassing authorization on parse/read errors.
   - Potential insecure YAML deserialization (line 13): load_yaml on env-controlled file path (line 9) may use unsafe loader; a crafted YAML could trigger code execution and attacker-controlled path could be loaded.
   - Missing authorization for state-changing operations (lines 28–71): _3 and _4 allow registration/promotion/demotion and session ID assignment without authn/authz, enabling DoS/privilege manipulation.
   - DoS via unhandled exceptions (lines 21, 60): fromisoformat on untrusted last_heartbeat and _l[_m] lookup for arbitrary keys in _j can raise exceptions and crash the process.
   - Information disclosure via logs (lines 48, 65–66): prints internal sp_end_point and role changes, aiding reconnaissance/log injection if fields are attacker-controlled.
   - Trust boundary: behavior controlled by environment (lines 74–83). OVERSEER_STORE can switch to SQL/other backends; if attackers influence env/process launch, they may pivot to weaker stores.
3. N/A
4. Uncertain whether load_yaml is safely implemented (SafeLoader vs. unsafe), and whether inputs to _3/_4 come from trusted, authenticated callers; impact depends on those contexts.

",1,1,58.77834486961365
