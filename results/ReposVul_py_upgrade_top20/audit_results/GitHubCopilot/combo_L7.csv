file_name,audit_report,input_token_num,output_token_num,inference_time
11_ElGamal.py,"1. YES
2. - On-chain secret exposure (critical) – Solidity lines 4, 13, 21: x and K are passed as public tx inputs, leaking private key and nonce; encryption nonce K must be secret. 
   - No authenticated encryption / malleable ElGamal (CCA-unsafe) – Python lines 61–64; Solidity lines 4–11: raw ElGamal used directly on M without padding/KDF/MAC, allowing ciphertext malleability and CCA attacks. 
   - Weak signature scheme (no hashing of message) – Python lines 73–84 (uses M directly at 80); Solidity lines 21–31 (uses M at 25): enables structural forgeries and standard ElGamal requires H(M) mod p−1. 
   - Nonce misuse risk for signatures/encryption – Python lines 49–56, 61–64, 73–84; Solidity lines 4–11, 21–31: K is caller-supplied with no enforcement of uniqueness/unpredictability; reuse/predictability reveals x. 
   - Incorrect modular inverse math – Solidity line 16 (uses p-3 instead of p-2 for inverse mod p) and line 27 (uses p1-2 mod p1; p1 not prime), leading to incorrect/undefined results and potential misuse. 
   - Missing domain parameter validation – Solidity lines 4, 13, 21, 33: no checks that p is prime/safe prime or g has correct order; enables small-subgroup/invalid-parameter attacks in protocols using these routines. 
   - DoS/logic bug in verification – Python lines 86–88: uses undefined variable p instead of self.p, causing runtime failure in verify. 
   - Use of deprecated library – Python lines 1–2: PyCrypto is unmaintained with known CVEs; unsafe for new code.
3. N/A
4. N/A

",1,1,86.68752217292786
14_static.py,"1. YES.
2. - Null pointer dereference/DoS: in normpath: ""char* real_path = realpath(path.c_str(), nullptr);"" followed by ""std::string normalized(real_path);"" and ""free(real_path);"" without checking real_path for nullptr; reason: realpath can fail and return nullptr, dereferencing crashes the process. - Use of uninitialized memory/logic bypass: member ""long _mtime;"" is never initialized in constructor and is read in manifest(): ""if (_mtime == 0 || mtime > _mtime)""; reason: undefined behavior may skip/trigger reload unpredictably. - Unbounded file read/possible memory exhaustion: in get_manifest: ""std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());"" with no size limit or open/error checks; reason: attacker-controlled large file can exhaust memory or read from an unintended file if manifest_path is user-influenced. - Ignored JSON parse errors/unsafe use of untrusted data: in parse_manifest the block ""if (!reader->parse(...)) { // Handle errors }"" does nothing and code proceeds to use root; reason: malformed JSON can produce unexpected state and downstream logic risks. - Path normalization pitfalls for access control: in normcase: converting paths to lowercase for security comparisons can enable bypasses on case-sensitive filesystems; reason: case-folding before comparisons can misclassify allowed vs. disallowed paths.
3. N/A.
4. N/A.

",1,1,35.14124894142151
55_pathutils.py,"1. YES

2. - DoS/Undefined Behavior: sanitizePath uses path.back() without checking emptiness (line with std::string trailing_slash = path.back() == '/' ? ""/"" : """";). Reason: path.back() on an empty string is undefined behavior and can crash the program.
   - Information disclosure/DoS: sanitizePath calls boost::filesystem::canonical(p) on untrusted input without handling errors (line with p = boost::filesystem::canonical(p);). Reason: canonical throws on non-existent/inaccessible paths, enabling path existence probing or crashing the service if uncaught.
   - Log injection/sensitive data exposure: pathToFilesystem logs unsanitized user input (line with std::cerr << ""Can't translate path safely to filesystem: "" << path). Reason: attacker-controlled strings (including newlines/control chars) can forge/poison logs and leak inputs.
   - DoS via logic error: pathToFilesystem splits a leading “/” into an empty token then rejects it, consistently throwing for non-empty sanitized paths (lines with token = sane_path.substr(0, pos); and if (!isSafeFilesystemPathComponent(token)) { throw ... }). Reason: absolute paths yield an empty first token, causing predictable exceptions and easy DoS.
   - Path parsing robustness issue (Windows): Mixing boost::filesystem with manual ""/"" building/splitting (lines building new_path with ""/"" and using delimiter ""/"") mishandles drive letters/UNC paths. Reason: can mis-parse or reject valid Windows paths, increasing crash/DoS surface.

3. N/A

4. N/A

",1,1,61.81855463981629
111_general.py,"1. NO
3. Reason: The aggregates use Django ORM’s expression system and parameter binding (e.g., Value for delimiters), with constant function names and templates, which prevents SQL injection; there’s no unsafe eval/IO/crypto/deserialization or trust boundary violations in this snippet.

",1,1,22.206992626190186
116_utils.py,"1. YES
2. - Unsafe native code execution: lines ~82-87 (inline_asm_example); executes raw machine code via ctypes, enabling arbitrary code execution if the byte buffer is influenced and violating DEP/W^X assumptions.
   - Insecure config/deserialization and fail-open: lines ~9-14 (load_privilege); AUTHZ_FILE controls arbitrary file path and load_yaml(privilege_file) may use unsafe YAML loader (RCE risk), and bare except defaults to empty dict, potentially bypassing authorization on parse errors.
   - Missing authZ/authN for critical operations: lines ~26-50 and ~52-69 (simple_PSP_policy, promote_sp); accepts input and promotes/demotes primary SP and assigns session IDs without verifying identity, enabling spoofing/privilege escalation.
   - Potential injection via data layer: lines ~28, ~44, ~53; untrusted fields passed to get_sp_by could lead to SQL/Redis injection if backend stores interpolate unsafely.
   - Information disclosure: lines ~46, ~63-64; printing sp_end_point leaks potentially sensitive service topology to logs.
   - DoS/robustness: line ~19; datetime.fromisoformat on untrusted last_heartbeat can raise and disrupt availability if not handled upstream.
3. N/A
4. Note: The deserialization risk depends on nvflare.lighter.utils.load_yaml (if it uses yaml.safe_load, RCE risk is reduced).

",1,1,43.66250443458557
