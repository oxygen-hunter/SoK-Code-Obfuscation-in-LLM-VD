file_name,audit_report,input_token_num,output_token_num,inference_time
11_ElGamal.py,"1. YES
2. Vulnerabilities: (a) 64-bit truncation of big integers in modular exponentiation making keys effectively ≤64-bit and breaking security (lines: elgamal_dll.powmod.argtypes = (ctypes.c_uint64, ...), elgamal_dll.powmod.restype = ctypes.c_uint64; all calls to elgamal_dll.powmod in _encrypt/_decrypt/_sign/_verify/generate); (b) Weak private-key selection allowing x = p−1 ⇒ y = 1, leaking plaintext on “encryption” (line: obj.x = number.getRandomRange(2, obj.p - 1, randfunc)); (c) No validation of K in _encrypt permits K=0 and plaintext recovery; API relies on caller-supplied K for encrypt/sign enabling weak RNG/reuse attacks that can recover x (lines: def _encrypt(self, M, K):, def encrypt(self, plaintext, K):, def sign(self, M, K):, def _sign(self, M, K):); (d) construct accepts unvalidated parameters (p/g/y/x) allowing invalid/weak keys (line: def construct(tup): ... setattr(...)); (e) Insufficient signature validation: no range check for sig[1]/b (line: def _verify(self, M, sig):); (f) Unsigned, unchecked native DLL load can enable DLL hijacking if the directory is writable (lines: dll_path = ..., elgamal_dll = ctypes.CDLL(dll_path)); (g) Use of deprecated PyCrypto pubkey API and likely non-constant-time operations risk side-channel/malleability.
3. N/A
4. N/A

",1,1,81.14453482627869
14_static.py,"1. YES
2. - Absolute path traversal (Windows): static_view.get_resource_name -> resource_path = normcase(normpath(join(self.norm_docroot, path))); reason: path elements aren’t checked for drive letters (e.g., ""C:""), so os.path.join treats ""C:/..."" as absolute and escapes docroot, enabling arbitrary file reads.
   - Null byte sanitization bypass: _invalid_element_chars = {'/', os.sep, '\\x00'} and _contains_invalid_element_char; reason: uses literal ""\\x00"" instead of the NUL byte '\x00', failing to block NULs and risking unexpected FS errors/DoS.
   - Potential reflected error/XSS: raise HTTPNotFound('Out of bounds: %s' % request.url); reason: echoes user-controlled URL in error detail which may reflect in error pages if not escaped by the framework/view.
   - Unsafe native function binding (unused but dangerous): libc = CDLL(""libc.so.6""); strcpy = libc.strcpy with c_char_p; reason: strcpy is inherently unsafe and could cause buffer overflows if later used with user input.
3. N/A
4. N/A

",1,1,70.60693717002869
55_pathutils.py,"1. YES
2. - Unsafe native call / buffer overflow (CWE-120/CWE-787) at lines ~40–44: uses ctypes.CDLL(""libc.so.6"") and libc.strcat on Python-managed buffers (safe_path.encode()), causing in-place writes to immutable memory and potential memory corruption/RCE/DoS.
   - DLL search order hijacking (CWE-427) at line ~40: loading ""libc.so.6"" by name can be hijacked via environment-controlled search paths (e.g., LD_LIBRARY_PATH), enabling arbitrary code execution.
   - NUL-byte/encoding misuse DoS (CWE-20/CWE-400) at lines ~44–45: attacker-controlled bytes (including b'\x00') passed to strcat and then decode() can truncate or crash; bytes/str mixing further increases crash risk.

",1,1,46.43110942840576
111_general.py,"1. NO
3. Reason: The aggregates use Django’s ORM which parameterizes inputs, and StringAgg wraps the delimiter with Value(), preventing SQL injection; OrderableAggMixin is a standard pattern and the template matches Django’s safe usage. The ctypes CDLL(None) handle is unused here, so it does not introduce a vulnerability in this snippet.

",1,1,25.33051323890686
116_utils.py,"1. YES
2. Vulnerabilities:
   - Untrusted native library loading (DLL hijacking/LD_PRELOAD risk): lines 6–11. Uses ctypes.CDLL with non-absolute names and no restricted search path, allowing attacker-controlled library loading.
   - Unauthenticated/unauthorized service registration and promotion: lines 42–66, 67–84. Any incoming_sp can create/update SP and become primary when none; promote_sp allows promotion without any authz checks.
   - Untrusted input passed to native code (memory corruption risk): lines 12–14, 49–57, 64–65, 80–81. Arbitrary-length, attacker-influenced bytes are sent to a C function without validation or length checks.
   - Insecure YAML loading path from environment (arbitrary file read / possible unsafe deserialization): lines 26–32. AUTHZ_FILE controls the file path; if load_yaml uses an unsafe loader this could enable code execution; at minimum allows reading attacker-chosen files.
   - Fail-open due to bare except on authz load: lines 28–31. Swallows all errors and defaults to empty privileges, potentially disabling authorization.
   - Information disclosure via logs: lines 24, 62, 78–79. Prints store selection and service endpoints, leaking operational details.
   - DoS via unhandled timestamp parsing: line 36. Malformed last_heartbeat can raise ValueError and crash update_sp_state.
   - Race condition (split-brain primary): lines 58–65. No synchronization when electing primary, allowing concurrent primaries.
3. N/A
4. N/A

",1,1,45.06770157814026
