file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
11_ElGamal.py,"1. YES
2. - Broken state isolation / secret leakage — `VM.load_program:13-14`, `VM.run:16-45`, `ElGamalobj.execute_vm:52-55`: the VM instance is reused without resetting `stack`, `registers`, `pc`, or `running`. After a program halts, `running` stays `False` and the old stack (which contains sensitive values like the private exponent) is returned on the next call. Any later operation such as `encrypt` therefore hands out leftover secrets instead of fresh results, fully exposing private key material.
   - Cryptographic failure — `VM.execute:22-45` together with `encrypt:57-75`, `decrypt:83-96`, `sign:107-126`, `verify:134-159`, `generate:164-205`: the VM never implements handlers for opcodes such as `CALL`, `MUL`, or `MOD`. Consequently the crypto routines never invoke `pow`, never perform modular arithmetic, and simply store previously pushed operands (e.g., the modulus `p`). Encryption ignores the plaintext and randomness, signatures aren’t computed, and key generation never produces real parameters, so confidentiality and authenticity collapse completely.
","CVE: CVE-2012-2417
CVE Description: PyCrypto before 2.6 does not produce appropriate prime numbers when using an ElGamal scheme to generate a key, which reduces the signature space or public key space and makes it easier for attackers to conduct brute force attacks to obtain the private key.
CWE: ['CWE-310']
CWE Description: 
",2.0,885.0,7.0,4.086474895477295
14_static.py,"1. YES
2. - Denial-of-Service (Resource exhaustion) — `static_view.py:17`, `static_view.py:77`, `static_view.py:84`, `static_view.py:92`: every request appends new instructions to the shared `VM.instructions` list and `VM.execute` never resets `pc` or trims old entries, so the instruction tape grows without bound; an attacker can send many requests to exhaust memory.
   - Denial-of-Service (Resource exhaustion) — `static_view.py:135-151`: with `reload` false (the default), `self.filemap` stores every requested `resource_name` even when no file exists, so repeated requests for random paths steadily grow the cache until memory is exhausted.
   - Input Validation / DoS — `static_view.py:179-183`: `_invalid_element_chars` checks for the literal string `'\\x00'` instead of the null byte `'\x00'`, so a request containing an embedded null is accepted and later triggers `ValueError: embedded null character` in filesystem calls, allowing an attacker to crash the view repeatedly.
3. N/A
4. N/A
","CVE: CVE-2023-40587
CVE Description: Pyramid is an open source Python web framework. A path traversal vulnerability in Pyramid versions 2.0.0 and 2.0.1 impacts users of Python 3.11 that are using a Pyramid static view with a full filesystem path and have a `index.html` file that is located exactly one directory above the location of the static view's file system path. No further path traversal exists, and the only file that could be disclosed accidentally is `index.html`. Pyramid version 2.0.2 rejects any path that contains a null-byte out of caution. While valid in directory/file names, we would strongly consider it a mistake to use null-bytes in naming files/directories. Secondly, Python 3.11, and 3.12 has fixed the underlying issue in `os.path.normpath` to no longer truncate on the first `0x00` found, returning the behavior to pre-3.11 Python, un an as of yet unreleased version. Fixes will be available in:Python 3.12.0rc2 and 3.11.5. Some workarounds are available. Use a version of Python 3 that is not affected, downgrade to Python 3.10 series temporarily, or wait until Python 3.11.5 is released and upgrade to the latest version of Python 3.11 series.
CWE: ['CWE-22']
CWE Description: 
",2.0,1105.0,7.0,0.8869278430938721
55_pathutils.py,"YES
- Path Traversal / Input Validation Bypass: code_obfuscation.py:35, code_obfuscation.py:43-89 – the VM’s `STORE` handler replaces the entire stack with the literal key (`self.stack = [args[0]]`), so later `LOAD ""path""`/`""split_path""` instructions operate on the string names, not the user-supplied value. All guard branches (`JZ` checks for `""""`, `.`, `..`, drive letters, etc.) therefore run against constant truthy values and never execute. Components such as `../../etc/passwd` are never stripped or rejected, so the sanitizer provides no protection against directory traversal.
- Security Control Bypass: code_obfuscation.py:78-89 – `compile_path_to_filesystem` pushes `ValueError(""Unsafe path"")` onto the stack but never raises it, and the function exits returning the literal `""error""`. Callers expecting an exception when the path is unsafe will continue executing with an unchecked path, defeating the intended safeguard.
","CVE: CVE-2016-1505
CVE Description: The filesystem storage backend in Radicale before 1.1 on Windows allows remote attackers to read or write to arbitrary files via a crafted path, as demonstrated by /c:/file/ignore.
CWE: ['CWE-21']
CWE Description: 
",4.0,839.0,7.0,0.7865657806396484
111_general.py,"1. YES  
2. - CWE-362 (race condition via shared mutable globals) — `aggregates.py:25`, `aggregates.py:70`, `aggregates.py:90`, `aggregates.py:104`  
    Reason: `compile_aggregation()` writes aggregator configuration (`function`, `allow_distinct`, `output_field`, `delimiter`, etc.) into the module `globals()`, and each aggregator’s `__init__` immediately reads those globals back. In a real Django deployment that serves concurrent requests, those globals are process-wide. An attacker who can trigger aggregator construction (e.g., via API queries) can race another request: after their `compile_aggregation()` call poisons the globals but before the victim request copies them, they hand the victim a mismatched `function`/`delimiter`. That forces the victim query to execute with attacker-controlled settings, yielding database errors (denial of service) or malformed results.
","CVE: CVE-2020-7471
CVE Description: Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.
CWE: ['CWE-89']
CWE Description: 
",2.0,890.0,7.0,0.9566755294799804
116_utils.py,"Vulnerable: YES

- Denial of Service (`code.py:20-27,29-32`): `POP`, `ADD`, `SUB`, and the jump opcodes trust that the stack and program counter always hold valid state. With attacker-controlled bytecode, a crafted sequence can trigger stack underflow or set `self.pc` out of range, raising uncaught exceptions (IndexError/TypeError) and crashing the service.
- Fail-Open Privilege Loading (`code.py:39-44`): `load_privilege()` swallows every exception from `load_yaml()` and falls back to an empty dict. If an attacker can point `AUTHZ_FILE` to an unreadable/invalid path (or delete/corrupt the file), the system silently continues with effectively “no restrictions,” defeating the privilege model.

Recommended next steps: 1) Harden the VM by validating stack depth and jump targets before executing untrusted instruction streams. 2) Make privilege loading fail closed—log the error, abort startup, or enforce a minimal-deny policy when the configuration cannot be parsed.
","CVE: CVE-2022-31605
CVE Description: NVFLARE, versions prior to 2.1.2, contains a vulnerability in its utils module, where YAML files are loaded via yaml.load() instead of yaml.safe_load(). The deserialization of Untrusted Data, may allow an unprivileged network attacker to cause Remote Code Execution, Denial Of Service, and Impact to both Confidentiality and Integrity.
CWE: ['CWE-502']
CWE Description: 
",2.0,876.0,7.0,1.21331787109375
