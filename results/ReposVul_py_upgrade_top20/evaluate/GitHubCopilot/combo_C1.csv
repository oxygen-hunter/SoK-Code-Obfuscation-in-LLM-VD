file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
11_ElGamal.py,"1. YES
2. - Improper nonce/randomness handling (caller-supplied K): lines 51, 53, 55-58, 64-72; reason: K not generated internally—reuse or K=0 enables plaintext disclosure in encryption and private key recovery in signatures.
   - Signature over raw message (no hashing): lines 64-72, 73-79; reason: signing M directly makes ElGamal signatures forgeable (not EUF-CMA); must use H(M).
   - Undefined variable in verify: line 74 uses p instead of self.p; reason: NameError/logic flaw enables verification bypass/DoS and lacks full range checks.
   - Brittle import/use of inverse: lines 62, 71; reason: inverse may be undefined in scope → runtime error/DoS; inconsistent with number.inverse used elsewhere.
   - No input validation on ciphertext/signature elements: lines 59-63, 73-79; reason: invalid values (e.g., M[0]=0) can cause inverse failure/timing differences → DoS/side-channel.
   - Malleable, unauthenticated encryption: lines 55-58; reason: raw ElGamal without MAC/KDF is IND-CPA only and malleable (attackers can tweak plaintext by scaling b).
   - Timing side-channels: lines 61, 69 (ops with secret x); reason: Python big-int pow/inverse not constant-time → potential key leakage via timing.
   - Broken construct/public key assembly: lines 35-40 (uses tuple builtin instead of tup); reason: raises TypeError, breaking publickey() and enabling DoS; also shadowing builtins (line 85 object=ElGamalobj) is unsafe.
3. N/A
4. N/A

","CVE: CVE-2012-2417
CVE Description: PyCrypto before 2.6 does not produce appropriate prime numbers when using an ElGamal scheme to generate a key, which reduces the signature space or public key space and makes it easier for attackers to conduct brute force attacks to obtain the private key.
CWE: ['CWE-310']
CWE Description: 
",4.0,1011.0,7.0,2.102365255355835
14_static.py,"1) YES. 2) Vulnerabilities: (1) Symlink traversal: get_resource_name returns filesystem paths via resource_path = normcase(normpath(join(self.norm_docroot, path))) and __call__ serves them with FileResponse(...) without verifying os.path.realpath(path).startswith(self.norm_docroot), allowing a symlink inside docroot to escape; (2) Null-byte sanitization bug: _invalid_element_chars = {'/', os.sep, '\\x00'} used by _contains_invalid_element_char/_secure_path does not block the real '\x00', so a decoded null byte can bypass checks and trigger ValueError in filesystem/resource APIs, causing 500 DoS; (3) Unbounded cache DoS: get_possible_files caches self.filemap[resource_name] unbounded when reload=False, letting attackers flood unique paths to exhaust memory; (4) Content negotiation flaw: find_best_match unconditionally adds None to acceptable_encodings even if client sent identity;q=0, potentially serving disallowed variants and risking cache inconsistencies when Vary is present. 3) N/A. 4) N/A.

","CVE: CVE-2023-40587
CVE Description: Pyramid is an open source Python web framework. A path traversal vulnerability in Pyramid versions 2.0.0 and 2.0.1 impacts users of Python 3.11 that are using a Pyramid static view with a full filesystem path and have a `index.html` file that is located exactly one directory above the location of the static view's file system path. No further path traversal exists, and the only file that could be disclosed accidentally is `index.html`. Pyramid version 2.0.2 rejects any path that contains a null-byte out of caution. While valid in directory/file names, we would strongly consider it a mistake to use null-bytes in naming files/directories. Secondly, Python 3.11, and 3.12 has fixed the underlying issue in `os.path.normpath` to no longer truncate on the first `0x00` found, returning the behavior to pre-3.11 Python, un an as of yet unreleased version. Fixes will be available in:Python 3.12.0rc2 and 3.11.5. Some workarounds are available. Use a version of Python 3 that is not affected, downgrade to Python 3.10 series temporarily, or wait until Python 3.11.5 is released and upgrade to the latest version of Python 3.11 series.
CWE: ['CWE-22']
CWE Description: 
",2.0,1087.0,7.0,0.9777803421020508
55_pathutils.py,"1. YES
2. - Symlink traversal / TOCTOU risk: lines 57–76 (esp. 68–71 and 76). Reason: Only per-component checks are done; the final path is returned without resolving or enforcing it stays within base_folder, allowing symlink-based escapes if an attacker can create symlinks inside base_folder.
   - Log injection / information disclosure: line 69. Reason: Logs untrusted path verbatim; embedded newlines/control chars can forge log lines or leak sensitive input.
   - Incomplete normalization on Windows if sanitize_path is used alone: lines 23–41. Reason: Uses posixpath and splits only on ""/"", so backslash-separated traversal (e.g., ""..\\.."") isn’t removed; unsafe if later used for filesystem/security decisions without additional checks.
3. N/A
4. N/A

","CVE: CVE-2016-1505
CVE Description: The filesystem storage backend in Radicale before 1.1 on Windows allows remote attackers to read or write to arbitrary files via a crafted path, as demonstrated by /c:/file/ignore.
CWE: ['CWE-21']
CWE Description: 
",4.0,801.0,7.0,0.7911257743835449
111_general.py,"1. NO
3. Reason: The code uses Django ORM Aggregates with constant function names and parameterized inputs (e.g., StringAgg wraps the delimiter in Value), avoiding dynamic SQL/string concatenation, eval/exec, or unsafe I/O. JSONField from contrib is deprecated but not a security risk.

","CVE: CVE-2020-7471
CVE Description: Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.
CWE: ['CWE-89']
CWE Description: 
",1.0,757.0,7.0,0.8947756290435791
116_utils.py,"1. YES.
2. - Missing authentication/authorization for SP registration and primary promotion: simple_PSP_policy(): update_sp({...}) when sp not found and later psp[""primary""] = True; promote_sp(): psp[""primary""] = True and current_psp[""primary""] = False; reason: any caller can register/overwrite SPs and force leadership without verification (privilege escalation/IDOR).
   - Potential unsafe YAML deserialization and untrusted file loading: load_privilege(): privilege = load_yaml(privilege_file) where privilege_file = os.environ[""AUTHZ_FILE""]; reason: if load_yaml uses an unsafe loader this can lead to code execution; even with safe loader, attacker-controlled env var can read arbitrary files.
   - Bare except hides authz load failures: load_privilege(): except: privilege = dict(); reason: silently defaulting to empty rules may weaken or bypass authorization if callers treat missing rules as permissive.
   - Race condition in primary election/promotion: simple_PSP_policy() and promote_sp() mutate “primary” without locking/uniqueness enforcement; reason: concurrent calls can create split-brain or overwrite a legitimate primary.
   - Information disclosure: print(f""{psp['sp_end_point']} online/promoted/demoted""); reason: leaks internal service endpoints and state to logs/stdout.

","CVE: CVE-2022-31605
CVE Description: NVFLARE, versions prior to 2.1.2, contains a vulnerability in its utils module, where YAML files are loaded via yaml.load() instead of yaml.safe_load(). The deserialization of Untrusted Data, may allow an unprivileged network attacker to cause Remote Code Execution, Denial Of Service, and Impact to both Confidentiality and Integrity.
CWE: ['CWE-502']
CWE Description: 
",2.0,929.0,7.0,1.0009210109710691
