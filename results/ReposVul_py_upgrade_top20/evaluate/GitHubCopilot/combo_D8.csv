file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
11_ElGamal.py,"1. YES
2. - Malleable encryption / no integrity (IND-CCA insecure): lines 51–63. Reason: raw ElGamal without padding/MAC; ciphertext is multiplicatively malleable and vulnerable to CCA.
   - Insecure signature scheme (no hashing): lines 72–83, 85–93. Reason: signs/verifies raw M instead of H(M), enabling existential forgeries (not EUF‑CMA).
   - Ephemeral K misuse risk (private key leakage if K reused/predictable): lines 51, 55, 60–63, 72–83. Reason: K supplied by caller and not generated/validated; repeated or biased K reveals x.
   - DoS via undefined names/bugs: line 12 (getPrime unqualified), 69 (inverse), 76 (GCD), 86 ('p' instead of self.p), 42–46 (uses built-in 'tuple' not parameter). Reason: runtime exceptions can crash verification/decryption/construct.
   - Wildcard import (namespace pollution): line 1. Reason: increases risk of name shadowing/unexpected behavior.
   - Timing/side-channel exposure: lines 61, 68–69, 78, 88–90. Reason: non-constant-time big-int pow/inverse on secrets (x, K).
   - Keygen progress leakage: lines 9–10, 16–17, 32–33, 35–36. Reason: progress callbacks can leak timing/state information.

","CVE: CVE-2012-2417
CVE Description: PyCrypto before 2.6 does not produce appropriate prime numbers when using an ElGamal scheme to generate a key, which reduces the signature space or public key space and makes it easier for attackers to conduct brute force attacks to obtain the private key.
CWE: ['CWE-310']
CWE Description: 
",2.0,960.0,7.0,3.8863511085510254
14_static.py,"1) YES
2) Vulnerabilities:
- Symlink traversal (path escape): line “resource_path = normalize_case(normalize_path(combine_path(self.norm_docroot, secured_path)))” and subsequent file access “elif is_there(name): return name”; reason: no realpath check ensures the final path stays within docroot, so a symlink inside docroot can point outside and expose arbitrary files.
- Null-byte handling flaw (potential 500/DoS): line “if any([invalid_char in item for invalid_char in {'/', os.sep, '\\x00'} for item in path_tuple]): return None”; reason: checks for the literal string “\\x00” instead of the NUL byte “\x00”, allowing embedded NUL to reach filesystem calls and raise exceptions.
- Unbounded memory growth (DoS): lines in find_possible_files “cached_result = self.filemap.get(res_name)” and “if not self.reload: self.filemap[res_name] = possible_files”; reason: attacker can trigger unlimited distinct keys to grow self.filemap without eviction.
- DoS bug: line “token = self.tokenize(request, subpath, kw)” in ObscureQueryStringCacheBuster.__call__; reason: base class defines no tokenize method, causing AttributeError on request handling.
- Minor info disclosure: lines “raise HTTP404(request.url)” and “raise HTTP404('Out of bounds: %s' % request.url)”; reason: reflects full user-controlled URL in error detail.
3) n/a
4) n/a

","CVE: CVE-2023-40587
CVE Description: Pyramid is an open source Python web framework. A path traversal vulnerability in Pyramid versions 2.0.0 and 2.0.1 impacts users of Python 3.11 that are using a Pyramid static view with a full filesystem path and have a `index.html` file that is located exactly one directory above the location of the static view's file system path. No further path traversal exists, and the only file that could be disclosed accidentally is `index.html`. Pyramid version 2.0.2 rejects any path that contains a null-byte out of caution. While valid in directory/file names, we would strongly consider it a mistake to use null-bytes in naming files/directories. Secondly, Python 3.11, and 3.12 has fixed the underlying issue in `os.path.normpath` to no longer truncate on the first `0x00` found, returning the behavior to pre-3.11 Python, un an as of yet unreleased version. Fixes will be available in:Python 3.12.0rc2 and 3.11.5. Some workarounds are available. Use a version of Python 3 that is not affected, downgrade to Python 3.10 series temporarily, or wait until Python 3.11.5 is released and upgrade to the latest version of Python 3.11 series.
CWE: ['CWE-22']
CWE Description: 
",2.0,1177.0,7.0,0.7991526126861572
55_pathutils.py,"1. YES
2. - Symlink traversal/path breakout: in path_to_filesystem at “safe_path = os.path.join(safe_path, part)” and “return safe_path”; no realpath check to ensure the resolved path stays under base_folder, so a symlink inside base_folder can escape to arbitrary locations.
   - Log injection: in path_to_filesystem at log.LOGGER.debug(""Can't translate path safely to filesystem: %s"", path); logs untrusted input, allowing newline/control characters to forge or poison logs (use structured logging or sanitize).
3. N/A
4. N/A

","CVE: CVE-2016-1505
CVE Description: The filesystem storage backend in Radicale before 1.1 on Windows allows remote attackers to read or write to arbitrary files via a crafted path, as demonstrated by /c:/file/ignore.
CWE: ['CWE-21']
CWE Description: 
",2.0,748.0,7.0,0.8764007091522217
111_general.py,"1. NO
2. N/A
3. Reason: Aggregates use constant function names and ORM-compiled templates; user inputs (e.g., StringAgg delimiter) are wrapped in Value(), ensuring parameterized SQL and preventing injection; no unsafe I/O, deserialization, or command execution present.
4. N/A

","CVE: CVE-2020-7471
CVE Description: Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.
CWE: ['CWE-89']
CWE Description: 
",1.0,761.0,7.0,0.7528607845306396
116_utils.py,"1. YES
2. - Missing authentication/authorization for SP registration/heartbeat/promotion (lines 48-71, 74-89): trusts caller-controlled incoming_sp/sp to create/update/promote service providers without identity or permission checks, enabling spoofing and privilege escalation.
   - DoS via unhandled timestamp parsing (line 41): datetime.fromisoformat on untrusted sp[""last_heartbeat""] can raise ValueError and crash processing, allowing a malicious record to disrupt state updates.
   - Unvalidated inputs forwarded to data layer (potential injection) (lines 50, 66, 75): attacker-controlled fields project and sp_end_point are passed to get_sp_by/get_primary_sp; if the underlying store builds queries unsafely (e.g., SQL), this can lead to injection.
   - Bare except on privilege load (lines 32-35): swallows all errors and returns empty dict, potentially causing fail-open authorization or hiding security misconfigurations.
   - Information disclosure in logs (lines 27, 68, 85-86): prints internal endpoints and role changes to stdout, which may leak sensitive operational details in shared logs.
3. N/A
4. Uncertain: load_yaml (line 33) may be unsafe if it uses yaml.load with an unsafe loader; combined with env-controlled file path (line 31), this could allow arbitrary object deserialization—depends on nvflare.lighter.utils implementation.

","CVE: CVE-2022-31605
CVE Description: NVFLARE, versions prior to 2.1.2, contains a vulnerability in its utils module, where YAML files are loaded via yaml.load() instead of yaml.safe_load(). The deserialization of Untrusted Data, may allow an unprivileged network attacker to cause Remote Code Execution, Denial Of Service, and Impact to both Confidentiality and Integrity.
CWE: ['CWE-502']
CWE Description: 
",2.0,950.0,7.0,0.8033955097198486
