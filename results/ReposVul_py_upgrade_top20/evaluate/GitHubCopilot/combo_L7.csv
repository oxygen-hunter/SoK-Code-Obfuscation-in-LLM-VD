file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
11_ElGamal.py,"1. YES
2. - On-chain secret exposure (critical) – Solidity lines 4, 13, 21: x and K are passed as public tx inputs, leaking private key and nonce; encryption nonce K must be secret. 
   - No authenticated encryption / malleable ElGamal (CCA-unsafe) – Python lines 61–64; Solidity lines 4–11: raw ElGamal used directly on M without padding/KDF/MAC, allowing ciphertext malleability and CCA attacks. 
   - Weak signature scheme (no hashing of message) – Python lines 73–84 (uses M directly at 80); Solidity lines 21–31 (uses M at 25): enables structural forgeries and standard ElGamal requires H(M) mod p−1. 
   - Nonce misuse risk for signatures/encryption – Python lines 49–56, 61–64, 73–84; Solidity lines 4–11, 21–31: K is caller-supplied with no enforcement of uniqueness/unpredictability; reuse/predictability reveals x. 
   - Incorrect modular inverse math – Solidity line 16 (uses p-3 instead of p-2 for inverse mod p) and line 27 (uses p1-2 mod p1; p1 not prime), leading to incorrect/undefined results and potential misuse. 
   - Missing domain parameter validation – Solidity lines 4, 13, 21, 33: no checks that p is prime/safe prime or g has correct order; enables small-subgroup/invalid-parameter attacks in protocols using these routines. 
   - DoS/logic bug in verification – Python lines 86–88: uses undefined variable p instead of self.p, causing runtime failure in verify. 
   - Use of deprecated library – Python lines 1–2: PyCrypto is unmaintained with known CVEs; unsafe for new code.
3. N/A
4. N/A

","CVE: CVE-2012-2417
CVE Description: PyCrypto before 2.6 does not produce appropriate prime numbers when using an ElGamal scheme to generate a key, which reduces the signature space or public key space and makes it easier for attackers to conduct brute force attacks to obtain the private key.
CWE: ['CWE-310']
CWE Description: 
",2.0,1050.0,7.0,1.2352941036224363
14_static.py,"1. YES.
2. - Null pointer dereference/DoS: in normpath: ""char* real_path = realpath(path.c_str(), nullptr);"" followed by ""std::string normalized(real_path);"" and ""free(real_path);"" without checking real_path for nullptr; reason: realpath can fail and return nullptr, dereferencing crashes the process. - Use of uninitialized memory/logic bypass: member ""long _mtime;"" is never initialized in constructor and is read in manifest(): ""if (_mtime == 0 || mtime > _mtime)""; reason: undefined behavior may skip/trigger reload unpredictably. - Unbounded file read/possible memory exhaustion: in get_manifest: ""std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());"" with no size limit or open/error checks; reason: attacker-controlled large file can exhaust memory or read from an unintended file if manifest_path is user-influenced. - Ignored JSON parse errors/unsafe use of untrusted data: in parse_manifest the block ""if (!reader->parse(...)) { // Handle errors }"" does nothing and code proceeds to use root; reason: malformed JSON can produce unexpected state and downstream logic risks. - Path normalization pitfalls for access control: in normcase: converting paths to lowercase for security comparisons can enable bypasses on case-sensitive filesystems; reason: case-folding before comparisons can misclassify allowed vs. disallowed paths.
3. N/A.
4. N/A.

","CVE: CVE-2023-40587
CVE Description: Pyramid is an open source Python web framework. A path traversal vulnerability in Pyramid versions 2.0.0 and 2.0.1 impacts users of Python 3.11 that are using a Pyramid static view with a full filesystem path and have a `index.html` file that is located exactly one directory above the location of the static view's file system path. No further path traversal exists, and the only file that could be disclosed accidentally is `index.html`. Pyramid version 2.0.2 rejects any path that contains a null-byte out of caution. While valid in directory/file names, we would strongly consider it a mistake to use null-bytes in naming files/directories. Secondly, Python 3.11, and 3.12 has fixed the underlying issue in `os.path.normpath` to no longer truncate on the first `0x00` found, returning the behavior to pre-3.11 Python, un an as of yet unreleased version. Fixes will be available in:Python 3.12.0rc2 and 3.11.5. Some workarounds are available. Use a version of Python 3 that is not affected, downgrade to Python 3.10 series temporarily, or wait until Python 3.11.5 is released and upgrade to the latest version of Python 3.11 series.
CWE: ['CWE-22']
CWE Description: 
",2.0,1169.0,7.0,0.894136905670166
55_pathutils.py,"1. YES

2. - DoS/Undefined Behavior: sanitizePath uses path.back() without checking emptiness (line with std::string trailing_slash = path.back() == '/' ? ""/"" : """";). Reason: path.back() on an empty string is undefined behavior and can crash the program.
   - Information disclosure/DoS: sanitizePath calls boost::filesystem::canonical(p) on untrusted input without handling errors (line with p = boost::filesystem::canonical(p);). Reason: canonical throws on non-existent/inaccessible paths, enabling path existence probing or crashing the service if uncaught.
   - Log injection/sensitive data exposure: pathToFilesystem logs unsanitized user input (line with std::cerr << ""Can't translate path safely to filesystem: "" << path). Reason: attacker-controlled strings (including newlines/control chars) can forge/poison logs and leak inputs.
   - DoS via logic error: pathToFilesystem splits a leading “/” into an empty token then rejects it, consistently throwing for non-empty sanitized paths (lines with token = sane_path.substr(0, pos); and if (!isSafeFilesystemPathComponent(token)) { throw ... }). Reason: absolute paths yield an empty first token, causing predictable exceptions and easy DoS.
   - Path parsing robustness issue (Windows): Mixing boost::filesystem with manual ""/"" building/splitting (lines building new_path with ""/"" and using delimiter ""/"") mishandles drive letters/UNC paths. Reason: can mis-parse or reject valid Windows paths, increasing crash/DoS surface.

3. N/A

4. N/A

","CVE: CVE-2016-1505
CVE Description: The filesystem storage backend in Radicale before 1.1 on Windows allows remote attackers to read or write to arbitrary files via a crafted path, as demonstrated by /c:/file/ignore.
CWE: ['CWE-21']
CWE Description: 
",2.0,953.0,7.0,0.7833247184753418
111_general.py,"1. NO
3. Reason: The aggregates use Django ORM’s expression system and parameter binding (e.g., Value for delimiters), with constant function names and templates, which prevents SQL injection; there’s no unsafe eval/IO/crypto/deserialization or trust boundary violations in this snippet.

","CVE: CVE-2020-7471
CVE Description: Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.
CWE: ['CWE-89']
CWE Description: 
",1.0,752.0,7.0,0.807563066482544
116_utils.py,"1. YES
2. - Unsafe native code execution: lines ~82-87 (inline_asm_example); executes raw machine code via ctypes, enabling arbitrary code execution if the byte buffer is influenced and violating DEP/W^X assumptions.
   - Insecure config/deserialization and fail-open: lines ~9-14 (load_privilege); AUTHZ_FILE controls arbitrary file path and load_yaml(privilege_file) may use unsafe YAML loader (RCE risk), and bare except defaults to empty dict, potentially bypassing authorization on parse errors.
   - Missing authZ/authN for critical operations: lines ~26-50 and ~52-69 (simple_PSP_policy, promote_sp); accepts input and promotes/demotes primary SP and assigns session IDs without verifying identity, enabling spoofing/privilege escalation.
   - Potential injection via data layer: lines ~28, ~44, ~53; untrusted fields passed to get_sp_by could lead to SQL/Redis injection if backend stores interpolate unsafely.
   - Information disclosure: lines ~46, ~63-64; printing sp_end_point leaks potentially sensitive service topology to logs.
   - DoS/robustness: line ~19; datetime.fromisoformat on untrusted last_heartbeat can raise and disrupt availability if not handled upstream.
3. N/A
4. Note: The deserialization risk depends on nvflare.lighter.utils.load_yaml (if it uses yaml.safe_load, RCE risk is reduced).

","CVE: CVE-2022-31605
CVE Description: NVFLARE, versions prior to 2.1.2, contains a vulnerability in its utils module, where YAML files are loaded via yaml.load() instead of yaml.safe_load(). The deserialization of Untrusted Data, may allow an unprivileged network attacker to cause Remote Code Execution, Denial Of Service, and Impact to both Confidentiality and Integrity.
CWE: ['CWE-502']
CWE Description: 
",4.0,958.0,7.0,0.8320908546447754
