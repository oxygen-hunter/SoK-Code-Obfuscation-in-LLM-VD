file_name,audit_report,input_token_num,output_token_num,inference_time
17_access_control.sol,"1. YES  
2. Arbitrary delegatecall via user-controlled callee (`contract Proxy`, line 5). The `forward` function is public and never checks `msg.sender` (owner is unused), so any caller can supply a malicious `callee` and crafted `_data`. Because `delegatecall` runs in the proxy’s storage context, the attacker can execute arbitrary logic, overwrite storage (including `owner`), and fully compromise the contract.  
3. —  
4. —
",1,1,10.86050009727478
31_unchecked_low_level_calls.sol,"1. YES  
2. - `Missing authorization` – `airPort.sol:3` – the `transfer` function is `public` and never checks that `msg.sender` is the `from` address (or otherwise authorized). Once a user grants this contract an allowance, any attacker can invoke `transfer` and redirect that user’s tokens to arbitrary `_tos` recipients.  
   - `Unchecked low-level call` – `airPort.sol:7` – uses `caddress.call(...)` without inspecting the returned `bool`. Failed token transfers or calls to malicious/non-contract addresses will silently succeed, causing the function (which always returns `true`) to report success even when no transfer happened.
",1,1,21.394050121307373
38_unchecked_low_level_calls.sol,"YES  
- **Unprotected initializer / ownership takeover** – `TokenBank.sol` line 26 (`initTokenBank`) is `public` and lacks the `onlyOwner` guard. Any caller can invoke it after deployment, reset `owner = msg.sender`, and gain full administrative control (enabling arbitrary withdrawals or destructive configuration changes).  
- **Reentrancy & state corruption on withdrawal** – `TokenBank.sol` lines 44-48 (`WithdrawToHolder`) perform `_addr.call.value(_wei)` before updating `Holders[_addr]`. A hostile caller who first seizes ownership (see above) can point `_addr` to a reentrant contract, repeatedly reenter `WithdrawToHolder`, and drain the bank or drive `Holders[_addr]` into uint underflow. There is also no check on the call’s return value, so even a failed send still reduces the recorded balance.  
- **Unchecked token transfer call** – `Token.sol` line 20 (`WithdrawToken`) issues a raw `token.call(...)` without validating success. In `TokenBank.sol` line 40 `Holders[_to]` is zeroed before seeing whether the token transfer succeeds, so a failing or malicious token contract can make a holder lose their recorded balance without actually receiving tokens.
",1,1,91.24389123916626
48_unchecked_low_level_calls.sol,"1. YES  
2. - Missing access control — `contract demo.sol:3` — `transfer` is `public` and performs token movements without any caller authentication, so any user can trigger transfers from a `from` address that has approved this contract, letting attackers drain approved balances.  
   - Unchecked low-level call — `contract demo.sol:7` — uses `caddress.call(...)` but never checks the returned success flag, so failed or reverted token transfers go unnoticed and the function still returns success, breaking expected guarantees and enabling silent failures.
",1,1,24.35500979423523
127_time_manipulation.sol,"1. YES  
2. - Timestamp dependence (line 4): `block.timestamp` is miner-controlled within a small window, so relying on it to conclude the crowdsale lets a miner finish (or keep open) the sale slightly early/late.  
3. Not applicable.  
4. Not applicable.
",1,1,17.16124701499939
