file_name,audit_report,input_token_num,output_token_num,inference_time
17_access_control.sol,"1. YES  
2. Vulnerability Type: Unrestricted `delegatecall` / Proxy takeover  
   Vulnerable Lines: `Proxy.forward` (around line 6)  
   Reason: `forward` is publicly callable and lacks any owner check, so anyone can trigger `delegatecall` with attacker‑controlled targets and calldata. Because `delegatecall` runs in the proxy’s storage/context, an attacker can overwrite state (e.g., seize ownership) or execute arbitrary logic, fully compromising the contract.
",1,1,8.136021852493286
31_unchecked_low_level_calls.sol,"1. YES
2. - `Missing authorization` (line 3): `transfer` is public and never enforces `msg.sender == from`, so once someone grants this contract an allowance, any attacker can call `transfer` and redirect those tokens to arbitrary `_tos`, draining the approved balance.
   - `Unchecked low-level call` (line 7): `caddress.call(id, from, _tos[i], v)` ignores the returned `bool`, so failed or reverted token transfers are silently treated as successes, leaving callers with a false sense that funds moved.
3. —
4. —
",1,1,30.46001696586609
38_unchecked_low_level_calls.sol,"1. YES  
2. - Type: Unprotected initializer / ownership takeover; Lines: `TokenBank.sol:26-28`; Reason: `initTokenBank()` is public and resets `owner` to `msg.sender`, so any caller can seize control of the bank immediately after deployment.  
   - Type: Reentrancy with integer underflow; Lines: `TokenBank.sol:44-49`; Reason: `_addr.call.value(_wei)` forwards all gas before balances are decremented, letting a malicious owner-controlled contract reenter `WithdrawToHolder`, satisfy `onlyOwner`, and trigger multiple decrements that underflow `Holders[_addr]`, enabling indefinite withdrawals of others’ funds.  
   - Type: Unchecked low-level call (ETH); Lines: `TokenBank.sol:47-48`; Reason: The return value of `_addr.call.value(_wei)` is ignored, so failed sends still reduce `Holders[_addr]`, permanently desynchronizing accounting and locking depositor funds in the contract.  
   - Type: Unchecked low-level call (token); Lines: `Token.sol:19-21`; Reason: `WithdrawToken` uses `token.call(...)` without verifying success, allowing silent failure of token transfers and subsequent accounting corruption when `WitdrawTokenToHolder` zeroes balances.  
   - Type: Balance deletion before confirming token transfer; Lines: `TokenBank.sol:38-42`; Reason: `Holders[_to]` is set to zero prior to ensuring `WithdrawToken` succeeded, so any token transfer failure erases the holder’s recorded balance without actually sending their tokens.  
   - Type: Integer overflow; Lines: `TokenBank.sol:34-35`; Reason: `Holders[msg.sender] += msg.value` lacks safe arithmetic in Solidity 0.4.18, so a holder can craft deposits that wrap the balance mapping and subvert withdrawal checks.
",1,1,86.41510725021362
48_unchecked_low_level_calls.sol,"1. YES  
2. - Type: Unchecked low-level call (`caddress.call`) – `contract demo`:7; ignores the boolean return value from the external call, so the loop keeps going and the function returns `true` even when `transferFrom` fails (e.g., target contract missing the function, reverting, or malicious). This can mislead callers into believing the transfers succeeded, leaving allowances or accounting in an unknown, unsafe state.
",1,1,16.28560161590576
127_time_manipulation.sol,"1. NO  
2. Function only compares the current block timestamp to a fixed constant; there are no external inputs, state changes, or value transfers to exploit, so no meaningful security risk arises.
",1,1,8.994294881820679
