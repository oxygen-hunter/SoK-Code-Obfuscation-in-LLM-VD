file_name,audit_report,input_token_num,output_token_num,inference_time
17_access_control.sol,"YES  
- Unrestricted `delegatecall` (arbitrary code execution/storage corruption) — `Proxy.sol:8-10` (`forward` function is `public`, takes attacker-controlled `callee` and `_data`, and performs `callee.delegatecall(_data)` without any owner or whitelist check. The callee runs in the proxy’s context, so a malicious contract can overwrite storage, seize ownership, or drain assets managed by this contract.)
",1,1,10.74410104751587
31_unchecked_low_level_calls.sol,"1. YES  
2. - Vulnerability Type: Missing access control, Lines: `airPort.sol:3-9`, Reason: `transfer` is public with no check that `msg.sender` matches `from`, so once `from` grants allowance, any caller can drain their tokens to arbitrary `_tos`.  
   - Vulnerability Type: Unchecked low-level call, Lines: `airPort.sol:7`, Reason: uses `caddress.call` without verifying the boolean return value, so failed or malicious calls silently succeed and can mask unsuccessful or harmful transfers.  
   - Vulnerability Type: Arbitrary code execution via DLL loading, Lines: `airport.py:5`, Reason: loading a DLL from the attacker-controlled `dll_path` allows execution of malicious native code in the process.  
3. Not applicable.  
4. Not applicable.
",1,1,31.676452159881592
38_unchecked_low_level_calls.sol,"1. YES
2. - Type: Unrestricted access control / ownership takeover; Lines: Solidity `TokenBank.initTokenBank` 26-29; Reason: public initializer lets any caller reset `owner` and seize full control (no guard or one-time check), enabling contract takeover and subsequent theft of Ether/tokens.
   - Type: Reentrancy via unsafe Ether send; Lines: Solidity `TokenBank.WithdrawToHolder` 44-49; Reason: uses low-level `_addr.call.value(_wei)` before updating `Holders[_addr]`, so a malicious new owner can reenter repeatedly and drain balances.
   - Type: Unchecked low-level token call / state corruption; Lines: Solidity `Token.WithdrawToken` 19-21 together with `TokenBank.WitdrawTokenToHolder` 38-42; Reason: relies on `token.call(...)` without checking the return value, yet zeroes the holder balance first—failed or malicious calls leave bookkeeping inconsistent and can facilitate further attacks.
   - Type: Unrestricted access control / ownership takeover; Lines: Python `TokenBank.initTokenBank` 9-11; Reason: mirrors the Solidity bug—any caller can reinitialize and assume ownership, gaining authority over downstream withdrawals.
   - Type: Reentrancy / state update after external call; Lines: Python `TokenBank.WithdrawToHolder` 21-25; Reason: external `mylib.send_value` executes before debiting the holder, so an owner-controlled recipient can reenter via callbacks and drain funds.
   - Type: Unchecked external call result / balance zeroing; Lines: Python `TokenBank.WitdrawTokenToHolder` 17-20; Reason: clears the holder’s balance prior to confirming `mylib.withdraw_token` succeeded, letting failures or malicious tokens desync balances and funds.
",1,1,81.35886526107788
48_unchecked_low_level_calls.sol,"1. YES
2. - Vulnerability Type: Missing access control; Location: demo.sol:3; Reason: `transfer` is `public` and accepts an arbitrary `from` address, so any caller can drain allowances previously granted to this contract by victims, enabling unauthorized token transfers.  
   - Vulnerability Type: Unchecked low-level call; Location: demo.sol:7; Reason: uses `caddress.call(...)` without verifying the returned status, so failed or malicious calls report success and can silently skip transfers.  
   - Vulnerability Type: Insecure dynamic library loading; Location: call_transfer.py:5; Reason: loads `./eth_interaction.so` via a relative path, allowing attackers to supply a malicious library in the working directory (classic DLL hijacking).
",1,1,30.414532899856567
127_time_manipulation.sol,"1. YES  
2. - Improper initialization / logic flaw — `TimedCrowdsale.sol:10-18` — `timestamp` is never set in assembly (`timestamp := timestamp` is a no-op), so `getTimestampFromC()` always returns `0`, making `block.timestamp >= 0` true and forcing `isSaleFinished()` to report the sale finished permanently (denial of service).  
   - Timestamp manipulation — `TimedCrowdsale.sol:4` — relying directly on `block.timestamp` in Solidity 0.4.25 lets miners skew the reported time within the block window, enabling them to end the crowdsale slightly earlier or later than intended.
",1,1,18.51831102371216
