file_name,audit_report,input_token_num,output_token_num,inference_time
17_access_control.sol,"1. YES
2. - Unrestricted delegatecall / arbitrary code execution (line 5): forward is public and calls callee.delegatecall(_data) without any access control or validation, allowing anyone to execute code in Proxy’s context to overwrite storage (e.g., owner at line 3), drain Ether, or selfdestruct the proxy.
   - Missing access control (lines 3, 5): owner is set but never enforced; forward lacks an onlyOwner check so any caller can trigger delegatecall.

",1,1,57.139702558517456
31_unchecked_low_level_calls.sol,"1. YES
2. - Unchecked low-level call return value (SWC-104) — line 7: caddress.call(id,from,_tos[i],v); Reason: ignores the boolean result, so failed transfers are silently skipped and the function still reports success.
   - Missing authorization/access control (SWC-105) — line 3: function transfer(...). Reason: anyone can trigger transfers from arbitrary from; if this contract has allowance, an attacker can spend from’s approved tokens; typically require(msg.sender == from) or onlyOwner.
   - Unbounded external calls loop / gas risk (SWC-128) — lines 6-7: for(uint i=0;i<_tos.length;i++){ ... call ... }. Reason: user-controlled array size can cause out-of-gas and non-atomic partial execution patterns.
   - External call to untrusted contract (reentrancy/external code execution surface) — line 7: caddress is user-supplied; calling arbitrary contracts in a loop expands attack surface; currently no state is modified, but this is dangerous if extended or if other contracts trust this result.
   - Misleading return value — line 9: return true;. Reason: returns true unconditionally even if some/all calls failed.

",1,1,85.80937266349792
38_unchecked_low_level_calls.sol,"1. YES
2. - Unprotected initializer/ownership takeover: function initTokenBank() public { owner=msg.sender; MinDeposit=1 ether; } — anyone can call this post-deploy to become owner and change settings (constructor is not used in 0.4.18).
   - Reentrancy and missing return check (check-effects-interactions violated): in WithdrawToHolder(...) use of _addr.call.value(_wei); then Holders[_addr]-=_wei; — external call before state update and no success check can enable reentrancy/lock funds; use transfer/send or check call result and update state before calling.
   - Unsafe token transfer via low-level call without success check: token.call(bytes4(sha3(""transfer(address,uint256)"")), to, amount); — can silently fail or be exploited by non-standard tokens; in WitdrawTokenToHolder it zeroes Holders[_to] before transfer, causing loss/inconsistency if transfer fails.
   - State variable shadowing/inconsistent access control: contract Token is Ownable { address owner=msg.sender; ... } — redeclares owner, causing ambiguity/inconsistency with onlyOwner modifier’s owner; in some compiler versions this won’t compile, in others it leads to incorrect authorization logic.
   - Weak onlyOwner modifier: modifier onlyOwner { if (owner == msg.sender) _; } — silently no-ops instead of reverting, enabling unnoticed failed admin ops and potential logic assumptions; should use require(owner == msg.sender).
   - Outdated compiler: pragma solidity ^0.4.18; — old compiler with known issues; upgrade to >=0.8.x for built-in overflow checks and safer patterns.
3. N/A
4. N/A

",1,1,106.01728987693788
48_unchecked_low_level_calls.sol,"1. YES
2. - Missing access control — line 1 (function transfer(...)) — anyone can trigger spending of allowances that ‘from’ granted to this contract, enabling arbitrary token drains.
   - Unchecked low-level call — line 1 (caddress.call(id, from, _tos[i], v[i])) — return value ignored, so failed/false transfers or calls to EOAs/non-compliant tokens are silently treated as success.
   - No input length validation — line 1 (only require(_tos.length > 0)) — lacks require(v.length == _tos.length), enabling out-of-bounds access/revert DoS.
   - External calls in unbounded loop — line 1 (for loop) — gas griefing/partial execution risk and reentrancy surface (even if no internal state).
   - Misleading success reporting — line 1 (return true) — returns true even if some/all transfers failed.
3. N/A
4. N/A

",1,1,64.7086968421936
127_time_manipulation.sol,"1. YES
2. - Timestamp dependence/manipulation (line: return block.timestamp>=1546300800;) — miners can slightly skew block.timestamp and influence time-based control flow.
   - Outdated/floating compiler pragma (line: pragma solidity ^0.4.25;) — allows compiling with vulnerable/buggy 0.4.x versions and is not pinned to a specific safe compiler.
   - Logic flaw (line: return block.timestamp>=1546300800;) — hardcoded past timestamp (2019-01-01) makes the sale always “finished,” potentially causing a permanent denial of functionality.
3. N/A
4. N/A

",1,1,94.74292612075806
