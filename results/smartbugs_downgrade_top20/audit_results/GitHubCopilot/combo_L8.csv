file_name,audit_report,input_token_num,output_token_num,inference_time
17_access_control.sol,"1. YES
2. - Untrusted delegatecall (arbitrary code execution/storage corruption/selfdestruct): lines 7–9, especially line 8 (`require(callee.delegatecall(_data));`) — caller controls callee and calldata, so code runs in Proxy’s context, can overwrite storage (e.g., owner), drain funds, or SELFDESTRUCT the Proxy.
   - Missing access control on forward: line 7 (`public`) — anyone can invoke the dangerous delegatecall; should be restricted (e.g., onlyOwner/allowlist).
   - Missing callee validation: lines 7–8 — no check that callee is a contract and non-zero; can cause revert/DoS or unexpected behavior.
3. N/A
4. N/A

",1,1,43.88721561431885
31_unchecked_low_level_calls.sol,"1. YES
2. Vulnerabilities:
   - Solidity (airPort):
     - Missing access control (lines 3, 7): anyone can trigger transferFrom using this contract’s allowance, enabling draining of approved tokens from arbitrary from addresses.
     - Unchecked low-level call and ignored result (lines 7, 9): uses caddress.call(...) without checking success and always returns true, enabling silent failures and expanding reentrancy surface.
     - Unbounded loop/DoS risk (lines 6–8): large _tos can exhaust gas causing partial execution; also outdated compiler ^0.4.24 (line 1) lacks built-in overflow checks and has known pitfalls.
   - Python (AirPort):
     - Unsafe DLL loading (line 5): ctypes.CDLL(dll_path) without safe search/validation enables DLL hijacking and arbitrary code execution.
     - Unsafe ctypes usage (lines 5, 12–13): no argtypes/restype and unchecked return can cause memory corruption/crashes and logic errors.
     - ABI/signature mismatch and logic flaw (lines 10, 12): 0xa9059cbb corresponds to transfer(address,uint256) but code passes from_addr,to,v (and ignores caddress), leading to incorrect calls/undefined behavior.

",1,1,75.31849908828735
38_unchecked_low_level_calls.sol,"1. YES

2. Vulnerabilities:
- Solidity (pragma ^0.4.18):
  - Reentrancy + CEI violation: in WithdrawToHolder: ""_addr.call.value(_wei);"" before ""Holders[_addr] -= _wei;"" (external call before state change; forwards gas; allows reentrancy drain).
  - Unchecked low-level call results: ""token.call(bytes4(sha3('transfer(address,uint256)')), to, amount);"" and ""_addr.call.value(_wei);"" (ignores return bool; can silently fail causing loss/inconsistency).
  - Owner variable shadowing/authorization confusion: ""contract Token is Ownable { address owner = msg.sender; }"" and ""function initTokenBank() public { owner = msg.sender; ... }"" (shadows Ownable.owner used by onlyOwner; init changes child owner, not the one checked by onlyOwner).
  - Anyone-callable initializer (no constructor): ""function initTokenBank() public"" (anyone can reinitialize Token.owner and MinDeposit; misconfiguration risk).
  - Integer overflow/underflow: ""Holders[msg.sender] += msg.value;"" and ""Holders[_addr] -= _wei;"" (Solidity 0.4.18 without SafeMath).
  - Authorization logic flaw: in WithdrawToHolder gate ""if(Holders[msg.sender] > 0)"" (checks caller’s holder balance, not target; brittle auth).
- Python:
  - Missing access control on privileged methods: ""def WitdrawTokenToHolder(...)"" and ""def WithdrawToHolder(...)"" (no owner/onlyOwner check; any caller with balance can trigger transfers).
  - Unchecked external call results: ""mylib.withdraw_token(...)"" and ""mylib.send_value(...)"" (no return/error handling; state updated regardless).
  - CEI/order bug: in WithdrawToHolder, ""mylib.send_value(_addr, _wei)"" before ""self.Holders[str(_addr)] -= _wei"" (can desync balances on failure; potential reentrancy via C boundary).
  - Fragile identity mapping: use of str(mylib.get_sender())/str(_addr) as keys (possible collisions/inconsistent normalization).

3. N/A

4. N/A

",1,1,97.41219854354858
48_unchecked_low_level_calls.sol,"1. YES

2. Vulnerabilities
- Solidity (L3) Missing access control: public transfer lets anyone trigger transferFrom on behalf of from if allowance exists, enabling arbitrary draining of approved tokens.
- Solidity (L7) Unchecked low-level call: caddress.call(...) return value ignored; failures/reverts/false returns are silently treated as success.
- Solidity (L6–L7) External calls in unbounded loop: multiple calls to untrusted contracts enable reentrancy/DoS/gas griefing.
- Solidity (L3, L6–L7) Length mismatch not validated: v[i] indexed without require(v.length == _tos.length), allowing forced revert/DoS.
- Solidity (L7) Arbitrary external call gadget: user-controlled caddress may execute fallback/non-ERC20 code unexpectedly.
- Solidity (L9) Misleading success: returns true regardless of per-iteration failures.

- Python (L5) Insecure library loading: ctypes.CDLL('./eth_interaction.so') uses a relative path, risking loading attacker-controlled library.
- Python (L6, L9) Integer truncation: uses ctypes.c_uint (32-bit) for ERC-20 amounts (uint256), causing overflow/wrong values.
- Python (L3, L11) Length mismatch not enforced: passes len(to_addresses) as count without verifying len(values) matches, risking OOB in C.
- Python (L11) No error handling: ignores native transfer return/status, masking failures.

3. N/A

4. N/A

",1,1,70.86145997047424
127_time_manipulation.sol,"1. YES
2. Vulnerabilities:
   - Timestamp dependence/miner manipulation (line 4): uses block.timestamp for critical logic; miners can skew it by ~15s to influence sale end.
   - Uninitialized local variable/DoS (lines 10, 15–17): timestamp is never set; assembly “timestamp := timestamp” is a no-op, so function returns 0, making isSaleFinished always true (sale permanently “finished”).
   - Misuse of inline assembly/impossible external C call (lines 11–16): EVM cannot call a C DLL; placeholder causes undefined behavior and breaks determinism, especially in a pure function.
   - Outdated compiler version (line 1): 0.4.25 is deprecated and lacks modern safety checks (e.g., built-in overflow checks), increasing risk surface.
3. N/A
4. N/A

",1,1,47.83223581314087
