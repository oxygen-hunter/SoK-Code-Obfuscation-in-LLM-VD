file_name,audit_report,input_token_num,output_token_num,inference_time
17_access_control.sol,"1. YES
2. - Unrestricted delegatecall / Arbitrary code execution (lines 7-8): forward is public and performs delegatecall to attacker-controlled callee with attacker-controlled data, executing in Proxy’s storage/balance context; this enables arbitrary storage writes (e.g., overwrite owner), draining funds, or triggering selfdestruct to kill the proxy and send funds to an attacker.
   - Missing access control on critical function (line 7): no onlyOwner/whitelist check restricts who can call forward.
   - No validation that callee is a contract (lines 7-8, minor): no extcodesize check can lead to unexpected reverts/DoS when called with EOAs.
3. N/A
4. N/A

",1,1,44.07647824287415
31_unchecked_low_level_calls.sol,"1. YES
2. - Missing access control (unauthorized token spending): lines 3, 7. Reason: transfer is public and does not verify msg.sender; anyone can trigger transferFrom from the “from” address if this contract has allowance, enabling arbitrary spending of approved funds.
   - Unchecked low‑level call result: line 7. Reason: caddress.call(...) return value is ignored, so failed/malicious calls and token transfer failures are silently accepted.
   - External call in loop with full gas forwarding (reentrancy/gas griefing DoS): lines 6–7. Reason: forwards all gas to an untrusted contract repeatedly without a reentrancy guard or gas limit, allowing reentry or gas exhaustion to disrupt execution.
   - No validation that caddress is a contract: lines 3, 7. Reason: calling an EOA or wrong address can no-op or fail silently, leading to misleading success and operational risk.
   - Always returns true regardless of outcomes: line 9. Reason: callers cannot detect partial/total failures, enabling misuse and masking errors.
3. N/A
4. N/A

",1,1,95.16230535507202
38_unchecked_low_level_calls.sol,"1. YES
2. - Access control confusion via owner shadowing (lines 4, 29, 45, 24): Token.owner shadows Ownable.owner, onlyOwner (line 24) checks Ownable.owner while initTokenBank sets Token.owner, causing inconsistent/unsafe authorization.
   - Unprotected initializer (lines 42–47): Anyone can call initTokenBank to set Token.owner and MinDeposit, enabling misconfiguration/DoS.
   - Unchecked low-level ETH call + reentrancy window (lines 85–86): _addr.call.value(_wei) forwards all gas, return value ignored, and state updated after the external call (reentrancy risk and fund accounting error on failure).
   - Unchecked token call (line 34): token.call(...transfer...) ignores return value; failures are silent and may enable reentrancy paths.
   - Funds/accounting bug (lines 68–71 + 34): Holders[_to] is zeroed before attempting token transfer; mapping tracks ETH, not tokens—failed token call loses user credit and even on success ETH balance is wrongly cleared.
   - DoS/logic error (line 81): Requires Holders[msg.sender] > 0 (i.e., owner must have a balance) to withdraw to holders, blocking withdrawals if owner hasn’t deposited.
   - Weak onlyOwner (line 24): Uses if(...)_; without revert, silently succeeds with no effect on unauthorized calls (poor auth feedback/possible gas grief).
   - Missing SafeMath (line 60): Potential overflow on Holders[msg.sender] += msg.value.
   - Outdated compiler (line 1): ^0.4.18 lacks modern safety checks and protections.
3. N/A
4. N/A

",1,1,279.4726474285126
48_unchecked_low_level_calls.sol,"1. YES
2. - Missing authorization: anyone can spend another user’s allowance via this contract; no check ties msg.sender to from (lines 3, 7), so if from approved this contract, any caller can drain via batch
   - Unchecked low-level call return (SWC-104): caddress.call(...) ignores success/failure, function still returns true, masking failed transfers (line 7)
   - Unbounded external calls in user-controlled loop (SWC-128): for-loop over _tos with external call each iteration can cause OOG/DoS and amplify reentrancy surfaces (lines 6–7)
   - No array length parity check: uses v[i] without require(_tos.length == v.length), risking out-of-bounds revert/DoS (lines 3, 6–7)
   - Outdated compiler version (SWC-102): pragma ^0.4.25 has known issues; upgrade to >=0.8.x (line 1)
   - Untrusted external call to arbitrary address without contract check: no code-size check on caddress; call may hit fallback or non-ERC20 and silently fail (lines 3, 7)
3. N/A
4. N/A

",1,1,96.45428848266602
127_time_manipulation.sol,"1. YES
2. - Timestamp dependence/block.timestamp manipulation — line with ""return block.timestamp >= 1546300800;"" — miners can slightly skew block timestamps, influencing when the sale is considered finished if this gates critical logic.
   - Hardcoded past timestamp — line with ""return block.timestamp >= 1546300800;"" — 1546300800 (2019-01-01 UTC) means isSaleFinished is permanently true after that date (now 2025-10-28), causing a logic/DoS risk if used to block purchases.
   - Outdated compiler pragma — ""pragma solidity ^0.4.25;"" — old compiler lacks modern safety checks and has known issues; upgrade to >=0.8.x.
3. N/A
4. N/A

",1,1,31.555073022842407
