file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
17_access_control.sol,"1. YES  
2. Arbitrary delegatecall via user-controlled callee (`contract Proxy`, line 5). The `forward` function is public and never checks `msg.sender` (owner is unused), so any caller can supply a malicious `callee` and crafted `_data`. Because `delegatecall` runs in the proxy’s storage context, the attacker can execute arbitrary logic, overwrite storage (including `owner`), and fully compromise the contract.  
3. —  
4. —
",access control,4.0,658.0,7.0,2.971567153930664
31_unchecked_low_level_calls.sol,"1. YES  
2. - `Missing authorization` – `airPort.sol:3` – the `transfer` function is `public` and never checks that `msg.sender` is the `from` address (or otherwise authorized). Once a user grants this contract an allowance, any attacker can invoke `transfer` and redirect that user’s tokens to arbitrary `_tos` recipients.  
   - `Unchecked low-level call` – `airPort.sol:7` – uses `caddress.call(...)` without inspecting the returned `bool`. Failed token transfers or calls to malicious/non-contract addresses will silently succeed, causing the function (which always returns `true`) to report success even when no transfer happened.
",unchecked low level calls,4.0,707.0,7.0,2.4712789058685303
38_unchecked_low_level_calls.sol,"YES  
- **Unprotected initializer / ownership takeover** – `TokenBank.sol` line 26 (`initTokenBank`) is `public` and lacks the `onlyOwner` guard. Any caller can invoke it after deployment, reset `owner = msg.sender`, and gain full administrative control (enabling arbitrary withdrawals or destructive configuration changes).  
- **Reentrancy & state corruption on withdrawal** – `TokenBank.sol` lines 44-48 (`WithdrawToHolder`) perform `_addr.call.value(_wei)` before updating `Holders[_addr]`. A hostile caller who first seizes ownership (see above) can point `_addr` to a reentrant contract, repeatedly reenter `WithdrawToHolder`, and drain the bank or drive `Holders[_addr]` into uint underflow. There is also no check on the call’s return value, so even a failed send still reduces the recorded balance.  
- **Unchecked token transfer call** – `Token.sol` line 20 (`WithdrawToken`) issues a raw `token.call(...)` without validating success. In `TokenBank.sol` line 40 `Holders[_to]` is zeroed before seeing whether the token transfer succeeds, so a failing or malicious token contract can make a holder lose their recorded balance without actually receiving tokens.
",unchecked low level calls,4.0,826.0,7.0,1.7620835304260254
48_unchecked_low_level_calls.sol,"1. YES  
2. - Missing access control — `contract demo.sol:3` — `transfer` is `public` and performs token movements without any caller authentication, so any user can trigger transfers from a `from` address that has approved this contract, letting attackers drain approved balances.  
   - Unchecked low-level call — `contract demo.sol:7` — uses `caddress.call(...)` but never checks the returned success flag, so failed or reverted token transfers go unnoticed and the function still returns success, breaking expected guarantees and enabling silent failures.
",unchecked low level calls,4.0,677.0,7.0,0.841294527053833
127_time_manipulation.sol,"1. YES  
2. - Timestamp dependence (line 4): `block.timestamp` is miner-controlled within a small window, so relying on it to conclude the crowdsale lets a miner finish (or keep open) the sale slightly early/late.  
3. Not applicable.  
4. Not applicable.
",time manipulation,4.0,624.0,7.0,0.8805115222930908
