file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
17_access_control.sol,"YES  
- **Type**: Unrestricted delegatecall  
  - **Lines**: `forward` function (around forward signature and body: `function forward(bytes _data, address callee) public { bool success = callee.delegatecall(_data); require(success); }`)  
  - **Reason**: Any caller can invoke `forward` and supply an arbitrary `callee`, causing the contract to execute that address’s code in its own storage context via `delegatecall`. This grants attackers control over the proxy’s state/logic, enabling takeover or theft of assets/storage.
",access control,4.0,672.0,7.0,1.1715848445892334
31_unchecked_low_level_calls.sol,"YES  
- Unchecked low-level call result (`_1.call(...)`) at `transfer(...)` line 8: The contract uses `address.call` to invoke `transferFrom` on the token but never checks the returned `bool`. This suppresses errors from the token contract (including failed transfers or malicious reverts), so `transfer` will still return `true` even when no tokens moved, misleading callers and hiding failures.
",unchecked low level calls,4.0,649.0,7.0,0.8266160488128662
38_unchecked_low_level_calls.sol,"1. YES  
2. - Unprotected initializer takeover (`TokenBank.sol:16`): anyone can call `initTokenBank()` after deployment to reset `o.a` to themselves, permanently seizing `onlyOwner` privileges.  
   - Reentrancy-enabled drain (`TokenBank.sol:20`): `_addr.call.value(_wei)()` executes before balances are reduced, allowing a malicious holder to re-enter `WithdrawToHolder()` as owner and trigger multiple payouts before state is updated.  
   - Integer underflow on balance tracking (`TokenBank.sol:20`): the post-call `d.c[_addr] -= _wei;` runs after that reentrant window; repeated calls let `d.c[_addr]` wrap under zero, re-enabling withdrawals and draining the contract balance.
",unchecked low level calls,2.0,724.0,7.0,0.9117550849914552
48_unchecked_low_level_calls.sol,"1. YES
2. Vulnerability: Unchecked low-level call return value — `contract demo.sol:10`. The code uses `caddress.call(...)` without checking the returned boolean; if the external call fails, the function still returns true, so token transfers can silently fail and callers get a false sense of success.
",unchecked low level calls,4.0,629.0,7.0,0.8112099170684814
127_time_manipulation.sol,"1. NO  
3. The contract only exposes a `view` helper that compares the current block timestamp to a fixed cutoff, which is a standard pattern for time-bound logic. It neither handles funds nor mutates state, so there’s no exploitable condition in this snippet.
",time manipulation,1.0,617.0,7.0,0.978203296661377
