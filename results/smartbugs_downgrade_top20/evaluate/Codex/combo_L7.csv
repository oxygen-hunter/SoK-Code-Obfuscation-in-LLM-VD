file_name,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
17_access_control.sol,"1. YES  
2. Access control / arbitrary delegatecall injection — `forward` function (lines 7-13): the function is `public` and forwards to any `callee` via `delegatecall`, so any caller can execute arbitrary code in the proxy’s storage context (e.g., overwrite `owner`, drain funds), leading to full contract compromise.  
3. N/A  
4. N/A
",access control,4.0,644.0,7.0,1.6861693859100342
31_unchecked_low_level_calls.sol,"YES  
- Missing access control — `airPort.sol:3-16` — the public `transfer` function lets the caller supply `from`, `caddress`, and the recipient list, then performs token transfers via `transferFrom`. Once a token holder grants this contract allowance, any attacker can invoke `transfer` and redirect the victim’s tokens to arbitrary addresses, draining the allowance.
",unchecked low level calls,2.0,640.0,7.0,1.336658000946045
38_unchecked_low_level_calls.sol,"Yes. The contract has multiple high‑severity vulnerabilities.

- **Access Control Bypass** — `TokenBank.sol:17` : the `onlyOwner` modifier never reverts when `msg.sender` ≠ `owner`, so every `onlyOwner` function (owner change, ETH/token withdrawals) is callable by anyone.
- **Unauthorized Ownership Takeover** — `TokenBank.sol:43` : `initTokenBank()` is public and unprotected; any caller can immediately overwrite `owner` with their own address, giving themselves full control even if `onlyOwner` were fixed.
- **Reentrancy on ETH Withdraw** — `TokenBank.sol:75` : `WithdrawToHolder` sends ETH via `call` before reducing the stored balance, allowing the recipient to reenter (thanks to the broken modifier), repeatedly withdraw, and drain the vault.
",unchecked low level calls,2.0,735.0,7.0,1.2341833114624023
48_unchecked_low_level_calls.sol,"1. YES  
2. - Vulnerability type: Missing access control / authorization bypass  
     Vulnerable lines: demo.sol:3-21 (function `transfer`)  
     Reason: `transfer` is declared `public` and never checks `msg.sender`. Any caller can choose the `from` address and recipient list; if that address has approved this contract to spend its tokens, an attacker can drain the allowance by invoking this function.  
3. N/A  
4. N/A
",unchecked low level calls,2.0,662.0,7.0,3.144280433654785
127_time_manipulation.sol,"1. YES  
2. - Timestamp manipulation — `TimedCrowdsale.sol:6` — the sale end check relies on `timestamp` fetched via inline assembly; miners can skew `block.timestamp` slightly to end or extend the sale window, which is a known timestamp-dependence vulnerability.  
3. Not applicable  
4. Not applicable
",time manipulation,4.0,631.0,7.0,1.0229003429412842
