file_name,audit_report,input_token_num,output_token_num,inference_time
12_access_control.sol,"1. YES
2. Constructor misdefinition / ownership takeover – `missing`:5 – Under Solidity 0.4.24 constructors must match the contract name exactly (case-sensitive). Because `missing()` is lowercase, it remains an ordinary public function. Any caller can invoke it to overwrite `owner` with their own address, then pass the `onlyowner` modifier and withdraw all funds.
",1,1,15.861913681030272
19_access_control.sol,"1. YES  
2. Type: Missing constructor / insecure ownership (`function C()` at line 6). Reason: in Solidity 0.4.24 constructors must match the contract name; since `C` is just a public function, any account can call it after deployment to set `o` to themselves and then call `w()` to drain the entire balance.
",1,1,10.862226724624634
20_access_control.sol,"1. YES  
2. - `Improper access control` — `Wallet.sol:7-8`: `initWallet` is public and lacks any guard (e.g., `require(creator == address(0))`), so any caller can set or reset `creator` to themselves at any time. Once hijacked, the attacker gains creator privileges.
   - `Unauthorized funds migration` — `Wallet.sol:22-24`: Because `migrateTo` only checks `creator == msg.sender`, an attacker who first calls `initWallet` can immediately drain all Ether via `migrateTo`, sending the entire contract balance to an arbitrary address.
",1,1,37.45585989952088
62_unchecked_low_level_calls.sol,"1. YES
2. - Vulnerability: Missing access control on privileged withdrawals (`EtherGet.sol`:11-16). The functions `withdrawTokens` and `withdrawEther` are declared `public` without verifying `msg.sender == owner`, so any caller can trigger them. That lets arbitrary users withdraw all tokens and Ether held by the contract (albeit to the owner), defeating any expectation that only the owner should be able to initiate those operations.
",1,1,24.379329681396484
138_denial_of_service.sol,"YES
- Vulnerability: DoS (denial of service via unexpected revert); vulnerable code `DosAuction.bid` at `require(currentFrontrunner.send(currentBid));`; reason: if the current frontrunner is a contract whose fallback function intentionally reverts (e.g., by using `revert()` or exhausting the 2300 gas stipend), the `send` call fails and the `require` triggers, permanently blocking any new bids and freezing the auction.
",1,1,7.380338907241821
