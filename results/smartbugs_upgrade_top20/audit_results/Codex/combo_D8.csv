file_name,audit_report,input_token_num,output_token_num,inference_time
12_access_control.sol,"1. YES
2. - `unprotected-initialization` at `Missing.sol:11`: `missing()` was likely intended as the constructor, but in Solidity ≥0.4.22 constructors must use the `constructor` keyword. Because `missing()` is just a public function, any account can call it at any time to set `o` to their own address, gaining owner privileges. Once an attacker claims ownership, `withdraw()` (e.g. `Missing.sol:17`) lets them pull all contract funds via `transfer(this.balance)`.
",1,1,16.626075267791748
19_access_control.sol,"1. YES  
2. - Type: Misnamed constructor / unprotected ownership initialization (SWC-115)  
     Lines: `function Constructor() public { setOwner(getSender()); }`  
     Reason: In Solidity 0.4.24 constructors must either be named exactly `Missing` or use the `constructor` keyword. Because `Constructor` (capital C) is just a public function, anyone can call it at any time and set themselves as `dynamicOwner`, then call `withdraw()` to drain the contract.
",1,1,17.81815505027771
20_access_control.sol,"1. YES  
2. - Vulnerability: Unprotected initialization / ownership hijack — `Wallet.sol:5`, `Wallet.sol:10`  
     Reason: `initWallet()` is a public function that anyone can call at any time, overwriting `creatorAddress`. A malicious caller can set themselves as creator and then invoke `migrateTo()` to transfer the entire contract balance to an arbitrary address, draining all funds.
",1,1,18.224629878997803
62_unchecked_low_level_calls.sol,"1. YES  
2. - Vulnerability type: Missing access control (Improper Authorization) — `withdrawTokens` (line 10) and `withdrawEther` (line 15). Both functions are `public` and lack any `msg.sender` check, so any caller can empty the contract’s token and ether balances to `privateOwner`. This lets an attacker grief the contract by draining all assets at will, preventing the contract from operating as intended.  
   - Vulnerability type: Unchecked arbitrary external call / Reentrancy gadget — `getTokens` (lines 16-19). The function performs `addr.call.value(0)()` on attacker-controlled addresses with no return-value check, repeating it `num` times. This enables untrusted code execution with the contract as the caller (potentially abusing any trust other systems place in this contract) and makes the function succeed even if the external calls fail or reenter.
",1,1,198.44877791404724
138_denial_of_service.sol,"1. YES  
2. - Denial of Service (DoS) via external call — `DosAuction.sol:18` — `require(previousFrontrunner.send(previousBid));` refunds the previous frontrunner using `send`. A malicious frontrunner can deploy a contract whose fallback either consumes more than the 2300 gas stipend or deliberately reverts, causing `send` to fail. Because the failure triggers the surrounding `require`, every subsequent `bid()` reverts, permanently blocking the auction.
",1,1,9.492759943008425
