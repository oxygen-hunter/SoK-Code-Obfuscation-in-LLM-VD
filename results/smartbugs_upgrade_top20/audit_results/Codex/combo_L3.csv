file_name,audit_report,input_token_num,output_token_num,inference_time
12_access_control.sol,"YES  
- Broken access control — `missing()` at line 1 exposes the would-be constructor as a public function, so any caller can reset `owner` to themselves and then call `withdraw()` to drain all funds held by the contract.
",1,1,10.775738000869753
19_access_control.sol,"1. YES  
2. Vulnerability: `Incorrect constructor visibility` (`pragma solidity ^0.4.24;` `function Constructor()`) – lines 8-10. The function meant to be the constructor uses an uppercase name that does not match the contract name, so it is treated as a normal public function. Any caller can invoke it to set themselves as `owner` and then drain the contract via `withdraw()`.
",1,1,14.328171253204346
20_access_control.sol,"YES  
- Vulnerability: Unprotected initializer allows ownership takeover; `initWallet` at `Wallet.sol:5` is a publicly callable function that (re)assigns `creator` to whoever calls it, so any attacker can declare themselves the owner after deployment. Once they do, they can invoke `migrateTo` (`Wallet.sol:12`) and transfer the entire contract balance to an arbitrary address, draining all funds.
",1,1,17.871504306793213
62_unchecked_low_level_calls.sol,"1. YES  
2. - Missing function-level access control (`EtherGet.sol`:11,15): both `withdrawTokens` and `withdrawEther` are `public` without any `msg.sender` check, so any caller can trigger them and immediately move all stored tokens or Ether to the `owner` address. This lets an arbitrary user empty the contract’s balances, bypassing the intended owner-only control.  
   - Unrestricted external call with reentrancy surface (`EtherGet.sol`:19-20): `getTokens` performs a low-level `addr.call` inside a loop, forwarding all remaining gas and ignoring the return value. A malicious `addr` can reenter the contract (e.g., repeatedly invoking other public functions) or force excessive gas use, enabling denial-of-service patterns or unexpected state interactions.
",1,1,50.85004901885986
138_denial_of_service.sol,"1. YES
2. - Denial of Service via revert (`DosAuction.sol`: `require(currentFrontrunner.send(currentBid));`). The contract relies on `send`, which only forwards 2300 gas, and then requires it to succeed. A frontrunner can set a fallback that consumes more than 2300 gas (or deliberately reverts), forcing `send` to fail and reverting every subsequent `bid`, permanently locking the auction.
",1,1,10.512601852416992
