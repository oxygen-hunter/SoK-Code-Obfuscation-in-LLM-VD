file_name,audit_report,input_token_num,output_token_num,inference_time
12_access_control.sol,"1. YES
2. - Type: Unprotected owner initialization; Lines: `Missing.sol:8`; Reason: In Solidity 0.4.x constructors must match the contract name exactly, so `function missing()` is a normal public function that anyone can call to (re)set `owner`. Any caller can take over ownership and withdraw all funds via `withdraw()`, enabling unrestricted ether theft.
",1,1,23.53616595268249
19_access_control.sol,"1. YES  
2. Access control – misnamed constructor (`function Constructor() public { owner = msg.sender; }`, roughly line 8). In Solidity 0.4.x a legacy constructor must exactly match the contract name (`Missing`) or use the `constructor` keyword, so this function is just a publicly callable method that lets any caller set themselves as `owner` and subsequently call `withdraw()` to drain the contract.
",1,1,21.29918575286865
20_access_control.sol,"YES  
- Unauthorized initialization (`Wallet.sol`:6-8): `initWallet()` is a public function that anyone can call after deployment to set themselves as `creator`, because no constructor locks it to the deployer.  
- Privileged fund drain (`Wallet.sol`:15-19): Once an attacker captures `creator`, they can call `migrateTo()` and transfer the entire contract balance to an arbitrary address.
",1,1,15.775503158569336
62_unchecked_low_level_calls.sol,"1. YES
2. Missing access control — EtherGet.sol:12-17 — `withdrawTokens` and `withdrawEther` are public and never verify the caller, so any account can trigger these privileged withdrawals and empty the contract on demand, defeating any intended custody logic.  
   Unbounded recursion / DoS — EtherGet.sol:19-25 — `getTokens` lets a caller supply an arbitrary `num`, driving recursive `addr.call` executions; large inputs exhaust gas or hit the call-depth cap, so an attacker can repeatedly force the function to revert and deny its intended use.
",1,1,58.36390733718872
138_denial_of_service.sol,"YES  
- **Type**: Denial of Service via external call  
  **Location**: `DosAuction.sol:8`  
  **Reason**: `require(currentFrontrunner.send(currentBid));` sends funds to the previous frontrunner before updating state. Because `send` only forwards 2300 gas, a malicious frontrunner can force the call to fail (e.g. by a reverting fallback), causing the `require` to revert. That blocks all subsequent bids and locks the auction.
",1,1,14.533904552459717
