file_name,audit_report,input_token_num,output_token_num,inference_time
12_access_control.sol,"**Findings**
- `YES`
- `Insecure initialization | contract Missing:5`  
  Function `missing()` looks like a constructor but its casing does not match the contract name (`Missing`), so it is a public function that any user can call to seize ownership (`O = msg.sender`) and then withdraw all funds via `w()`.
",1,1,13.724546670913696
19_access_control.sol,"YES  
Access control flaw (`contract Missing`, line with `function Constructor() public { owner = msg.sender; }`): because the function name does not match the contract name, Solidity 0.4.24 treats it as a normal public function instead of the constructor. Any caller can invoke it first, set themselves as `owner`, and later drain all funds through `withdraw()`.
",1,1,10.546056747436523
20_access_control.sol,"1. YES  
2. - Type: Improper access control (unprotected initialization) | Lines: `Wallet.sol:5` | Reason: `initWallet()` is publicly callable with no one-time guard, so any account can (re)assign itself as `creator` after deployment and drain the contract via `migrateTo()`.  
   - Type: Unsafe dynamic library loading | Lines: `wallet.py:2` | Reason: `ctypes.CDLL('./wallet_c_lib.so')` loads a relative-path shared object without validation; an attacker controlling the working directory can supply a malicious `.so` and execute arbitrary native code.
",1,1,18.24976944923401
62_unchecked_low_level_calls.sol,"1. YES
2. - Type: Improper Authorization; Location: `withdrawTokens` (line 11) and `withdrawEther` (line 15); Reason: Functions that move all tokens/ether lack any owner check, letting any caller force a full withdrawal and disrupt intended control over when funds leave the contract.
   - Type: Reentrancy / Unchecked Low-Level Call; Location: `getTokens` (line 20); Reason: Uses `addr.call.value(0)()` without guarding or checking the return value, forwarding all gas and allowing the callee to re-enter contract functions (e.g., the withdrawal routines) or exhaust gas to disrupt execution.
   - Type: Insecure Dynamic Library Loading; Location: Python snippet `CDLL('./library.so')` (line 36); Reason: Loads a shared object from a relative path without validation, enabling DLL hijacking if an attacker can place a malicious library in the working directory.
3. —
",1,1,45.89704632759094
138_denial_of_service.sol,"YES  
- `Logic bug / locked funds` — `DosAuction.sol:8`, `DosAuction.sol:14`, `DosAuction.sol:24` — The contract assumes the previous frontrunner is refunded before updating state, but `externalSend` → `sendViaCDll` → `callCDll` never transfers Ether and just returns `true`. Every new winning bid therefore keeps the prior bidder’s stake permanently locked in the contract.
",1,1,40.64327073097229
