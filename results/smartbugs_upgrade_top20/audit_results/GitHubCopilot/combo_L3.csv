file_name,audit_report,input_token_num,output_token_num,inference_time
12_access_control.sol,"1. YES
2. - Misnamed constructor / unprotected ownership initialization (access control bypass): line 1: ""function missing() public {owner=msg.sender;}"" — In Solidity 0.4.24 constructors must match the contract name exactly; ""missing"" (lowercase) is a public function, so anyone can set themselves as owner at any time.
   - Unauthorized funds drain: line 1: ""function withdraw()public onlyowner{owner.transfer(this.balance);}"" — After seizing ownership via the above, an attacker can withdraw the entire balance.
3. N/A
4. N/A

",1,1,37.51206254959106
19_access_control.sol,"1) YES. 2) Vulnerabilities: (line 5) Incorrect constructor name 'Constructor' (should be Missing() or constructor()) lets anyone set owner and then call withdraw to drain funds; (line 7) Potential DoS to owner from address.transfer 2300-gas stipend if owner is a contract post-Istanbul causing withdrawals to revert.

",1,1,34.426026821136475
20_access_control.sol,"1. YES
2. - Unprotected initializer/owner takeover (function initWallet and migrateTo): initWallet() is public and can be called anytime to set or reset creator to the caller; then migrateTo() lets that caller drain all ETH via to.transfer(this.balance). 
   - Missing constructor/only-once guard (function initWallet): creator isn’t set in a constructor and there’s no “only once” check, so first/any caller becomes or replaces owner; funds sent before init can be stolen by the first caller.
   - Check-Effects-Interactions violation and transfer-based DoS (function withdraw): calls msg.sender.transfer(amount) before decrementing balance; transfer’s 2300-gas stipend can lock withdrawals for contract users and external call precedes state change.
   - Gas-inefficient overflow check (function deposit assert): uses assert(...) for overflow detection, which consumes all gas on failure; should use require/SafeMath (can be abused for griefing).
3. N/A
4. N/A

",1,1,37.29431509971619
62_unchecked_low_level_calls.sol,"1. YES
2. - Missing access control: lines ""function withdrawTokens(address tokenContract) public { ... }"" and ""function withdrawEther() public { ... }"" — anyone can trigger asset withdrawals (to owner), enabling griefing/front‑running and unexpected fund movements.
   - Unchecked token transfer: line ""tc.transfer(owner, tc.balanceOf(this));"" — return value is ignored; failures or non‑standard tokens can silently break withdrawals, and a malicious token implementation could reenter other public functions.
   - Arbitrary external call and unbounded loop: lines ""function getTokens(uint num, address addr) public { for (...) { addr.call.value(0 wei)(); } }"" — executes attacker‑controlled calls repeatedly without checking return value, enabling reentrancy into public functions and gas‑grief/DoS.
   - transfer gas‑stipend DoS: line ""owner.transfer(this.balance);"" — if owner is a contract with a costly fallback, transfer will revert, locking ether (classic 2300‑gas stipend DoS).
3. N/A
4. N/A

",1,1,32.45266056060791
138_denial_of_service.sol,"1. YES
2. DoS with (unexpected) revert / push-based refund: line 7 `if(currentFrontrunner!=0) {require(currentFrontrunner.send(currentBid));}` — a malicious or failing fallback can make send return false so require reverts, blocking all future bids; reliance on send’s 2300-gas stipend makes refunds brittle and enables intentional DoS. Also an interactions-before-effects anti-pattern exists (external call at line 7 before state updates at lines 8–9), which should be replaced with a pull-payment pattern and state updates before external calls.
3. N/A
4. N/A

",1,1,51.97672152519226
